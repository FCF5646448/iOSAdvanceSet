---
title: iOS-技能知识小集
date: 2020-5-9 17:36:48
tags: knoeledgePoints
categories: iOS进阶
description:  总结了OC学习当中的主要知识点。底层进阶相关的理论知识点为主
---

### UI相关
#### 图像显示原理
iOS的所有视图控件都是继承自UIView。根据“单一职责”的设计原则，真正负责显示的部分是CALayer。CALayer有一个id类型属性叫contents，它实际对应着一个CGImageRef（位图）。也就是说屏幕上显示每一帧都是由n张位图**合成**的。
* 每一帧画面的生成是由CPU和GPU合作完成的。
当视图树发生变化时，CPU会开始计算它的下一帧要显示的内容。包括视图的创建、布局计算、文本size等相关信息，然后绘制生成一个位图（这也可以在回调的drawRect里直接创建一张位图），如果是图片的话，还需要先进行**解码**，最后将图层进行打包，经由Core Animation提交给GPU。GPU的部分就是OpenGL渲染管线相关的工作。主要就包括**顶点着色**、**图元装配**、**几何着色**、**光栅化**、**片段着色**、**片段处理**等，最后将生成的像素点放到帧缓存区中。等到VSync信号到来之前，视图控制器就会去帧缓存区进行提取将要显示的内容。
#### UI卡顿掉帧的原因
在VSync信号到来后，系统会通过CADisplayLink等机制通知App。然后视图控制器就会去帧缓存区提取显示内容。那如果一个VSync信号周期内，CPU和GPU没能协作完成提交，那么那一帧就会被丢弃，此时屏幕就不会刷新，仍然显示之前的内容。这样就造成了卡顿。
* 按照苹果60FPS的刷帧率，每个16ms就会有一次VSync信号。
#### 卡顿优化
根据上面的图像显示原理，要保证不卡顿，则需要让CPU和GPU在16ms之内完成显示内容的生成。所以卡顿优化就主要从CPU和GPU两个方向入手：
##### CPU优化
* 尽量使用轻量级的对象，比如可以用CALayer取代UIView。
* 对象的创建、调整、销毁、UI的布局计算、文本计算等其他比较耗时的操作可以考虑放到子线程中进行；
* 尽量不要频繁修改UIVIew的frame、bounds等影响视图树的属性；
* Autolayout会比直接设置frame消耗更多CPU；
* 控制线程的最大并发数；
* 文本的**异步绘制**；
* 图片的编解码(比如：**SDWebImage编解码优化**)；
##### GPU优化
* 尽量避免出现**离屏渲染**；
* 根据视图合成的原理，可以在UI层面减少UI的层次和数量；
* 尽量避免短时间内显示大量图片，尽可能将多张图片合成一张进行显示；
* 尽量减少透明的视图；
[iOS性能优化](https://juejin.im/post/5b7a9c466fb9a019eb43b0d5)

#### 关键名词解析
* **合成**：是指一帧画面是由多种位图组成的，所以将多张位图组合成一帧画面的过程就是合成。比如位图的重叠部分的像素怎么处理等等！
* **解码**：解码主要是因为每一种图片都有不同的格式，要使图片能够显示在屏幕上，就得将不同格式的图片转码成图片的原始像素数据。这样才能进行绘制。
* **顶点着色**：是指把3D坐标转化为2D坐标，然后形状的各个点。
* **图元装配**：根据顶点着色器的输入，将所有点装配成点、线、三角形这些基础的图元；
* **几何着色器**：根据图元形成的数据生成几何形状；
* **光栅化**：就是把图元最终映射成屏幕上的像素，生成片段。片段是指一个像素渲染所需要的所有数据。
* **片段着色**：就将光栅化的结果先进行裁剪，去掉超出视图意外的像素，然后进行着色；
* **片段处理**：检测片段的对应深度值和透明度，丢弃被挡住的部分。然后对图层进行混合。
* **异步绘制**：UIView被触发了setNeedsDisplay方法后，会在CALayer的setNeedsDisplay上打上一个脏标记。在下一次RunLoop即将结束的时候，CALayer才会调用display方法，如果实现了layer.delegate的displayLayer方法，则就进入了异步绘制入口。然后在代理方法里调用Core Graphics的API进行bitmap的绘制，最后回到主线程进行复制
```OC
- (void)displayLayer{
	dispatch_async(backgroundQueue, ^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue, ^{
            layer.contents = img;
        });
	});   
}
```
* **SDWebImage编解码优化**：

  iOS默认会在UI主线程对图像进行解码。SDWebImageDecoder的优化思路就是将解码的耗时工作放到了子线程中进行，解码完成后就缓存到内存避免重复解码。

  解码的主要函数：[UIImage decodedImageWithImage:img];

* **离屏渲染**：
  在OpenGL中有两种渲染方式：当前屏幕内渲染和离屏渲染(在当前屏幕缓存区以外开辟一个新的缓存区进行渲染)。离屏渲染消耗性能的原因包括：
  1.需要创建新的缓存区；
  2.在离屏渲染的过程中，需要多次在当前屏幕和新的缓存区之间进行环境切换。
  哪些操作会触发离屏渲染？(因为有的组合属性在没有合成之前是不能在当前屏幕缓存区中使用的)
  1.光栅化：layer.shouldRasterize = true;
  2.遮罩：layer.mask
  3.圆角和masksToBounds一起使用的时候
  4.阴影。
  所以当遇到这些容易触发离屏渲染的情况的时候，可以考虑使用CPU渲染，也就是直接调用Core Graphics的API绘制来替代，比如使用shawdownPath来绘制阴影。


### OC基础特性
#### KVO
KVO是OC观察者模式的实践之一。KVO的实现原理是通过Runtime的**isa混写**技术给当前对象A生成一个NSNotifying_A的子类，然后重写所要监听的属性的Setter方法，Setter方法里会调用willChangeValueForKey:和didChangeValueForKey:方法。然后就会在ObserveValueForKey里监听到变化。
```oc
- (void)setB:(id)obj
{
    [self willChangeValueForKey:@"B"];
    [super setB:obj]; //调用原类的实现
    [self didChangeValueForKey:@"B"];
}
```
注意：
* kvo触发的关键点在于重写了属性的Setter方法，然后写了willChangeValueForKey和didChangeValueForKey方法，所以直接给成员变量 _ B赋值是不会触发KVO的，但是直接手动调用这两个方法也是可以触发KVO的
* KVC的setValue:ForKey:也能触发KVO，这也是KVC和KVO直接的联系；

#### KVC
KVC——KeyValueCoding键值编码。是苹果给NSObject添加的一个分类，它可以无需直接访问存Setter、取getter方法就能对属性进行操作(**所以这违反了面向对象的"封装性"的特性**)。主要的方法是setValueForKey:和valueForKey: 及KeyPath的变种。

注意：
* valueForKey:的时候会先按照getKey:、key、isKey、 _ key的顺序查找方法，然后判断accessInstanceVariablesDirectly，走后续流程；
* setValue:forKey：的时候先按照setKey:、 _ setKey:的顺序查找方法，然后判断accessInstanceVariablesDirectly，走后续流程；
* accessInstanceVariablesDirectly 设置为YES，则如果没有找到setKey，会按照 _ key， _ iskey，key，iskey的顺序搜索成员变量，设置成NO就不这样搜索。
* 如果传入的Value值为nil，则会调用setNilValueForKey方法；
* 如果key不存在且没有搜索到和key有关的字段和属性，则会调用valueForUndefinedKey函数。

  [KVC详解](https://juejin.im/entry/587d8b3e128fe1005701f969)

#### Category
category的最直接的作用就是给已有类添加方法。其次还可以拆分单个文件、便于多人同时开发一个类、声明私有方法等。

category是在runtime时决议的（所以category不能为类添加成员变量，因为运行时的类的内存布局已经确定了），category的结构体中包含名称、所属的类、方法列表、类方法列表、协议列表、属性列表。 

category是在运行时方法objc_init添加进类当中的，根据运行时方法的查找顺序，所以如果一个类对应多个category，每个category对应着相同方法，则最后编译的category的方法应该是实际生效的。但是并不是所有的方法都会直接这样“覆盖”掉。如果每个类本身和category都实现了**+load**方法，则每个load方法都会执行,执行的顺序是先类后category。

* 扩展： 扩展可以说是一个匿名的分类，但是它又不是分类，因为它是编译时决议的，生命周期随之宿主类，只有声明，没有实现，依附在宿主类中。主要的作用就是用来声明私有属性、私有方法、私有成员变量。不能为系统类添加扩展。

#### Association关联对象
在category中提到，不能为已有类添加成员变量，因为运行时类的内存布局已经确定了。但是可以添加属性。但其实属性 = setter+ getter + ivar。依然绕不过成员变量这个坎。所以关联对象的出现，正好解决了这个问题。

在runtime源码中我们可以看到一个AssociationsManager单例，它负责维护一个静态变量AssociationHasMap。也就是说我们创建的每一个类的关联对象都放在这同一个容器中。这个map以key为键值，以其他三个参数组成的结构体为value进行赋值。这样正好解决了内存布局的问题。

#### 通知
通知是使用观察者模式实现的，主要用于跨层传递消息。可以一对多进行传递。
通知的底层实现应该和关联对象的实现方式类似。主要由通知中心NSNotificationCenter管理一个Map表。Map表的key值是notifIctionName，value是一个列表。列表中的每个元素就是观察者、参数、方法等参数。

注意：
* 在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发。所以尽可能使用block API进行处理。其次要多注意它产生的循环引用的问题

* 代理：使用代理模式实现的，使用一对一的传递方式！

#### 关键名词解析
* **isa混写**：isa指针指向当前对象所对应的类，也可以说有isa指针的结构体就是一个对象，比如block和runloop。isa混写技术是指在运行时改变isa的指向，实现动态修改对象的类。具体是实现方案是通过给NSObject添加一个分类，分类里调用C函数objc_setClass来修过isa指向
```OC
//实现主体：
#import "NSObject+SetClass.h"
#import <objc/runtime.h>
@implementation NSObject(SetClass)
- (void)setClass:(Class)aclass {
   objct_setClass(self,aclass); //注意这里要确定两个类的size一样，通常需添加一个class_getInstanceSize的判断
}
@end

//使用：
A *a = [[A alloc]init];
[a setClass:[B class]];
```
* **+load**：每个类和分类都有load方法，它是在类被引进项目的时候（在main函数开始执行之前）自动被调用的，并且都会被调用一边。
与initialize的区别：initialize是在类或子类的第一个方法被调用前调用，也就是说没有使用的类不会被调用；如果类和分类都实现了initialize方法，则只有最后编译的category的initialize方法会被调用。

### Runtime
我们知道OC是在C语言基础之上开发的。编译的时候，OC无法直接编译为汇编语言，而是需要先转成C语言再进行编译。而从OC到C的过度就是由runtime实现的。所以可以说runtime是OC的运行环境，它是OC在C的基础上实现面向对象和动态机制的基石。

#### Runtime 基础数据结构
* 先来分析一下runtime的基础数据结构，从数据结构中了解OC的部分运行时特性：
OC中所有的对象都是id类型，id类型在runtime时被编译为objc_object结构体，objc_object包含了一个isa指针。OC中类对象Class在runtime中被编译成objc_class结构体，objc_class继承自objc_object。objc_class包含一个superClass指针，一个cache_t结构体，一个class_data_bits_t结构体。cache_t是一个可增量扩展的哈希表结构，它里面的每一个元素是bucket_t的结构体，bucket_t结构体里包含一个key和一个IMP。class_data_bits_t是对class_rw_t结构体的封装，class_rw_t里包含一个class_ro_t结构体、一个protocols二维数组、一个properties二维数组、一个methods二维数组。class_ro_t里包含一个name、一个ivars数组、一个protocols数组、一个properties数组、一个methods数组。methods数组里是一个method_t的结构体，method_t里包含一个SEL、IMP、const char*类型的字符串。

* 注意几个关键词：
  * isa指针是指向当前对象所属的类。它分为指针型isa和非指针型isa。指针型isa的所有数据都用于存储所属类的地址，非指针型的isa只有部分内容用来存储所属类的地址。我们可以说含有isa指针的结构体都是对象，比如说runloop、block等。 	
  * 类对象的superClass指针指向父类对象，元类对象的superClass指针指向元类的父类，根元类的superClass指针指向NSObject，NSObject的superClass指针为nil；
  * cache_t 是一个用于快速查找方法执行函数。它是一个可增量扩展的哈希表结构。是计算机局部性原理的应用；runtime通过key进行hash算法定位到对应的bucket_t，然后获取IMP。

* 几个重要的点：
  * 1、类也是一种对象，因为它继承自objc_object，称之为类对象。其中isa的指向就包括：对象的isa指向类对象，类对象的isa指针指向元类，元类的isa指针指向根元类，根元类的isa指针指向它本身；
  * 2、class_rw_t里的二维数组实际是对应category里的protocols、properties、methods。每一个category对应一个元素。所以方法查找时会先查找category里的方法；而class_ro_t是指只读的相关数据，也就是说已编译好的对象是无法在通过分类添加成员变量的。在class_rw_t的方法列表中查找时，对于已排到的使用二分法查找，对于没有排序的直接遍历查找。
  * 3、superClass指针的指向代表了方法查找的过程。也就是说对于实例方法，会沿着类对象的方法列表（此处先省略缓存查找等细节）进行查找，找不到就查找父类的方法列表，最后找的NSObject。而类方法的查找是在元类的方法列表中进行查找，以此往上查找，找的根元类的时候，由于根元类的superClass指针指向NSObject，所以又会去查找对应对象的实例方法。

#### Runtime涉及的事件
* 消息发送 objc_msgSend：
runtime会把iOS所有的方法调用转成objc_msgSend函数调用，给receive发送一条selector。之后会进行iOS的方法查找过程：在当前类的cache中进行查找，如果没有就在当前方法列表中进行查找，如果没有，就会去父类中查找，同样先查找缓存列表，再查找方法列表。如此往复，一直到根类。

* 消息转发：
如果方法查找没有找到，则iOS提供了动态方法解析和消息转发流程：
动态方法解析：resolveInstanceMethod: (类方法是resolveClassMethod)。可以在这个方法里动态添加方法实现（使用class_addMethod），添加完成后，会重新走消息发送流程；
如果动态方法解析没有添加方法，则开始走消息转发流程：先查看forwardingTargetForSelector：如果返回不为nil则说明转发给了其他id对象，则会开始走那个id对象的消息转发流程；如果返回nil，则会调用methodSignatureForSelector:方法，如果返回值不为nil，则会调用forwardingInvocation方法执行。否则调用doseNotRecognaziedSelector方法报出异常。

* Method-Swizzing：
方法交换是指使用runtime API : method_exchangeImplementations(Method m1, Method m2)来交换两个方法的实现。

* 其他：Category、KVO、KVC、ARC等

### Runloop
RunLoop是通过系统内部维护的事件循环来对事件和消息进行管理的对象。事件循环可以有效地对消息和事件进行管理：当有消息需要处理时，会将进程从内核态到用户态进行切换，同时唤醒当前线程处理消息；当没有消息需要处理时，会休眠当前线程，将进程从用户态到内核态进行切换，以避免资源占用。所以runloop可以保证进程不退出，可以处理和监听事件，可以定时渲染UI，可以调节CPU的工作。
#### runloop基础数据结构：
CFRunLoopRef 里包含一个pthread、一个currentMode、一个modes、一个commonModes、一个commonModeItems。currentMode指当前runloop对应的mode，每次调用runloop的主函数时，只能指定一个mode，它是为了分割开同组的Observer、timer、source,让其互不影响。 currentMode和modes里的数据结构都是对应CFRunLoopMode,CFRunLoopMode对应5种mode：DefaultMode、UITrackingMode、UIInitializationMode、EventReceiveMode、CommonModes。commonModes对应的是字符串，也就是前面5种mode的名称，它是一种技术解决方案，modeItems对应4种item：Observer、timer、source0、source1。

* 注意：
	* RunLoop与线程是一一对应的关系。所有的runloop被存在一个全局的字典容器中。我们无法手动代码创建runloop，只能通过currentRunLoop获取当前的runloop，获取的过程中，以线程为key值进行查找，没有找到就会默认创建，所以子线程中，不手动调用currentRunLoop，则该线程中的runloop就不会自动开启。 
	* 五种mode的区别：DefaultMode是APP默认的mode，通常主线程是在这个mode下运行；TrackingMode是UIScrollView的滑动mode；UIInitializationMode是app启动时的mode，启动完成后就不再使用；EventReceiveMode系统内部接收事件的mode，通常用不到；CommonMode则实际上不是一种模式，而是一种mode的组合方式。
	* commonMode是一种技术解决方案，因为runloop每次只能指定一个mode。一个mode一旦被标记为common属性的话，当runloop的内容发送变化时，runloop会将commonModeItems中的Observer、timer、source同步到具有Common属性的mode中。这样就可以让一些事件可以同时在多个mode中工作，比如NSTimer。
	* 4种Mode Item：Observer、timer、source0、source1：Oberver主要是用来观察RunLoop自身的6大状态，Timer实际就是我们用的NSTimer，也就是说NSTimer是根据RunLoop的Timer事件实现的，所以它是不准的。source0用于接收用户事件，比如UIEvent。source1事件是系统内核使用的，它可以主动唤起线程。
	* runloop循环状态：RunLoop启动时会发出CFRunLoopEntry通知；从休眠中唤醒时会发出CFRunLoopAfterWaiting通知；开启监听模式发出CFRunLoopBeforeObserve通知；然后发出CFRunLoopBeforeTimer通知进行优先处理timer和source0事件；当没有消息需要处理时，会从用户态切到内核态，进行休眠，此时发出CFRunLoopBeforeWaiting通知；最后runloop退出时会发出CFRunLoopExit通知。
	* source0 和 source1的关系：source1事件是具备唤醒线程的能力，但是主要用于系统内核事件，source0事件则主要用于app应用层事件，不具备唤醒线程的能力。所以一个touch事件，最初是由系统点击屏幕捕获到的系统事件，然后通过mach_msg，在APP内核生成一个source1事件，之后source1唤醒了当前线程，然后将其包装成source0事件去处理。

#### RunLoop涉及的事件：
* CALayer或者说视图树中的视图如果层次、frame或者调用了setNeedsDisplay\setNeedsLayout，则CALayer就会被标记为待处理。等到VSync信号发出来的时候才会CPU才开始处理，VSync的信号周期也就是 runloop的刷新周期，也就是在每秒60帧的画面，16.7ms的周期；
* runloop使得main函数不会退出，因为UIApplicationMain内部开启了一个主线程的runloop；
* runloop可以节省CPU事件，使其有事的时候做事，没事的时候休息；
* NSTimer实际是根据runloop的timer来实现的，所以默认情况下，NSTimer只能在DefaultMode下才能运行，当屏幕滑动时，则就会暂停运行，所以需要通过commonMode的方案来解决。同理，这也导致系统默认的NSTimer不准。CADisplayLink则是一个和屏幕刷新率一致的定时器，但是它同样存在和NSTimer一样的问题。 所以要想要更精准的定时器，最好使用GCD或者Facebook 开源的 AsyncDisplayLink；
* AutoreleasePool的实现原理：AutoreleasePool及其包含的对象的内存管理是根据runloop的运行周期来确定的，具体查看内存管理章节。
* 事件响应：参考上面source0和source1的分析
* performSelector：当使用NSObject的performSelecter:afterDelay:（注意这里一定得是和时间有关的API），实际会在其内部创建一个NSTimer并添加到当前线程的Runloop中。所以如果当前线程没有Runloop，则这个方法会失效，比如在新创建的子线程中，如果不调用[[NSRunLoop currentRunLoop] run]则就不会调用Select中的函数。
* GCD：GCD中的dispatch_async在使用到主线程的时候也使用到了RunLoop。首先GCD的所有线程仍然由libDispatch处理，但是当用到主线程的时候，libDispatch会向主线程的RunLoop发送消息，主线程的RunLoop会被唤醒，并从消息中获取block，然后回调执行。其他线程则仍由libDispatch处理。
* 网络请求框架中的常驻线程；

[runloop详解](https://blog.ibireme.com/2015/05/18/runloop/)


### Block
Block是对函数及其执行上下文封装起来的对象。
#### block基础数据结构：
Block最终被编译之后得到的是一个结构体，结构体内部成员变量有一个 _ _ block _ impl的结构体，它内部包含一个isa指针，一个FunPtr函数指针。所以说block是一个对象，block调用就是函数调用。
#### block的类型：
block分为NSGlobalBlock、NSMallocBlock、NSStackBlock，它们分别存在在全局数据区、堆区、栈区。并且在**ARC和MRC中有所区别**：
* 首先无论是ARC和MRC下，只要是没有引用外部变量的block都是NSGlobalBlock，全局block对copy、retain、release没有反应；
* 其次引用了外部变量的block就变成了栈block。因为一旦使用到了外部变量，就可能因为截获变量而得管理相关内存，此时对栈block进行copy操作，那么就会拷贝到堆区；
* 栈block变为堆block，存在一些条件：在ARC下：（调用Block的copy方法、将block赋值给 _ _ strong修饰的类型或成员变量、block作为返回值时、使用GCD的block等）；在MRC下，（对栈block进行copy操作等）；
* 注意 ：
这里用代码解释一下block在ARC和MRC的区别：
```
void(^block) = ^{};   //没有对外部变量进行任何操作，所以是全局block
int val = 0; 
NSLog("%@",^{val = 1;}); //引用了外部变量，所以这个匿名block是一个栈block，如果这是对其使用[^{val = 1;} copy],则就会变成一个堆block；
void (^block1) = ^{val=1;}; //注意，在MRC下，block1是一个栈block，因为它引用了外部变量。但是在ARC下，它是一个堆block，因为 = 左侧block1默认是 __ strong类型，相当于上文说的“将block赋值给__strong修饰的类型或成员变量”，所以在ARC下，大部分block其实都是堆block。
```
所以 在MRC中，block属性只能使用copy关键字，在ARC中，block属性可以使用Strong关键字和copy关键字。在实际开发过程中，为了使代码在ARC和MRC中都能使用，所以我们一般推荐使用copy关键字。

#### 截获变量：
block最常见的使用是异步回调的，也就是说不是顺序执行的，所以就涉及到使用了外部变量的情况下，如果外部变量修改了，会不会影响到block里的使用的问题。block对变量的截获主要分为以下几种情况：
* block对于全局变量和静态变量是不进行截获的，因为它的作用域足够广，所以可以直接使用；
* block对于局部的基础数据类型，直接截获其值。也就是说后续的修改跟它没什么关系；
* block对于局部的对象类型，则是连同其所有权修饰符一起截获；所以这就导致了循环引用的可能性。
#### block循环引用：
由于block对局部对象类型的截获变量特性，所以就导致了可能存在的循环引用问题。如果对象类型是 _ _ strong类型的，那么block对其进行截获是会连同所有权修饰符一起截获，也就是说在block内部也是使用了一个 _ _ strong类型的变量强引用了它。所以这就导致了循环引用的问题。所以最好的解决方案就是对截获的变量使用  _ _ weak 的变量去替代它，其次常用的解决循环引用的方法就是断环。

#### --block：
什么是 _ _ block? 
添加了 _ _ block修饰符的变量最终会变成一个multiple的结构体，结构体中含有isa指针。也就是说 使用了 _ _ block修饰的变量最终变成了对象。但是在**ARC和MRC下是有区别**的。在MRC下使用 _ _ block修饰的变量，不会增加对象的引用计数；在ARC下，使用 _ _ block修饰的变量，会增加其引用计数。所以就有一道痕经典的面试题:

```
{
    __block id * blockSelf = self;
    _block = ^int(int num){
        return num * blockSelf.var;
    };
    _block(3);
}
//分析：由于在MRC下，__block修饰的变量不会增加引用计数，所以也就不存在强引用的问题，所以这段代码在MRC下是不会有问题的。但是在ARC下，它是存在循环引用的。所以可以使用断环的方式进行处理：
{
    __block id * blockSelf = self;
    _block = ^int(int num){
        int result = num * blockSelf.var;
        blockSelf = nil;
        return result;
    };
    _block(3);
}

```
#### block的copy操作：
通过上面的分析，我们知道对全局block进行copy不会有任务反应，对栈block进行copy则会被拷贝到堆上，对堆block进行copy操作则会增加其引用计数。那实际上，对栈block进行copy操作时，在堆上也产生了一个一样的block，同时也使栈block的 _ _ forwarding指向了堆区的block，所以此时对栈block进行操作实际就是通过_ _forwarding指针找到对应的堆block，然后再进行操作。同时，在MRC下，对栈block进行copy操作就如同执行了一个malloc方法，所以同样存在内存泄漏的问题。


### 内存管理
#### 内存管理方案
* **TaggedPointer**：对于一些小对象，比如NSNumber和NSDate。它实际上采用的是TaggedPointer的管理方式进行内存管理的，它是对象指针实际上不执行任何内存地址，而是直接将值存储在了指针本身里，该指针就被拆分成两部分，一部分是直接保存数据，另一部分是作为特殊标记。
* **NONPOINTER_ISA**：在runtime章节中有提到isa是指向当前对象所属类的一个指针。一个结构体含有isa指针，那可以说明它是一个对象类型。实际上isa是对应一个isa_t的联合体，在64位架构下，它是由64个0和1的比特位组成。而实际上存储该对象所属类对象地址只需要用到大概33位，所以剩下的位数就可以用来存储其他的信息。
	我们来看看NONPOINTER_ISA的基础数据结构：
	* 第1位：是一个标志位，表示了它是否是一个非指针类型的isa，如果是0则说明它只是一个指针，内部的数据都是对应class的地址，如果是1则表示它是一个非指针类型的isa，内部数据只有部分用于存储class的地址；
	* 第2位：表示当前对象是否有管理对象——Association；
	* 第3位：表示是否使用ARC进行内存管理；
	* 第4~33位：表示当前对象所指向的类对象的地址；
	* 第34~40位：表示是否完成初始化；
	* 第41位：表示是否有弱引用指针；
	* 第42位：是否正在执行deallocating操作；
	* 第43位：表示当前对象是否外挂散列表；
	* 剩余的位数：都是表示extra_rc，也就是真实的引用计数值。
* **散列表：SideTables**：也就是在非指针型的isa的引用计数值太大时，则会使用到散列表来对内存进行管理。散列表中包含了引用计数表和弱引用表。
#### 散列表详解
##### 散列表基础数据结构：
在64位架构下，通常会有64个散列表组成一个全局的SideTables，它类似AssociationMap。每个散列表元素包含一个自旋锁、一个引用计数表、一个弱引用表。当需要对引用计数进行操作的时候，则通过对象指针作为key值，经过哈希查找定位到对应的散列表，然后进行操作。
* 注意：
	* 之所以要有多个sidetable组成一个sidetables，也是为了提供访问效率。因为每个引用计数的操作都是需要加锁处理，分割成多个表，就可以并行操作。实际上这就是**分离锁**的技术方案；
* **自旋锁Spinlock_t**： 它是一个“忙等”的锁，也就是说在当前资源被某个线程占用的时候，其他的线程会一直试探该锁有没有解锁，而像信号量，则是会在获取不到资源的时候进行休眠，等资源被释放后，则再被唤醒。它使用与轻量访问；
* **引用计数表**：引用计数表也是一个hash表，它是通过hash函数插入和获取引用计数，提高访问效率。hash表里的每个元素是一个unsigned long类型的size_t。它也是由64位比特位组成，其中第一位是表示是否有弱引用，第二位表示是否正在执行dealloc函数。剩下的则是表示引用计数的值。所以取引用计数的时候需要进行向右偏移2位的操作；
* **弱引用表**：实际上也是一个hash表，它存储的是一个weak_entry_t的结构体数组，它里面的每个对象存储的都是一个弱引用指针。 _ _ weak就是对应弱引用，在delloc的时候有相关操作。

#### ARC & MRC
MRC是手动内存管理，ARC是自动内存管理，它通过LLVM编译器和runtime协作在合适的时机给代码添加retain和release等代码，实现自动引用计数的管理。ARC无法显式调用retain和release等函数。
* alloc ：最终通过调用c函数的calloc完成初始化。注意此时引用计数并不为1；
q1:通过alloc生成的对象，其实并没有设置引用计数为1。但是获取它的引用计数的时候确实是1，为什么。因为一个对象初始化时的retainCount就被默认为1了；
* retain：新经过hash查找找到对应的sidetable，然后在经过hash查找找到对应的引用计数值，之后获取到引用计数值，进行+1操作；
q1：我们在进行retain操作的时候，系统是怎么查找其对于的引用计数的呢？
是经过两次hash查找，然后进行+1操作（实际上是位移操作）。
* release：
同样是经过两次hash算法，获取到引用计数值，然后进行-1操作。
* retainCount：
**查找引用计数时，会通过一个初始化为1的局部变量 ➕ 上面各方法中查找到的引用计数值。所以说上面说的isa或散列表等存储的引用计数值实际上就是引用计数的值减一**。而这也说明了为什么执行alloc操作时，没有设置引用计数，但是查找到的retainCount仍然为1的原因。
* **dealloc函数及 _ _ weak指针**:
执行dealloc时，判断是否可以释放的条件包括：是否使用nonpointer_isa、是否有弱引用指针、是否有关联对象、是否使用ARC、是否使用sidetable。如果这些条件都为NO的时候，就可以直接使用c函数free直接释放，否则则要调用objc_dispose()进行进一步清理。
而objc_dispose则会一步步 移除对关联对象、将指向该对象的弱引用指针置为nil，将当前对象在引用计数表的数据清除掉等操作。(这里解决了两个面试题:1、对象在释放的时候，是否有必要移除掉关联对象；2、weak修饰的对象是怎么讲指针置为nil的。答案就是在dealloc内部实现的时候有做这些操作)

#### 被 _ weak修饰过的对象
q1：系统是怎样把一个weak变量添加到它对应的弱引用表中的。
一个被声明为 _ weak 的对象指针，经过编译器编译，会调用一个objc_initWeak函数，之后会调用weak_register_no_lock()函数进行弱引用变量的添加，具体添加的位置是通过hash算法进行位置查找的，如果查找的对应位置中已经有了当前对象对应的弱引用数组，则把当前变量添加进弱引用数组，如果没有，则重新创建一个弱引用数组。
q2：当一个对象被释放之后，weak变量是怎么被清理的。
会被置为nil。当对象执行dealloc的时候会调用弱引用清除相关函数，在函数内部会通过弱引用指针找到弱引用数组，然后遍历所有的弱引用指针，分别置为nil。

##### AutoreleasePool
AutoreleasePool是用于对延迟释放的对象的内存管理。
* 首先来看一下AutoreleasePool的内部结构:
AutoreleasePool是一个以AutoreleasePoolPage为节点，的双向链表，同时它含有一个pthread的成员。在ARC中的实现流程是：当@autoreleasepool{}中，{开始的位置会被编译成AutoreleasePoolPagePush(),它会在当前栈中插入一个标志位，并且返回。在执行{}之间的代码时，会把对象插入进去，在}结束前，会把标志位做为入参执行AutoreleasePoolPagePop(xx),这个时候会给标志位之后的所有对象发送一个release消息，以释放无用的对象。
* 注意：
因为AutoreleasePool的数据结构实际是以标志位插入的方式来实现的，所以无论有多少层嵌套，都只是对标志位进行操作而已。

* AutoreleasePool与runloop的关系及内存管理：
AutoreleasePool与线程是一一对应的关系，那么它与runloop自然也是一一对应的关系。在runloop发出CFRunLoopEntry通知的时候，会执行一个AutoreleasePagePush()函数，创建一个AutoreleasePool，然后runloop的事件循环中（因为runloop是在entry之后才开启事件循环的），如果监听到了kCFRunLoopBeforeWaiting通知，会先执行AutoreleasePagePop()然后再执行AutoreleasePagePush()，相当于释放旧的AutoreleasePool，创建新的AutoreleasePool。然后在runloop退出前，即接收到KCFRunLoopExit通知时，再执行AutoreleasePagePop()释放掉AutoreleasePool。所以从这里可以看出，在Runloop的每一次事件循环期间，也是会对标志位直接的每一个对象发送一次release的，以及时释放掉无用的对象。


### 锁与多线程
多线程是为了实现并发执行的技术。在单核CPU中，操作系统通过分配CPU计算时间来实现软件层面的多线程，在多核CPU中，则直接可以在硬件层面进行多线程运行。
iOS有多种多线程的方案，pthread、NSThread、performSelect、GCD、NSOperation。
#### NSThread和performSelector
* NSThread先创建线程再启动线程，NSThread常用于开启常驻线程
```
//1 创建线程
NSThread * thread = [[NSThread alloc] initWithTarget:self selector:@selector(xxx) objc:nil];
//手动启动
[thread start]; 
// 2 创建线程 自动启动
[NSThread detachNewThreadSelector:@selector(xxx) toTarget:self withObject:nil];
```
* performSelector 含有thread的API可以隐式开启线程。但是其含有delay的API则是使用了线程中对应runloop的Timer，需要开启NSRunLoop才能运行
```
[self performSelectorInBackgroundL@selector(xx) withObjct:nil];
```
#### GCD
GCD是一个多核并行运算的解决方案，它可以自动管理线程的生命周期，只需要告诉GCD干什么就行。
##### 队列和任务:
* 队列分为**串行**和**并发**：
串行派发是指同一时间，队列中只能执行一个任务，只有在当前任务执行完成后，才会派发新的任务；并发是指多个任务可以在同一时间同时进行，无需等待前面的任务执行完也可以派发新任务；

iOS中主队列mian是一种串行队列，全局队列global是一种并发队列；global_queue是一个并发队列，创建全局队列时，第一个参数是一个优先级的标识，所以如果要在并行队列中，让任务先执行，这可以通过设置这个优先级来达到目的（但是这里要注意，先执行并不一定是第一个执行完，它只能保证开始的执行顺序而已）。它的优先级包括（低-高：background（同步备份数据）、utility（需要时间的下载）、default、user-Initiated(用户出发的，如打开文件)、user-Interractive(用户交互，如主线程事件)）

* 任务分为**同步**执行和**异步**执行：
同步执行是在当前线程中执行，异步执行会在线程池中获取一个线程进行执行，如果线程池中没有则会创建一个新的线程执行；

##### 4种线程组合：
* 同步串行：同步不开启新线程，串行队列让任务一个一个执行。所以它实际不会产生多线程运算；
* 同步并发：并发队列虽然可以并发执行，但是同步执行不开启线程，也就相当于任务只在一个线程中执行，而一个线程一次只能处理一个事件，所以实际也不构成多线程运算；
* 异步串行：异步执行虽然会开线程，但是串行队列中任务一个个执行，所以也不构成多线程运算；
* 异步并发：并发队列可以让任务并发执行，异步执行可以开启多个线程，所以这才会真正实现多线程运算。
```
//eg 01
serialQueue.async{
    serialQueue.sync{
    }
}
// 分析：首先这是在一个串行队列里执行，所以其执行方式必然是一个一个执行。最外层使用异步执行，所以会开辟一个线程；内部的任务是同步执行，所以是在当前线程中执行。因为是串行执行，所以内部任务是在外部任务执行完成后才开始执行，而外部任务的执行完成依赖于内部任务也执行完成。所以就导致了死锁！
SerialQueue.sync{
    SerialQueue.async{
    }
}
//分析：同上面的分析类似。使用串行队列，最外层任务是在当前线程中执行，内部任务会开辟新的线程执行。外部任务的执行完成意味着内部任务也执行完成，而内部任务可以在另外的线程中执行完成，所以这个是可以正常运行的！
```
##### dispatch_barrier
dispatch_barrier是指栅栏调用，它的特点是无论是同步还是异步，都会阻塞当前线程，也就是说它会等待所有之前入队的任务都执行完成才开始执行，而在之后入队的所有任务会等待dispatch_barrier本身任务执行完成再执行。
* dispatch_barrier_async与dispatch_barrier_sync的执行效果是一样的，区别就在于：sync会阻塞后续线程入队，async不会阻塞入队。但是执行时候的效果是一样的
* dispatch_barrier_async和dispatch_barrier_sync只有在自定义的并发队列中才能有栅栏效果，否则它与dispatch_async或dispatch_sync的作用是一样的。所以它在串行队列中同样容易导致死锁。
* dispatch_barrier实现多读单写
```swift
A{
    set{
        ConcurentQueue.async(flogs:.barrier){
            _a = newvalue
        }
    }
    get{
    //注意这里使用同步读取
        ConcurentQueue.sync{
            return _a
        }
    }
    
}
```
##### dispatch_group调度组
dispatch_group可以实现先并发处理一些任务，然后监听所有任务的执行完成。
dispatch_group_async可以异步添加任务到group中，如果无需涉及线程或者队列的话，则可以使用dispatch_group_enter和dispatch_group_leave**配对**执行，比如接口任务。最后使用dispatch_group_notify通知group所有任务已完成
```
{
//注意点：dispatch_group_async与dispatch_group_enter效果是一样的，都是异步添加任务，dispatch_group_enter与dispatch_group_leave必须成对出现，否则group中的任务永远不会完成。
    let group = DispatchGroup()
    DispatchQueue.global().async(group: group, qos: DispatchQoS.default, flags: []) {
      sleep(1000)
      print("任务1")
   }
    
    dispatch_group_enter(group)
    self.request1({
      sleep(1000)
      print("任务2")
      dispatch_group_leave(group)
    })
    
    dispatch_group_enter(group)
    self.request2({
      sleep(1000)
      print("任务3")
      dispatch_group_leave(group)
    })
    
    dispatch_group_notify(group,dispatch_get_main_queue(),^{
        print(finish)
    })
}
```
##### dispatch_semaphore 信号量
dispatch_semaphore俗称信号量，也叫信号锁，用于控制多线程下资源访问的数量。
三个方法：
* dispatch_semaphore_create: 创建一个带有初始值的信号量dispatch_semaphore_t。信号初始值为0的话相当于线程同步，信号值大于0的话，相当于加锁效果；
* dispatch_semaphore_wait: 这个方法主要用于减少信号量，每次调用都会对信号量进行减1。所以当信号值小于0时，这个方法会一直等待，也就是阻塞当前线程，直到信号量大于等于0时；当这个信号值大于或等于0时，会直接返回，不会阻塞当前线程；
* dispatch_semaphore_single: 这个方法用于让信号值加1，然后直接返回，如果先前信号量的值小于0，那么这个方法会唤醒先前等待的线程；
```
//1线程同步
let semaphonre = DispatchSemaphore(value: 0)
self.request2({
	print("执行耗时任务，比如接口请求")
	sleep(1000)
	semaphore.signal()
})
print("开始等待")
semaphore.wait(timeout: DispatchTime.distantFuture)
print("任务结束")

//2资源加锁
//创建一个线程
let semaphonre = DispatchSemaphore(value: 1)
static int tickets = 100; //100张票
var i = 0
while(i<3){
	//开启了3个线程
    DispatchQueue.global.async({
        //开启并发，每个线程类似一个售票窗口
        semaphore.wait(timeout: DispatchTime.distantFuture) //-1
        sleep(1000)
        tickets -= 1 //卖票
        semaphore.signal() 
    })
    i += 1
}

//3改变全局队列里设置好的优先级。
var highQueue = Dispatch.global(qos:.userInitiated)
var lowQueue = Dispatch.global(qos:.utility)

let semaphore = DispatchSemaphore(value:1)
lowQueue.asycn{
    semaphore.wait()
    sleep(1000)
    semaphore,signal()
}
highQueue.asycn{
    semaphore.wait()
    sleep(1000)
    semaphore,signal()
}
//这里lowQueue的优先级更高。
```
**注意**：
在信号量使用过程中对信号量进行重新赋值或者置空操作会crash。在libdispatch源码中，使用一个变量dsema_value保存当前信号量的值，使用dsema_orig保存初始值。执行过程中，当使用wait时会对dsema_value减1，使用signal的时候对dsema_value加1。当我们对信号量进行置空或重新赋值的时候，会调用disponse释放信号量，在disponse函数中如果dsema_value小于dsema_orig，则会直接调用CRASH使程序崩溃。
[dispatch_semaphore](https://juejin.im/post/5cc819cfe51d456e4869548d)

#### Operation：
NSOperation是基于GCD更高一层的封装。它是基于两个概念**操作**和**队列**来实现多线程的。
**操作**：
	* 操作其实就是对应着GCD的block。但是NSOperation的操作更复杂一些，它可以管理自己的状态和优先级。NSOperation使用其子类来定义操作:NSInvocationOperation、NSBlockOperation、自定义子类。
	* 每个操作都对应着4个状态：isReady(是否就绪)、isExecuting(是否进行中)、isCancelled(是否取消)、isFinished(是否完成)。
	* 单独的操作只在当前线程中执行。
**队列**：
	* NSOperation的队列有区别于GCD的先进先出的调度队列。NSOperationQueue是根据NSOperation的依赖关系来决定将队列中的哪个Operation置成就绪状态，然后进入就绪状态的Operation的**开始执行顺序**取决于操作之间的优先级；
	* OperationQueue实现了暂停、继续、终止、优先顺序、依赖等操作。同时通过设置最大并发量maxConcurentOperationCount来确定其实串行还是并发。
	* NSOperationQueue只提供了两种不同的队列：主队列和自定义队列；主队列运行在主线程之上，自定义队列运行在后台。
	* NSOperationQueue通过设置最大并发操作数来确定是串行还是并发操作
* 如何实现多线程
单独的NSOperation使用同步运行，把它放到NSOperationQueue中可以实现多线程的运行效果；
##### NSInvocationOperation
单独使用NSInvocationOperation是在当前线程中执行，并不开启线程。将其放到其他线程下面，才会开启新线程
```
//test函数省略， 单独这样使用的话，test就在当前线程中运行，和多线程没有任何关系。也可以将其放到任一一个子线程中运行。
- (void)useInvocationOperation{
	//创建对象
    NSInvocationOperation *iop = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];
    //手动开启
    [iop start];
}

```
##### NSBlockOperation
同样的，**单独的**的NSBlockOperation也是在当前线程中运行，并不会开启子线程。
```
- (void)useBlockOperation{
	//创建对象
    NSBlockOperation *bop = [NSBlockOperation blockOperationWithBlock:^{
		//模拟耗时操作
		[NSThread sleepForTimeInterval:20];
    }];
    //手动开启
    [bop start];
}
```
但是，NSBlockOperation还提供了addExcutionBlock。通过addExcutionBlock可以为NSBlockOperation添加额外的操作。而这些操作(包括NSBlockOperation本身)可以在不同的线程中同步执行，具体哪些线程在其他线程中执行以及开多少条子线程则由系统决定。
```
- (void)useBlockOperationWithAddExcution {
	//创建Block对象
    NSBlockOperation *bop = [NSBlockOperation blockOperationWithBlock:^{
		//模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
    }];
    //添加额外操作1
    [bop addExcutionBlock:^{
        //模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
    }];
    //添加额外操作2,可以添加n个额外操作
    [bop addExcutionBlock:^{
        //模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
    }];
    
    //手动开启
    [bop start];
}
```

##### 自定义Operation
如果想自己控制操作的状态，则可以自定义Operation，自定义的Operation又分为非并行的Operation和并行Operation：
* 非并行Operation：
非并行的Operation只需要实现main函数即可，将操作代码放到main函数里：
```
@interface CustomSyncOpretion:NSOperation
@end
@implementation CustomSyncOpretion
- (void)main{
	if ([self isCancelled] == NO) {
        [Thread sleepForTimeInterval:20]; 
	}
}
@end

//使用
CustomSyncOpretion *cop = [[CustomSyncOpretion alloc] init];
//调用 start 方法开始执行操作
[cop start];
```

* 并行Operation子类
要实现并发的子类则要复杂很多，因为要自己管理操作的状态，所以必须重写以下方法：
	* start ：所有并行的Operation必须重写这个方法，然后在你想要执行的线程中手动调用这个方法。注意：不要调用其父类的start方法；
	* isExecuting：是否执行中，需要使用KVO实现；
	* isFinished：是否完成，需要使用KVO实现；
	* isAsynchronous：该方法返回NO，表示非并发执行。并发执行需要自己定义并返回YES，其后的操作根据这个值来决定是否手动开启子线程；
```
@interface CustomAsyncOperation : NSOperation
@end

@interface CustomAsyncOperation(){
    BOOL excuting; //执行中
    BOOL finished; //已完成
}
@end

@implementation CustomAsyncOperation
- (instanceType)init{
    self = [super init];
    if (self){
        excuting = NO;
        finished = NO;
    }
    return self;
}

- (BOOL)isAsynchronous {
    return YES;
}
- (BOOL)isExecuting {
    return excuting;
}
- (BOOL)isFinished {
    return finished;
}

- (void)start {
	@autoreleasepool{
        if (self.cancelled) {
            [self willChangeValueForKey:@"isFinished"];
        	finished = YES;
        	[self didChangeValueForKey:@"isFinished"];
        	return;
        }
        
        // 任务。。。模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
		[self completeOperation];
    }
}

- (void)completeOperation {
    [self willChangeValueForKey:@"isFinished"];
    [self willChangeValueForKey:@"isExecuting"];
    
    executing = NO;
    finished = YES;
    
    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
}

@end

//使用
CustomAsyncOperation *cop2 = [[CustomAsyncOperation alloc] init];
//调用 start 方法开始执行操作
[cop start];
```

##### 队列
NSOperationQueue中一共有两种队列：主队列、自定义队列。自定义队列同时包含了串行和并发功能。
* 主队列：
凡是放到主队列中的操作，都会放到主线程中执行。(注意：这里不包括addExecutionBlock添加的额外操作，额外操作可能在其他线程中执行)
```
//获取主队列
NSOperationQueue * queue = [NSOperationQueue mainQueue];
```
* 自定义队列：
自定义这种队列的操作，会自动放到子线程中执行。
```
//注意，这里虽然用了上述的操作，但是在Queue里使用就无需手动start了。
NSOperationQueue * cusQueue = [NSOperationQueue new];
[cusQueue addOperation:iop];
[cusQueue addOperation:bop];
[cusQueue addOperation:cop1];
[cusQueue addOperation:cop2];

//直接使用block添加操作
[cusQueue addOperationWithBlock:^{
	//模拟耗时操作
	[NSThread sleepForTimeInterval:20];
}];
```
**队列控制串行并发**
队列使用属性**macConcurrentOperationCount**来控制串行和并发。注意：macConcurrentOperationCount并不表示并发线程的数量，而是一个队列中同时能并发执行的最大操作数。且一个操作并非只在一个线程下完成。macConcurrentOperationCount默认值是-1，表示不进行限制，可进行并发执行，如上代码；值为1时，队列为串行执行；值大于1时，队列并发操作，当然了，最大并发数肯定是无法超过系统限制的。
##### NSOperation操作依赖
NSOperation的操作依赖用来控制添加到队列中的操作进入准备就绪状态。
* addDependency:(NSOperation * ) op;  添加依赖，使当前操作依赖于操作 op 的完成。
* removeDependency:(NSOperation * ) op; 移除依赖，取消当前操作对op的依赖。
* @property (readonly, copy) NSArray<NSOperation *> *dependencies；在当前对象开始执行之前，完成数组里的所有操作对象。
**注意**：操作直接如果相互依赖会导致死锁。
##### NSOperation 优先级
NSOperation的优先级queuePriority属性，进入就绪状态的操作的**开始执行顺序**则是通过优先级属性决定的。
queuePriority包含五种取值：NSOperationQueuePriorityVeryLow、NSOperationQueuePriorityLow、NSOperationQueuePriorityNormal、NSOperationQueuePriorityHigh、NSOperationQueuePriorityVeryHigh。
优先级的属性只适用于同一队列中的操作。

总结：**依赖关系**决定了准备就绪状态，**优先级**决定了开始执行顺序：当一个操作的所有依赖已经完成时，操作会进入准备就绪状态。比如op1、op2、op3、op4四个操作。op3 dependency op2、op2 dependency op1。现在4个操作都添加到队列里，op1和op4都没有依赖，所以都是准备就绪状态，op2要等到op1执行完成后才进入准备就绪状态，op3要等到op2执行完成后才进入准备就绪状态。而同时进入准备就绪状态的操作的开始执行顺序则是由priority决定的。

##### Operation的暂停和取消操作
操作的暂停和取消操作并不代表里面就能将当前操作进行暂停和取消，而是当当前操作执行完毕之后不再执行新的操作。暂停和取消的区别则在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作就会清空索引的操作，后续无法继续。

[NSOperation基础](https://www.jianshu.com/p/4b1d77054b35)
[自定义Operation](https://www.jianshu.com/p/813f7d58935d)
[自定义Operation2](https://juejin.im/post/5d26a7a2e51d45777b1a3e38)


#### GCD VS NSOperation：
GCD是基于C语言实现的，NSOperation是基于GCD实现的！
NSOperation可以添加依赖、优先级、最大并发量，操作可以控制状态，执行暂停和取消等操作。
GCD则有栅栏、group、信号量、单例、延时执行等。在暂停、取消、最大并发量这些操作更不容易实现。

#### 锁
* 自旋锁 OSSpinLock 存在优先级反转的问题。就是等待线程的优先级更高，会一直占用CPU，优先级低的线程就无法释放锁；
* os_unfair_lock 用来替换OSSpinLock，但是它并非忙等的锁；
* pthread_mutex 互斥锁，等待线程时会进行休眠。它同时含有多种锁，比如pthread_mutex—递归锁、pthread_mutex—条件锁；
* NSLock是对pthread_mutex 普通锁的封装；
* NSRecursiveLock是对pthread_mutex—递归锁的封装；
* NSCondition是对phread_mutex—条件锁的封装；
* NSConditionLock是对NSCondition的又一层封装；
* @synchronized是对pthread_mutex—递归锁的封装；

另外信号量和同步队列也能实现类似锁的操作！

##### 死锁的几种情况
```swift
//1、串行队列：异步里同步嵌套
SerialQueue.async{
    print(1)
    SerialQueue.sync{
        print(2)
    }
}
//2、串行队列：同步里同步嵌套
SerialQueue.sync{
    print(1)
    SerialQueue.sync{
        print(2)
    }
}
//3、主线程中执行同步操作
viewDidLoad(){
    DispatchQueue.main.sync{
        print(3)
    }
}
//4、NSOperation 线程间依赖
let operaA = Operation()
let operaB = Operation()
operaA.addDependency(operaB)
operaB.addDependency(operaA)
```

#### 高效使用多线程
* 减少队列切换
* 控制线程数量。一个进程最多开启多少线程？目前我不是很清楚。但是过多的线程及线程调度肯定是非常耗性能的，所以最好的做法是开启和CPU核心数量一样的串行队列，提高CPU使用效率。
* 权衡线程优先级。比如大量图片异步解压过程。应该让查询磁盘的线程优先级高一点，让解压的优先级低一点。
* 主线程优化。比如Cell的复用机制、懒加载机制都能减少CPU的使用

[如何高效使用多线程](https://juejin.im/post/5d3faa9de51d4561f95ee9b7#heading-4)


### 事件及手势
#### 触摸——事件——响应者
* 触摸UITouch：就是一次触摸屏幕。它对应生成一个UITouch对象。多个手指触摸生成多个UITouch对象。在同一个位置双击，则会更新第一次单击的tap count值。每个UITouch对象记录了触摸的时间、位置、阶段、所处视图、窗口等。
* 事件UIEvent：一个触摸事件对应一个UIEvent。当然了UIEvent也可能不对应UITouch，也可能是其他的事件，比如抖动事件。
* 响应值UIResponder：每个响应者都是一个UIResponder对象。比如UIView、AppDelegat等。

#### 事件响应
* 1、手指触碰到屏幕后，将由系统判断决定是否传递给前台APP进程
* 2、APP进程接收到触摸事件后，触发source1回调，主线程的runloop就被唤醒；
* 3、主线程被唤醒之后，source1事件被包装成source0事件，添加到UIApplication对象的事件队列中；
* 4、等到事件出队后，就开始寻找最佳响应者的过程；
* 5、寻找到最佳响应者之后，接下来的事情便是事件在响应链中的传递及响应了；
##### 寻找最佳响应者
1、事件出队后，UIApplication首先将其传递给UIWindow，如果存在多个Window，则优先传给后显示的window；
2、若该window不能响应事件，则将事件传递给其他window。若该window能响应事件，则从后往前询问窗口子视图；
3、子视图中，若能响应，则自下而上传递，若其子视图不响应，则自身是最合适的响应者。若不能响应，则传递给其同级的前一个兄弟视图；
4、找到最佳响应者后，然后将其回溯返回给UIWindow。
5、找到最佳响应者后，则开始将事件在响应链中进行传递。**注意**前面步骤的传递是自下而上（window到最佳响应者）地传递，为了找到最佳响应者。而这里的事件传递则是将直接在响应链中传递，以便将事件进行响应，这是自上而下（最佳响应者向UIWindow传递）进行的；
6、每个响应者都有4个默认实现的响应事件触摸的方法：touchBegan:withEvent:、touchMoved:withEvent:、touchEnded:withEvent:、touchCancelled:withEvent:。所以可以在这些方法中对事件进行拦截做一些额外的处理。**touchBegan:withEvent也正是事件在响应链中的传递方式**；所以重写touchBegan:withEvent也能够让事件不再往下传递。

* 如何判断是否能响应？
每个UIView都有一个hitTest:withEvent方法，该方法返回一个能响应的UIView对象。比如：事件传递到UIWindow，UIWindow执行hitTest:withEvent:判断自身能否响应事件，若可以，则调用子视图的hitTest:withTest:将事件传递给子视图，并在子视图中查找最佳响应者。找到了之后就回溯给UIApplication一个最佳响应者视图。
hitTest:withEvent:方法的判断标准包括：是否允许交互、是否隐藏、透明度是否小于0.01，若这三个条件都通过，则会判断触摸点是否在当前视图的坐标系范围内。
* 如何判断触摸点是否在当前视图坐标系范围内？
pointINside:withEvent:方法用于判断触摸点是否在自身坐标范围内，返回一个bool值。注意的是次判断的时候都得以自身坐标系为准，所以应当使用covertPoint:toView:先进行坐标系转换。所以一般项目中碰到扩大按钮点击区域、tabBar凸出的按钮点击不响应等问题，则可以重写pointInside:withEvent:方法。
* 知道最佳响应者后，事件如何继续沿着响应链传递？
首先每个响应者都有一个nextResponder方法，用于将事件传递下一个响应者：若UIView是视图控制器的根视图，则其nextResponder是视图控制器，否则其nextResponder是其父视图；若视图控制器是window的根控制器，则其nextResponder是UIWindoi，否则是其前一个控制器；UIWindow的nextResponder是UIApplication；UIApplication的nextResponder是AppDelegate。
所以一旦找到最佳响应者后，整个响应链也就确定了。然后UIApplication会将事件通过sendEvent根据UITouch绑定的window传递给对应的UIWindow，UIWindow同样使用sendEvent通过UITouch绑定的touch对象将事件传递给hitTestView。

* UIResponder、UIGestureRecognizer、UIControl同时存在时，会怎么响应？
	* **手势识别器比UIResponder的响应优先级更高**。Window在将事件传递给最佳响应者之前，会将事件先传递给最佳响应者视图对应的视图控制器的手势识别器中。若手势识别器成功识别了事件，就Application会取消最佳响应者对对事件的响应；
	* 手势识别器UIGestureRecognizer同样通过那4个touch方法来判断是否接收事件的；
	* Window先将绑定了触摸对象的事件传递给触摸对象绑定的手势识别器，然后再发送给最佳响应者对应的hitTestView；手势识别器识别手势期间，若触摸对象的触摸状态发生了变化，事件会先发送给手势识别器，再发送给hitTestView；手势识别器若成功识别了手势，则会通知UIApplication取消hitTestView对事件的响应；若手势识别器未能识别手势，此时触摸接收，则停止向手势识别器发送事件，仅向hitTestView发送事件；所手势识别器未能识别手势，且此时触摸已结束，则向hitTestView发送end状态以停止对事件进行响应。
将手势识别器的delaysTouchesBegan属性置为YES表示是否在手势识别期间截断事件，不将事件发送给hitTestView；
	* **UIControl比手势识别器的响应优先级更高**。比如UIButton。

[触摸事件全家桶](https://www.jianshu.com/p/c294d1bd963d)


### 网络相关
#### HTTP：
http其实就是超文本传输协议，它主要包括请求报文和响应报文两部分组成。请求报文包括：方法(get、post)、url、http版本、首部字段(媒体类型、Encode编码格式、认证信息等)、实体主题；响应报文包括：http版本、状态码、首部字段(accept_range字节范围、时间、重定向URI)、实体主题。

**http的特点**：无连接（也就是每次请求连接都需要经历连接和断开的过程）、无状态（同一个用户在多次发送http请求时，server端并不知道是同一个用户发送的）

**状态码**：2xx、3xx、4xx、5xx，200请求成功，301、302一般是重定向问题、404一般是网络问题、504一般是指服务器问题。

**Get和Post的区别**：Get请求的参数通过？拼接在URL后面，post则放在Body里面。然后Get是安全的、幂等的、可缓存的，Post是非安全的、非幂等的、非可缓存的。安全性是指是否会引起server端的变化，幂等是指一种请求方法执行多次的结果是否完全相同，可缓存的是指代理服务器是否会进行缓存。

**TCP三次握手**：客服端向server端发送一个请求报文，server端接收到请求报文后会发送一个确认响应报文同时也附带一个建立连接的请求报文，客户端收到server端发来的请求报文后再会给server端一个确认报文。

**TCP四次挥手**：客户端向server端发送一个请求断开连接的报文，server端收到后会返回一个确认报文（这样客户端对server的连接就断开了），然后server端向客户端发送一个断开连接的请求报文，客户端收到后回复一个确认报文（这样server端对客户端的连接也断开了）

**持久连接**：应对http无连接特点。指在一定时间范围内不需要反复进行握手和挥手动作。http提供的持久连接的方案就是修改请求头部字段，比如connection: keep-alive(客户端期许采用持久连接)、time:20(持久连接时间)、max：10(这条连接最多可以发生多少次请求和响应对)。
那怎么判断持久连接中的一次连接已结束呢？1)通过响应头部字段：content-length:1024来判断。2)还有就是最后一个报文的chunked字段是否为空来判断。

**Charles的抓包原理**：利用了http中间人攻击漏洞进行抓包，中间人就是模仿客户端和server端的所有操作。

#### HTTPS
**HTTPS**：HTTPS = HTTP + SSL/TLS。
HTTPS连接的建立流程：客户端先向server发送一个SSL版本及支持的加密算法和随机数C，server会返回一个选定的加密算法、随机数S、server端证书。客户端接收到后会先验证server证书（也就是server端公钥），然后通过C、S、预组秘钥组装成会话秘钥，之后通过server端公钥对预组秘钥进行加密发送给server端，server端则通过私钥解密预组秘钥，然后通过C、S、预组秘钥组装会话秘钥。然后客户端和server端相互发送一个加密消息，验证安全通道是否建立完成。
HTTPS都使用了哪些加密手段？
对称加密和非对称加密。非对称加密在公私钥中使用到，传输过程中则是使用对称加密。
什么是非对称加密和对称加密？
非对称加密包含两个概念：公钥、私钥。加解密使用的钥匙不一样的。用公钥加密，就得用私钥解密；私钥加密就得用公钥解密。
对称加密：加解密用的是同一个秘钥。

#### TCP/UDP
**UDP**：用户数据报协议。
UDP特点：无连接、尽最大努力交付（不保证可靠传输）、面向报文(既不合并报文也不拆分报文，会原封不动传输报文，只是在运输层会拼装一个UDP首部)；
UDP提供的功能：复用(就是不同的端口都可以复用传输层UDP数据报)、分用(接收到数据报后，会根据目的端口进行分发)、差错检测(就是发送方通过某种方法计算出某个数据，将其插入到UDP首部传输给接收方，然后接收方接收到数据后，运用相同的方式进行计算，然后对比接收到的数据，进行差错检测。)

**TCP**：传输控制协议。则需要建立连接。
TCP特点：面向连接（数据传输开始和结束需要建立和释放连接）、可靠传输（无差错、无重复、按序到达）、面向字节流、流量控制、拥塞控制。

Q1:为什么是3次握手，而不是两次？
假如客户端发送建立连接的请求报文发生了超时，客户端会启用超时重传策略，重新发送连接请求，Server端收到了会回复确认报文，那之后又收到了之前超时的请求连接，那就又会建立一次连接，这样就可能建立了两次连接。而多了那次客户端确认报文则可以解决这种问题。

Q2、为什么是4次挥手，要分别断开两个方向的链接？
因为TCP建立的是一个全双通的链接，就是无论从客户端到server端，还是server端到客户端，都可以建立单独的发送与确认接收的通道，比如说在4次握手中，如果仅仅是进行了前两步（断开了客户端到server端的链接），那么此时客户端是不能向server端发送数据的，但是server端依旧可以向客户端发送数据。

Q3 、怎么保证可靠传输的？
可靠传输是通过停止等待协议来实现的。它是包括4方面的：

无差错情况：就是每次报文的传输中，server端收到后都会返回一个确认报文。

超时重传：那如果超时了，也就意味着在这个时间范围内，server端没有收到报文，也自然没有返回确认报文，那客户端就会进行重新发送。

确认丢失：是指server端返回的确认报文丢失了，那么同样的，客户端没有在时间限定内收到确认，所以会进行重新发送。server端会将第一次接到的报文丢失掉。

确认迟到：指确认报文迟到了，客户端同样会进行确认丢失一样的操作。

Q4、面向字节流?
是指TCP并不是原封不动地将发送方发送的字节一次性地完全地传输给接收方，而是会根据实际情况对字节流进行拆分或合并，然后再进行发送。和UDP的面向报文的方式正好相反。

Q5、怎么做到流量控制、按序到达？
通过滑动窗口协议实现。TCP的发送缓存当中的数据都有字节编号，然后我们进行排序。将每次发送出去后收到的确认报文位置进行标记，将将要发送的字节流中的最后字节进行标记。然后这大概就是字节流中的一个小的字节窗口。但是为了避免接收方数据溢出，所以接收方需要动态调节发送方的窗口大小来控制发送速率（比如接收方只能接收2个字节了，那么发送方就最多只能发送2个字节。这个应该是放在报文的首部字段）。同样的，接收缓存中也会对已接收的字节进行排序，它会对按序到底的下一个期望到达的字节进行标记（比如已经接收了1、2、3字节，那么期望标记就是第4个字节，而返回给长层应用程序的字节就是这些已按序到底的字节部分，那比如说还接收到了第6个字节，则暂时不会进行处理。）。所以呢，这个滑动窗口协议就可以进行流量控制和按序到达了。

Q6、拥塞控制：
慢开始、拥塞避免：一开始先发送一个报文，如果没有发送拥塞，则翻倍发送2个，然后再4个、16个(指数增长的方式)。一直达到窗口的门限初始值为止；然后再通过拥塞避免的策略，以线性增长的方式发送报文，可能达到某个值得时候，就产生了网络拥塞（比如连续3个报文没有收到确认报文），此时就越高采用拥塞避免的乘法减小的策略，只发送一个报文，同时将门限值降低，然后重新开始“慢开始”。

快恢复、快重传：是指在达到拥塞时，回到新的门限值，以线性增长的方式发送报文，而不经过前面指数增长的慢开始阶段。

#### DNS解析：
DNS解析过程？
DNS服务器是提供域名到IP之间的解析服务，一般计算机就是一个IP地址，但是纯数字不符合人类的记忆习惯，所以一般会有一个域名，比如www.baidu.com ，当我们代码对某个域名发起访问的时候，则要通过DNS解析，找到对应的IP，然后再进行访问 。一般DNS解析都是有运营商进行管理，比如移动的卡发出来的访问，先经过移动运营商，然后移动运营商找到对应的ip，然后进行访问。
DNS采用UDP数据报文，53端口号，且明文。

DNS解析查询方式：
1、递归查询：按照 本地DNS——根域DNS——顶级DNS——权限DNS的层级一层层递归查找；
2、迭代查找：先查询本地DNS，然后本地DNS依次询问根域DNS、顶级DNS、权限DNS；
DNS劫持问题？
因为DNS是UDP明文传输，就有可能被钓鱼DNS劫持，返回错误的IP地址。
DNS劫持与解析都与http无关，它是发生在http之前的操作。
解决DNS劫持：
1、httpDNS：实际上DNS解析是指DNS协议向DNS服务器的53端口进行请求，采用HTTPDNS这种方式则是直接通过http协议向DNS服务器的80端口进行请求，这样实际上就不存在DNS解析了，所以也就不存在DNS解析问题了。比如：http://119.29.29.29/d?dn=www.baidu.com&ip=163.177.153.109 (其中http://119.29.29.29/d 是国内最大的DNS域名服务器，dn=www.baidu.com 是需要解析的域名，后面是本地IP地址)
2、长连接：
客户端采用 长连server 从API Server通过内网专线获取IP的方式

DNS解析转发问题？
是指DNS解析服务器为了节省资源，将解析请求发送给其他DNS域名服务器，依次转发，最后返回的IP地址可能不是同一运营商的网络，存在跨网访问的可能，造成一些请求缓慢等效率问题。

#### Session/Cookie
应对http无状态特点，指多次发送同一个请求，server端无法知道是否是同一个用户。
Cookie主要是用来记录用户状态，区分用户；状态主要保存在客户端；
Session也是主要用来记录用户状态，区分用户；状态主要存放在server端。

### socket

socket 是使用标准Unix文件描述符合其他程序进行通讯的方式，实际上是对TCP、UDP的一层接口封装！

* socket与http：
* socket 打洞：


### 实践与优化
##### runtime 及其埋点和越界崩溃
runtime是指在程序运行期间才能确认对应的数据类型和方法调用等，OC有三大动态特性动态类型、动态加载、动态绑定，这都是通过runtime的机制实现的。

* 埋点
埋点主要是为了抓取一些主要的日志数据，然后上报。以便于在一些特殊的节点，可以通过日志查找到相关的数据和用户操作信息，更利于解决问题。
首先我们需要对日志进行分类，1是基本的接口日志(主要运用于测试)，2是用户的主要操作日志，3是主要节点日志(比如购买的信息身份的转变等)，4是异常日志(这个主要是依赖于bugly)
1、页面的统计：使用Method Swizzing代码混淆，重写UIViewController的ViewDidLoad方法。
2、点击统计：通过Method Swizzing代码混淆，hook sendAction:to:forEvent:方法。
3、tableview的cell点击：通过hook setDelegate方法，在设置代理时，再Swizzing代理实现了的didSelect方法。
4、然后剩余的关键节点的日志就得使用代码进行log了。

然后就是上传服务器，可以在日志达到一定容量时进行上传。记得添加断点续传

* 越界崩溃
首先越界崩溃也是通过runtime的方法混淆来做的，但是需要注意的是：抽象工厂模式的一些类的具体实现是隐藏的，也就是说，它们对应的真实名字分别是：NSArray----- NSArrayI；NSMutablArray ---- NSArrayM；NSDictionary---NSDictionaryI；NSMutableDictionary ---- NSDictionaryM。
然后使用swizing混淆相应方法。比如objectAtIndex


### 播放器
通过kvo的方式监听"Status"和"loadedTimeranges"来分别监听播放状态和缓存时长。

### FPS检测原理：CADisplayLink

### 直播的流程和API:

### IM流程：

### 音视频相关:


### 常用三方库的实现原理和总结
3、Alamofire、SwiftJSon、SDWebImage、AsyncDisplayKit、realm大概使用与实现原理
#### AFNetworking
整体框架：AFNetWorking整体框架主要是由会话模块(NSURLSession)、网络监听模块、网络安全模块、请求序列化和响应序列化的封装以及UIKit的集成模块(比如原生分类)。
其中最核心类是AFURLSessionManager，其子类AFHTTPSessionManager包含了AFURLRequestionSerialzation(请求序列化)、AFURLResponseSerialzation(响应序列化)两部分；同时AFURLSessionManager还包含了NSURLSession(会话模块)、AFsecurityPolicy(网络安全模块：证书校验)、AFNetWorkingReachabilityManager(负责对网络连接进行监听)；
AFURLSessionManager主要工作包括哪些？
1、负责管理和创建NSURLSession、NSURLSessionTask
2、实现NSURLSessionDelegate等协议的代理方法
3、引入AFSecurityPolicy保证请求安全
4、引入AFNetWorkingReachabilityManager监听网络状态

#### Alamofire：同一个作者写的swift版本的AFNetWorking

整体框架：Alamofire核心部分都在其Core文件夹内，它包含了核心的2个类、3个枚举、2个结构体；另一个文件夹Feature则包含了对这些核心数据结构的扩展。
2个类：Manager(提供对外接口，处理NSURLSession的代理方法)；Request(对请求的处理)；
3枚举：Method(请求方法)；ParameterEncoding(编码方式)；Result(请求成功或失败数据结构)
2结构体：Response(响应结构体)；Error(错误对象)
扩展中包括Manager的Upload、Download、Stream扩展、以及Request的扩展Validation和ResponseSerialization。
怎么处理多并发请求？
使用NSOperetionQueue！

#### SDWebImage：
整体框架：SDWebImage更多的是封装的UIKit的一些分类方法，比如说UIImageView+WebCache。主要功能是由SDWebImageManager进行管理，在此之下主要分为两部分：SDImageCache和SDWebImageDownloader，SDImageCache又同时分为磁盘缓存和内存缓存。
加载图片的流程：通过图片URL的hash值作为key值去查找内存缓存，如果内存缓存找不到则查找磁盘缓存，如果仍然没有查找到就去进行网络下载

#### AsyncDisplayKit：
整体框架：
正常情况下，UIView作为CALayer的delegate，而CALayer作为UIView的一个成员变量，负责视图展示工作。ASDK则是在此之上封装了一个ASNod类，它有点view的成员变量，可以生成一个UIView，同时UIView有一个.node成员属性，可以获取到它所对应的Node。而ASNode是线程安全的，它可以放到后台线程创建和修改。所以平时我们对UIView的一些相关修改就可以落地到对ASNode的属性的修改和提交，同时模仿Core Animation提交setneeddisplayer的这种形式把对ASNode的修改进行封装提交到一个全局容器中，然后监听runloop的beforewaiting的通知，当runloop进入休眠时，ASDK则可以从全局容器中把ASNode提取出来，然后把对应的属性设置一次性设置给UIView。

主要解决的问题：布局的耗时运算(文本宽高、视图布局运算)、渲染(文本渲染、图片解码、图形绘制)、UIKit的对象处理(对象创建、对象调整、对象销毁)。因为这些对象基本都是在UIKit和Core Animation框架下，而UIKit和Core Animation相关操作必须在主线程中进行。所以ASDK的任务就是把这些任务从主线挪走，挪不走的就尽量优化。

### 数据库
#### Realm：
<https://juejin.im/entry/5a1d44a6f265da432f30dd09>


### 算法
##### 二叉树:
前序、中序、后序遍历指的是根节点的位置。
中序：
```OC
//中序，使用栈
-(void)sourt1:(Node *)root{
   Node* p = root;
   stack<Node *> s;
   while(!s.empty() || p){
       if(p){ //先将左子树全部入栈
           s.push(p);
           p = p.leftchild;
       }else{
           p = s.top();
           s.pop();
           print(p.value);//打印
           p = p.rightChild; //进入右子数
       }
   }
}
//前序：也是使用栈
-(void)sourt2:(Node *)root{
   Node* p = root;
   stack<Node *> s;
   while(!s.empty() || p){
       if(p){ //先将左子树全部入栈
	       print(p.value);//打印
           s.push(p);
           p = p.leftchild;
       }else{
           p = s.top;
           s.pop();
           p = p.rightChild; //进入右子数
       }
   }
}
//后序：也是使用栈。这个好难，先放弃吧

```




