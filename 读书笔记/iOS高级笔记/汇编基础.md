---
title: 汇编基础
date: 2020-8-2 8:00:00
tags: 汇编
categories: 汇编
description:  学习基础汇编语法
---

### 程序本质

* 软件\程序的执行过程
  通常写的程序代码是存储在**硬盘**当中，当程序启动的时候就会被装载进**内存**中，然后**CPU**从内存中读取程序，解析到程序要干什么后，就会控制**计算机**的各种硬件，比如屏幕、音响。当然CPU在读取解析程序的过程中，也可能会往内存中写一部分数据。
  **CPU**主要由三部分组成：寄存器、运算器、控制器；寄存器主要用来存储数据的，运算器主要用来做运算处理。通常情况下计算机会将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行运算。 
  举个例子：假设内存中有一块内存地址0xAxx，内存存储的值是3，然后要对3进行加一操作，然后放到另一块内存0xBxx中，类似代码:
  ```
  var a = 3
  var b = a + 1
  ```
  具体步骤就是：
  * > CPU会先将第一块内存地址的值放到rax寄存器中：movq 0xAxx, %rax
  * > 然后让rax寄存器与1相加：addq $0x1, %rax
  * >最后将值赋值给内存空间：movq %rax, 0xBxx

* 通常情况下，高级语言需要先编译成汇编，汇编再编译成机器语言，最后机器语言运行在计算机上。这两个过程都称之为**编译**。汇编语言与机器语言是一一对应的，所以机器语言也可以**反编译**成汇编指令。
* 汇编严重依赖于计算机架构。比如32位的x86汇编，64位的x64汇编，移动和嵌入式的ARM汇编。作为iOS开发，最主要的汇编语言是AT&T汇编(应用于iOS模拟器)和ARM汇编(应用于iOS真机)

### 常见汇编指令 AT&T
* 寄存器命名：%rax 、%eax、%ax、%ah 					//通常会使用%表示,以r开头的都是64位架构下的8字节寄存器,e开头的都是32位架构下的4字节寄存器，不以r、e开头且没有h、l的寄存器都是16位架构下2字节的，其他带h、l的则表示1个字节，其中h是high（高字节）的意思，l是low（低字节）的意思。
* 操作位顺序：movq %rax, %rdx			//将rax的值赋值给rdx寄存器
* 常数\立即数(立即数就是字面量)：movq $3,%rax			//将3赋值给rax
* 内存赋值：movq $0xa, 0x1ff7(%rip)	 //将0xa赋值给地址值为rip+0x1ff7的内存
* 取内存地址：leaq -0x18(%rbp),%rax	 //将rbp-0x18这个地址赋值给rax。**这里要注意了movq是取地址里的值进行赋值，leaq则是直接取地址进行赋值**
* jmp跳转：jump *%rdx；jump 0x4001002 //这两句语句都是表示跳转
* call跳转：call 0x4001002			   //call和jump的区别在于jump跳转过去后就不会再回到原来的指令之后继续执行，call则是跳转过去后会回到原来指令之后的指令继续执行；
* 操作数长度：movl、movq、leaw 		   //mov、lea这些操作符后面的字母都代表操作数的长度：b=byte(8-bit);s=short(16-bit int or 32-bit float);w=word(16-bit);l=long(32-bit int or 64-bit float);q=quad(64-bit);t=ten bytes(80-bit float)
* 16个常用寄存器：rax、rbx、rcx、rdx、rsi、rdi、rbp、rsp、r8、r9、r10、r11、r12、r13、r14、r15
  * rip是下一行指令的地址值；
  * rax 一般作为函数的返回值；
  * rsi、rdi、rdx、rcx、r8、r9等寄存器一般用于存放函数参数；
  * rsp、rbp用于栈操作；
  * **内存地址格式为 0x4bdc(%rip) 一般是全局变量；内存地址格式为 -0x78(%rbp)一般为局部变量；内存地址格式为0x10(rax)一般为堆空间；**
* 

### LLDB常用指令
* 读取所有寄存器的值：register read
* 读取寄存器的值：register read rax
* 对寄存器写入值：register write rax 10
* n：单步运行，把子函数当做整体一步执行(源码级别)
* s：单步运行，遇到子函数会进入子函数运行(源码级别)
* ni：单步运行，把子函数当做整体一步执行(汇编级别)
* si：单步运行，遇到子函数会进入子函数运行(汇编级别)
* finish：直接执行完当前函数的所有代码，返回到上一个函数(遇到断点会卡住)
