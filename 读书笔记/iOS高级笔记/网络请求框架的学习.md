---
title: iOS-网络请求框架的学习
date: 2020-8-5 11:36:48
tags: network
categories: iOS进阶
description:  从基础的iOS原生网络请求到分析Alamofire源码及使用，然后二次封装Alamofire。来学习iOS完整的网络请求流程与架构搭建思路。
---

### iOS 原生 URLSession

#### 一个正常HTTP/HTTPS网络请求的实际过程 (**重点**)
* 建立NSURLSessionTask，并且resume；
* 检查cache策略，如果有需要从本地cache中直接返回数据；
* 通过DNS进行域名查找；
* 建立TCP链接；
* 如果是HTTPS，进行TLS认证；
* 开始请求；
* 收到HTTP的response；
* 接收HTTP的Data。

#### URLSession的简单使用步骤：
* 1、设置Config（可选）；
* 2、创建Session；
* 3、创建Task；
* 4、resume()，开启Task
* 5、使用delegate或block监听回调（可选）；

#### 解析
* Config是设置URLSession的基础信息，URLSession不设置Config也可以发起请求，实际使用的是默认的Config。Config可以设置Cookie、设置安全策略(TLS协议之类的)、设置缓存策略、是否支持后台继续、设置http策略和代理、链接变化等。 
* URLSession有3种类型：
	* default session：默认模式，该模式下系统创建一个持久化的缓存并在用户的钥匙串中存储证书，允许configuration使用代理持续获取数据。通常我们就使用默认模式就足够了
	* Ephemeral session：没有任何持久性存储，所有接口与session生命周期一致，且不存储cookie、证书相关；
	* Background session：后台会话模式（该模式可以在后台完成上传和下载。）。background模式和Default模式非常相似，不过background模式会使用一个单独的线程进行传输。它可以在程序挂起、退出、崩溃的情况下运行task，也可以利用标识符来恢复。注意，后台session在创建的时候一定要赋予一个唯一的identifier，这样APP下次运行的时候，能够根据identifier进行区分。如果用户关闭了APP，iOS会关闭所有background session，而且被用户强制关闭了以后，只有下次启动后，数据传输才会继续。
* URLSessionTask也有4种类型：
	* URLSessionDataTask：处理从HTTP get请求中从服务器获取数据到**内存**中；
	* URLSessionUploadTask：上传文件到服务器，一般用于POST、PUT；
	* URLSessionDownloadTask：从远程服务器下载文件到**临时文件**位置；
	* URLSessionStreamTask：通过流文件传输；
#### 实践：
* 上传：
```
func upload() {
        /// 设置config
        let config = URLSessionConfiguration.default
        ///创建session
        let session = URLSession(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
        //根据url设置Task
        let url = URL(string: "")
        var request = URLRequest(url: url!)
        request.httpMethod = HTTPMethod.post.rawValue
        let updata = UIImage(named: "")?.pngData()
        let upTast = session.uploadTask(with: request, from: updata) { (data, res, error) in
            if error != nil {
                //
            }else{
                print("上传完毕")
            }
        }
        //开启
        upTast.resume()
    }
```
* 普通下载
```
// 1、设置下载
func download() {
        /// 设置background config, 也可以在正常情况下正常下载
        let config = URLSessionConfiguration.background(withIdentifier: "backgroundIdentifier")
        /// session
        let session = URLSession.init(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
        /// 创建tast
        let downloadTast = session.downloadTask(with: URL(string: "")!)
        /// 开始下载
        downloadTast.resume()
    }
}

// 2、URLSessionDownloadDelegate
func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        print("下载完成")
    }
    
func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        print(" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)")
        print("下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n")
    }
```
* 后台下载（在上诉普通下载的基础之下加上下面步骤）
```
// 3、在AppDelegate里保存后台下载的completionHandler
  var backgroundSessionCompletionHandler: (() -> Void)?
  func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {
      self.backgroundSessionCompletionHandler = completionHandler
  }

// 4、下载完成时，调用系统回调URLSessionDownloadDelegate，更新屏幕
 func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
        print("后台任务")
            DispatchQueue.main.async {
                guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let backgroundHandle = appDelegate.backgroundSessionCompletionHandler else { return }
                backgroundHandle()
            }
    }

//解析：其实实现完第3步就基本实现了后台下载功能了，程序挂起后台后还是依旧可以继续下载的。当task完成后(无论成功或失败),系统都会走handleEventsForBackgroundURLSession回调。第4步则是苹果要求在下载完成后需要实现这个代理，以达到更新屏幕的目的。
```
* 断点续传，关键点就是在cancel的时候使用一个data把数据暂存起来。
```
//
var session: URLSession?
var downloadTast: URLSessionDownloadTask?
//暂存的已加载数据
var partialData: Data?

extension ViewController2 {
    //开始下载
    func download() {
        /// 设置background config
        let config = URLSessionConfiguration.background(withIdentifier: "backgroundIdentifier")
        /// session
        self.session = URLSession.init(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
        /// 创建tast
        downloadTast = session!.downloadTask(with: URLRequest(url: URL(string: "")!))
        /// 开始下载
        downloadTast?.resume()
    }
    
    //挂起
    func onSuspend() {
        guard let tast = self.downloadTast else {
            return
        }
        tast.cancel {[weak self] (resumeData) in
            self?.partialData = resumeData
            self?.downloadTast = nil
        }
    }
    
    //恢复下载， 有暂存的已下载数据，传入已下载数据重新创建Task
    func onResume() {
        if self.downloadTast == nil {
            if self.partialData == nil {
                self.downloadTast = session?.downloadTask(with: URLRequest(url: URL(string: "")!))
            }else{
                self.downloadTast = session?.downloadTask(withResumeData: self.partialData!)
            }
            
            self.downloadTast!.resume()
        }
        
    }
}

//监听代理
extension ViewController2 : URLSessionDownloadDelegate {
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        print("下载完成")
    }
    
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        print(" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)")
        print("下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n")
    }
}
```

### Alamofire的使用与架构分析
Alamofire 核心也是在URLSession和URLSessionTask的基础之上进行分装的。使用swift语法进行链式访问。它的设计非常简洁，完整地将网络请求、URL校验、失败重试机制、请求缓存机制、错误机制、响应解析等功能封装在一起。
#### Alamofire整体框架
* 线程相关：Protected.swift 
  Protect主要是将不同类型的任务实现了加锁处理，然后这个文件中封装了两种锁（互斥锁和自旋锁），iOS系统使用的是自旋锁。

* 会话：Session.swift、SessionDelegate.swift 
	* Session是Alamofire的对外接口。它利用组合模式对整个请求过程及回调处理进行管理。具体的工作就包括生成URLSession
  Session主要是生成URLSession，然后用于管理SessionDelegate和Request。

* 请求：Request.swift、RequestTaskMap.swift、RequestInterceptor.swift
  * Request 是Alamofire请求类型的公共超类，主要包含了状态、委托、回调处理等信息。其子类主要就是DataRequest、UploadRequest、DownloadRequest、StreamRequest；
  * RequestInterceptor是请求拦截器，由RequestAdapter和RequestRetry组成，用于在发送请求之前修改Request和请求失败之后的重试策略。
  * RequestAdapter叫做适配器，用来做请求前和请求之后的适配，比如用来设置一些公关参数、token之类的，然后在request成功或失败时对request进行适配（其实就是修饰一下，把request的一些相关属性设置一下的意思）；
  * RequestRetry用于重试策略；

* 响应：Response.swift、ResponseSerialization.swift

* 验证：URLConvertable+URLRequestConvertible.swift、Validation.swift

* 事件监听：EventMonitor.swift

* 综合：Alamofire.swift、AFError.swift、AlamofireExtended.swift

	* Alomofire.swift就定义了一个AF常量，是Session类型，类似于命名空间的作用；所以请求可以直接使用AF调用，更简洁明了。

#### Alamofire 请求过程和设计思路
首先看一下Alamofire的入口及解析

* 入口函数参数及返回值解析：
           * convertible: URLConvertible // 一个协议类型,可以是这里传入String、URL、URLComponents；
           * method: HTTPMethod // 方法结构体，包含常用的所有方法类型；
           * parameters: Encodable // 实现了Encodable协议的实例；
           * encoder: ParameterEncoder // 实现了ParameterEncoder协议的实例，是编码格式，比如json，这个协议最终生成一个URL；
           * headers: HTTPHeaders //请求头部信息；
           * interceptor: RequestInterceptor // 拦截器，封装了适配器和重试策略；
           * requestModifier: RequestModifier // 封装了一个闭包，可以在闭包里对URLRequest进行处理；
  * return: DataRequest //最终返回一个DataRequest，它继承自Request，对应URLSessionDataTask，是对整个请求过程封装的一个组合类，可以理解为一次请求就生成一个DataRequest，然后它包含了整个请求过程的几乎所有数据。

```
AF.request(_ convertible: URLConvertible,
                      method: HTTPMethod = .get,
                      parameters: Parameters? = nil,
                      encoding: ParameterEncoding = URLEncoding.default,
                      headers: HTTPHeaders? = nil,
                      interceptor: RequestInterceptor? = nil,
                      requestModifier: RequestModifier? = nil) -> DataRequest
```
* 之后会根据传入的除了RequestInterceptor之外的所有参数来构建RequestConvertible，这个类型主要作用是持有这些参数并生成URLRequest；然后创建DataRequest实例；最后将DataRequest实例放入请求队列里，根据它的类型来开启请求。这里同样要说明的是DataRequest实例根据其具体的类型，也分为UploadRequest、DataRequest、DownloadRequest、DataStreamRequest，基本和URLSessionTask的类型对应。
* 









<https://juejin.im/post/6844904118008430606>















<https://juejin.im/post/6844904036169154574#heading-10>

<https://blog.csdn.net/zgpeace/article/details/103069788>

<https://rayy.top/2019/12/09/alamofire/>