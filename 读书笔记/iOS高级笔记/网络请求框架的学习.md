---
title: iOS-网络请求框架的学习
date: 2020-8-5 11:36:48
tags: network
categories: iOS进阶
description:  从基础的iOS原生网络请求到分析Alamofire源码及使用，然后二次封装Alamofire。来学习iOS完整的网络请求流程与架构搭建思路。
---
### iOS 原生 URLSession
#### URLSession的使用步骤：
* 1、设置Config（可选）；

* 2、创建Session；

* 3、创建Task；

* 4、resume()，开启Task

* 5、使用delegate或block监听回调（可选）；

#### 解析
* Config是设置URLSession的基础信息，URLSession不设置Config也可以发起请求，实际使用的是默认的Config。Config可以设置Cookie、设置安全策略(TLS协议之类的)、设置缓存策略、是否支持后台继续、设置http策略和代理、链接变化等。 
* URLSession有3种类型：
	* default session：默认模式，该模式下系统创建一个持久化的缓存并在用户的钥匙串中存储证书，允许configuration使用代理持续获取数据。通常我们就使用默认模式就足够了
	* Ephemeral session：没有任何持久性存储，所有接口与session生命周期一致，且不存储cookie、证书相关；
	* Background session：后台会话模式（该模式可以在后台完成上传和下载。）。background模式和Default模式非常相似，不过background模式会使用一个单独的线程进行传输。它可以在程序挂起、退出、崩溃的情况下运行task，也可以利用标识符来恢复。注意，后台session在创建的时候一定要赋予一个唯一的identifier，这样APP下次运行的时候，能够根据identifier进行区分。如果用户关闭了APP，iOS会关闭所有background session，而且被用户强制关闭了以后，只有下次启动后，数据传输才会继续。
* URLSessionTask也有4种类型：
	* URLSessionDataTask：处理从HTTP get请求中从服务器获取数据到**内存**中；
	* URLSessionUploadTask：上传文件到服务器，一般用于POST、PUT；
	* URLSessionDownloadTask：从远程服务器下载文件到**临时文件**位置；
	* URLSessionStreamTask：通过流文件传输；
#### 实践：
* 上传：
```
func upload() {
        /// 设置config
        let config = URLSessionConfiguration.default
        ///创建session
        let session = URLSession(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
        //根据url设置Task
        let url = URL(string: "")
        var request = URLRequest(url: url!)
        request.httpMethod = HTTPMethod.post.rawValue
        let updata = UIImage(named: "")?.pngData()
        let upTast = session.uploadTask(with: request, from: updata) { (data, res, error) in
            if error != nil {
                //
            }else{
                print("上传完毕")
            }
        }
        //开启
        upTast.resume()
    }
```
* 普通下载
```
// 1、设置下载
func download() {
        /// 设置background config, 也可以在正常情况下正常下载
        let config = URLSessionConfiguration.background(withIdentifier: "backgroundIdentifier")
        /// session
        let session = URLSession.init(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
        /// 创建tast
        let downloadTast = session.downloadTask(with: URL(string: "")!)
        /// 开始下载
        downloadTast.resume()
    }
}

// 2、URLSessionDownloadDelegate
func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        print("下载完成")
    }
    
func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        print(" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)")
        print("下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n")
    }
```
* 后台下载（在上诉普通下载的基础之下加上下面步骤）
```
// 3、在AppDelegate里保存后台下载的completionHandler
  var backgroundSessionCompletionHandler: (() -> Void)?
  func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {
      self.backgroundSessionCompletionHandler = completionHandler
  }

// 4、下载完成时，调用系统回调URLSessionDownloadDelegate，更新屏幕
 func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
        print("后台任务")
            DispatchQueue.main.async {
                guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let backgroundHandle = appDelegate.backgroundSessionCompletionHandler else { return }
                backgroundHandle()
            }
    }

//解析：其实实现完第3步就基本实现了后台下载功能了，程序挂起后台后还是依旧可以继续下载的。当task完成后(无论成功或失败),系统都会走handleEventsForBackgroundURLSession回调。第4步则是苹果要求在下载完成后需要实现这个代理，以达到更新屏幕的目的。
```
* 断点续传，关键点就是在cancel的时候使用一个data把数据暂存起来。
```
//
var session: URLSession?
var downloadTast: URLSessionDownloadTask?
//暂存的已加载数据
var partialData: Data?

extension ViewController2 {
    //开始下载
    func download() {
        /// 设置background config
        let config = URLSessionConfiguration.background(withIdentifier: "backgroundIdentifier")
        /// session
        self.session = URLSession.init(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
        /// 创建tast
        downloadTast = session!.downloadTask(with: URLRequest(url: URL(string: "")!))
        /// 开始下载
        downloadTast?.resume()
    }
    
    //挂起
    func onSuspend() {
        guard let tast = self.downloadTast else {
            return
        }
        tast.cancel {[weak self] (resumeData) in
            self?.partialData = resumeData
            self?.downloadTast = nil
        }
    }
    
    //恢复下载， 有暂存的已下载数据，传入已下载数据重新创建Task
    func onResume() {
        if self.downloadTast == nil {
            if self.partialData == nil {
                self.downloadTast = session?.downloadTask(with: URLRequest(url: URL(string: "")!))
            }else{
                self.downloadTast = session?.downloadTask(withResumeData: self.partialData!)
            }
            
            self.downloadTast!.resume()
        }
        
    }
}

//监听代理
extension ViewController2 : URLSessionDownloadDelegate {
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        print("下载完成")
    }
    
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        print(" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)")
        print("下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n")
    }
}
```

### Alamofire的使用
Alamofire 核心也是在URLSession和URLSessionTask的基础之上进行分装的。使用swift语法进行链式访问。
#### Alamofire整体框架
* 线程相关：Protected.swift 
	Protect主要是将不同类型的任务实现了加锁处理，iOS系统使用的是自旋锁。
* 会话：Session.swift、SessionDelegate.swift 
	Session主要是生成URLSession，然后用于管理SessionDelegate和Request。
* 请求：Request.swift、RequestTaskMap.swift、RequestInterceptor.swift
	* RequestInterceptor是请求拦截器，由RequestAdapter和RequestRetry组成，用于在发送请求之前修改Request和请求失败之后的重试策略。
	* 
* 响应：Response.swift、ResponseSerialization.swift
	
* 验证：URLConvertable+URLRequestConvertible.swift、Validation.swift
	
* 事件监听：EventMonitor.swift
	
* 综合：Alamofire.swift、AFError.swift、AlamofireExtended.swift
	



<https://juejin.im/post/6844904118008430606>

<https://juejin.im/post/6844904036169154574#heading-10>

<https://blog.csdn.net/zgpeace/article/details/103069788>

<https://rayy.top/2019/12/09/alamofire/>