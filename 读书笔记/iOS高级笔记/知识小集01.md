---
title: iOS-项目知识小集
date: 2020-5-9 17:36:48
tags: knoeledgePoints
categories: iOS进阶
description: 总结项目开发中的常用的进阶知识点
---

### swift 语言特性
#### swift与OC的区别

#### 函数式编程

swift是解析型静态语言、OC是编译型动态语言；swift更注重安全性，是强类型语言；OC更注重灵活性；swift有函数式编程、面向对象、面向协议编程，OC只有面向对象编程；swift更注重值类型，OC更遵循指针和索引。
1、数据结构：
* swift将String、Array、Dictionary设计成值类型，OC是引用类型。相较而言，1)、值类型更高效使用内存，它是在栈上操作，引用类型在堆上操作；2)、通过let和var来确认String、Array、Dictionary是可变还是不可变，让线程更加安全；3)、也让String可以遵循Collection这种协议，增加了灵活性
* 初始化的差别：swift的初始化更加严格准确，swift必须保证所有非optional的成员变量都完成初始化，同时新增convenience(便利初始化方法，必须通过调用同一个类中的designed初始化方法来完成)和required（强制子类重写父类所修饰的初始化方法）初始化方法
* swift的protocol协议更灵活，它可以对接口进行抽象，例如Sequence，配合extention、泛型、关联类型实现面向协议编程，同时它还可以用于值类型、如结构体和枚举
  2、语言特性：
  swift中，协议是动态派发，扩展是静态派发，也就是说如果协议中有方法声明，那么方法会根据对象的实际类型进行调用
```swift
protocol Chef{
    func makeFood()
}
extension Chef{
    func makeFood(){
        print("Make food")
    }
}

struct SeafoodChef:Chef{
    func makeFood(){
        print("cook seafood")
    }
}

let oneC:Chef = SeafoodChef()
let twoC:SeafoodChef = SeafoodChef()
oneC.makeFood()
twoC.makeFood()
//这里oneC和twoC实际上都是SeafoodChef类型，按照上述原则，这里会打印两个"cook seafood"。假如protocol中没有声明makeFood()，那么第一行打印的就会是"Make food"，因为没有声明的话，只会按照声明类型进行静态派发，也就是说oneC被声明成了Chef类型，所以oneC会调用扩展中的实现。
```
Q1、类和结构体的区别：
类是引用类型，结构体是值类型。类可以继承、运行时类型转换、用deinit释放资源、可以被多次引用；Struts结构小，适用于复制操作，相较引用更安全，无须担心内存泄漏和多线程冲突问题。
Q2、weak和unowned的区别weak和unowned的区别QQ2：
当访问对象可能已经被释放时，使用weak，例如delegate；当访问对象确认不可能被释放时，则用unowned，比如self的引用；实际上，为了安全，基本上都是使用weak。
Q3、如何理解copy-on-write:
当值类型进行复制时，实际上复制的对象和原对象还是处于同一个内存中，当且仅当修改复制后的对象时，才会在内存中重新创建一个新对象。这样是内存使用更高效。
Q4、初始化方法对属性的设定以及willSet和didSet里对属性设定都不会触发属性观察。


### APP架构
#### MVC
#### MVVM
简单介绍一下MVVM框架及ViewModel作用
说到MVVM之前，首先要先介绍一下MVC框架，MVC框架就是Model-View-Controller组成，其中Model负责呈现数据，View负责UI展示，Controller则负责调解Model和View直接的交互。这样就导致了大部分的处理逻辑都在Controller当中，所以它又被称为“重量级视图控制器”。而MVVM框架则表示Model--ViewModel--（View Controller），它其实就是对MVC的一个优化而已，它将业务逻辑、网络请求和数据解析放在了ViewModel层，大大简化了Controller层的逻辑代码，也让model 、view的功能更加独立单一。

#### MVP

* CTMeditor

#### 组件化、模块化、路由化
模块化的优势：各模块直接代码和资源相互独立，模块可以独立维护、测试等。实现简单的插拔式。
文件夹隔离：将各模块的业务代码整理到相应的模块文件夹中，将各个模块用到的资源、宏也沉淀到基础库里。s
路由化：首先我们通过MGJRouter实现简单的路由化，尽可能地解耦各个模块。它是通过注册组件，通过URL调用页面，通过路由表的映射关系进行关联。
其次模块化：主要是有两个方式：
1、通过cocoapod的方案将各个主代码模块打包成pod包的形式。然后通过配置podsepc来进行模块以及库直接的依赖。但是会存在很大问题，一个主要 的是文件夹只有一层，没法做分级。2是库循环依赖问题。
2、使用cocoa touch framework。主要注意的点是混编时，对外的头文件，尤其是swift中使用到的OC头文件放到public中，因为framework不支持bridge；framework中的内核架构。

#### 下载模块
首先需要一个manager管理整个app的下载事件；它负责管理每一个request。比如说取消、重新加载等操作。其次需要有一个Config配置类，用来配置基础信息，比如配置请求类型、cookie、时间等信息。然后有一个对response进行处理的工具，比如日志的筛选打印、对一些异常错误的处理等等

#### 图片缓存框架



### 项目相关
#### 播放器

通过kvo的方式监听"Status"和"loadedTimeranges"来分别监听播放状态和缓存时长。

https://juejin.im/post/5da1a30de51d457825210a8c

#### 直播框架与实践

#### IM流程：

#### 音视频相关:


### 单元测试与可持续集成

<https://juejin.im/post/5a3090f2f265da4310485d01>

### Swift Package Manager

<https://www.jianshu.com/p/479986e9ae80>


### 常用三方库的实现原理和总结
3、Alamofire、SwiftJSon、SDWebImage、AsyncDisplayKit、realm大概使用与实现原理
#### AFNetworking
整体框架：AFNetWorking整体框架主要是由会话模块(NSURLSession)、网络监听模块、网络安全模块、请求序列化和响应序列化的封装以及UIKit的集成模块(比如原生分类)。
其中最核心类是AFURLSessionManager，其子类AFHTTPSessionManager包含了AFURLRequestionSerialzation(请求序列化)、AFURLResponseSerialzation(响应序列化)两部分；同时AFURLSessionManager还包含了NSURLSession(会话模块)、AFsecurityPolicy(网络安全模块：证书校验)、AFNetWorkingReachabilityManager(负责对网络连接进行监听)；
AFURLSessionManager主要工作包括哪些？
1、负责管理和创建NSURLSession、NSURLSessionTask
2、实现NSURLSessionDelegate等协议的代理方法
3、引入AFSecurityPolicy保证请求安全
4、引入AFNetWorkingReachabilityManager监听网络状态

#### Alamofire：同一个作者写的swift版本的AFNetWorking

整体框架：Alamofire核心部分都在其Core文件夹内，它包含了核心的2个类、3个枚举、2个结构体；另一个文件夹Feature则包含了对这些核心数据结构的扩展。
2个类：Manager(提供对外接口，处理NSURLSession的代理方法)；Request(对请求的处理)；
3枚举：Method(请求方法)；ParameterEncoding(编码方式)；Result(请求成功或失败数据结构)
2结构体：Response(响应结构体)；Error(错误对象)
扩展中包括Manager的Upload、Download、Stream扩展、以及Request的扩展Validation和ResponseSerialization。
怎么处理多并发请求？
使用NSOperetionQueue！

#### SDWebImage：
整体框架：SDWebImage更多的是封装的UIKit的一些分类方法，比如说UIImageView+WebCache。主要功能是由SDWebImageManager进行管理，在此之下主要分为两部分：SDImageCache和SDWebImageDownloader，SDImageCache又同时分为磁盘缓存和内存缓存。
加载图片的流程：通过图片URL的hash值作为key值去查找内存缓存，如果内存缓存找不到则查找磁盘缓存，如果仍然没有查找到就去进行网络下载

#### AsyncDisplayKit：
整体框架：
正常情况下，UIView作为CALayer的delegate，而CALayer作为UIView的一个成员变量，负责视图展示工作。ASDK则是在此之上封装了一个ASNod类，它有点view的成员变量，可以生成一个UIView，同时UIView有一个.node成员属性，可以获取到它所对应的Node。而ASNode是线程安全的，它可以放到后台线程创建和修改。所以平时我们对UIView的一些相关修改就可以落地到对ASNode的属性的修改和提交，同时模仿Core Animation提交setneeddisplayer的这种形式把对ASNode的修改进行封装提交到一个全局容器中，然后监听runloop的beforewaiting的通知，当runloop进入休眠时，ASDK则可以从全局容器中把ASNode提取出来，然后把对应的属性设置一次性设置给UIView。

主要解决的问题：布局的耗时运算(文本宽高、视图布局运算)、渲染(文本渲染、图片解码、图形绘制)、UIKit的对象处理(对象创建、对象调整、对象销毁)。因为这些对象基本都是在UIKit和Core Animation框架下，而UIKit和Core Animation相关操作必须在主线程中进行。所以ASDK的任务就是把这些任务从主线挪走，挪不走的就尽量优化。

### 算法
##### 二叉树:
前序、中序、后序遍历指的是根节点的位置。
中序：
```OC
//中序，使用栈
-(void)sourt1:(Node *)root{
   Node* p = root;
   stack<Node *> s;
   while(!s.empty() || p){
       if(p){ //先将左子树全部入栈
           s.push(p);
           p = p.leftchild;
       }else{
           p = s.top();
           s.pop();
           print(p.value);//打印
           p = p.rightChild; //进入右子数
       }
   }
}
//前序：也是使用栈
-(void)sourt2:(Node *)root{
   Node* p = root;
   stack<Node *> s;
   while(!s.empty() || p){
       if(p){ //先将左子树全部入栈
	       print(p.value);//打印
           s.push(p);
           p = p.leftchild;
       }else{
           p = s.top;
           s.pop();
           p = p.rightChild; //进入右子数
       }
   }
}
//后序：也是使用栈。这个好难，先放弃吧

```
