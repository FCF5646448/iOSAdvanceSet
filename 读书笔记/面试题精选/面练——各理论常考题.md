---
title: iOS-技能知识小集
date: 2020-10-26 16:00:00
tags: knoeledgePoints
categories: 面试
description:  总结了iOS底层理论知识点所对应的面试题
---

### Runtime相关
#### OC对象
* 一个OC对象在内存中是如何布局的？
  一个NSObject被编译后是一个Objc_object的结构体，它里面只有一个isa指针，一个指针在64位系统下，占用8个字节。

* 一个NSObject对象占用多少内存？
  系统分配了16个 字节给NSObject对象。(一个对象最少占用16字节空间。另外从内存对齐的角度来开，内存对齐的方式：结构体大学必须是最大成员大小的倍数)
  但是NSObject对象内部只使用了8个字节的空间(在64位系统下)。

* 下面的Person对象和Student对象分别占用多少内存空间？
  ```
  @interface Person: NSObject 
  {
        int _age;
  }
  @end
  @interface Student: Person 
  {
        int _no;
  }
  @end	
  ```
  Person和Student对象都是占用了16个字节。

* isa指针指向哪里？



* OC的类信息存放在哪里？

#### Category
* Category的实现原理，为什么Category只能添加方法不能添加属性？
* Category中有load方法吗？load方法什么时候调用？load方法能继承吗？
* load、initialize在Category中的调用顺序，出现继承时，他们之间的调用过程
* load、initialize的区别，以及它们在Category重写时的调用次序？

#### KVO 
* iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么)

  KVO是根据里斯替换原则，在runtime时动态生成了一个NSKVONotifying_XXX的子类，然后利用Runtime的isa混写技术将当前类的isa指针指向动态生成的子类。然后会重写所监听属性的setter方法。

  setter方法里代码：

  ```
  [self willChangeValueForKey:@"xxx"];
  [super setValue:@"x" forKey:@"xxx"];
  [self didChangeValueForKey:@"xxx"];
  ```

  然后didChangeValueForKey方法里会触发监听器：欧抱抱serverValueForKeyPath：ofObject: change:context:]；

* 如何手动触发kvo

  直接手动调用willChangeValueForKey：和didChangeValueForKey：方法。

* kvo在运行时的isa指针指向什么？打印class方法结果是什么？(之前面试的时候被问过，在NSKVONotifying_xxx子类的set方法里打印[self class]打印出来的结果是什么)
  ```
  NSPerson * p = [NSPerson new];
  [self.p addObserver:self forKeyPath:@"age" options:NSKeyValueObservingOptionNew |NSKeyValueObservingOptionOld context:nil];
  //这里完全就是真实运行环境的实际情况：
  NSLog(@"类对象 - %@",object_getClass(self.p)); 
  //结果是NSKVONotifying_Person。object_getClass函数打印的是真实isa指针所执行的类，这里打印结果是动态子类，说明self.p.isa指针所指向的类确实是子类本身。
  NSLog(@"类对象 - %@",[self.p class]); 
  //结果是Person。class方法是通过调用NSObject的方法打印的结果。这里之所以打印的是Person，而不是动态的子类NSKVONotifying_Person。是因为子类里重写了class方法，目的是为了屏蔽动态化实现，隐藏动态子类的存在。
  ```

* KVO的子类重写了什么方法。
  set方法、**class方法**、dealloc方法、isKVOA方法。使用以下代码可以证明

  ```
  // KVO底层实现
  - (void)kvoTest {
  	self.p1 = [Person new];
  	self.p1.age = 1;
  	self.p2 = [Person new];
  	self.p2.age = 2;
  	[self.p1 addObserver:self forKeyPath:@"age" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];
  	// 上一题的答案
  	//NSLog(@"真实类：%@,%@", object_getClass(self.p1), object_getClass(self.p2));
  	//NSLog(@"表面类：%@,%@", [self.p1 class], [self.p2 class]);
  	//这道题验证
  	[self printMethodNameOfClass:object_getClass(self.p1)];
  	[self printMethodNameOfClass:object_getClass(self.p2)];
  }
  //打印一个类对象的所有方法
  - (void) printMethodNameOfClass: (Class) cls {
  	unsigned int count;
  	Method *methLists = class_copyMethodList(cls, &count);
  	//保存所有方法
  	NSMutableString * methodNames = [NSMutableString string];
  	for (int i = 0; i < count; i++) {
  		//获取方法名
  		NSString * methodName = NSStringFromSelector(method_getName(methLists[i]));
  		[methodNames appendFormat:@"%@ ,",methodName];
  	}
  	free(methLists);
  	NSLog(@"%@ %@",cls, methodNames);
  }
  ```

* 直接修改成员变量会触发KVO吗？

  不会，KVO的本质就是触发了setter方法。直接修改成员变量则只需要执行：

  ```
  self.p2->_age = 3; //这样就是直接修改变量，不会触发setter方法。得需要使用手动触发才能实现KVO。
  ```

### KVC 

* 通过KVC修改属性会触发KVO吗？

  可以触发。下述setValue的每一个方式都会触发KVO

* KVC的赋值和取值过程是怎样的？原理是什么？

  **赋值**：setValue:forKey:的过程：

  先查找是否存在方法setKey: 有则直接使用；

  没有，则再查找是否存在方法 _setKey: 有则直接使用；

  没有，则判断accessInstanceVariablesDirectly是否为YES，表示是否允许直接访问成员变量；

  值为YES，则判断是否存在成员变量_key，有则直接赋值；

  没有，则判断是否存在成员变量_isKey，有则直接赋值；

  没有，则判断是否存在成员变量key，有则直接赋值；

  没有，则判断是否存在成员变量isKey，有则直接赋值；

  没有，则崩溃。

  **取值**：valueForKey:的过程：