---
title: 计算机网络相关
date: 2018-08-08 23:18:03
tags: network learing
categories: iOS进阶
description: 学习Http协议、TCP/UDP 、HTTPS、DNS、Session/Cookies。
---

#### HTTP
http其实就是超文本传输协议，它主要包括请求报文和响应报文两部分组成。请求报文包括：方法(get、post)、url、http版本、首部字段(媒体类型、Encode编码格式、认证信息等)、实体主题；响应报文包括：http版本、状态码、首部字段(accept_range字节范围、时间、重定向URI)、实体主题。

**http的特点**：无连接（也就是每次请求连接都需要经历连接和断开的过程）、无状态（同一个用户在多次发送http请求时，server端并不知道是同一个用户发送的）

**状态码**：2xx、3xx、4xx、5xx，200请求成功，301、302一般是重定向问题、404一般是网络问题、504一般是指服务器问题。

**Get和Post的区别**：Get请求的参数通过？拼接在URL后面，post则放在Body里面。然后Get是安全的、幂等的、可缓存的，Post是非安全的、非幂等的、非可缓存的。安全性是指是否会引起server端的变化，幂等是指一种请求方法执行多次的结果是否完全相同，可缓存的是指代理服务器是否会进行缓存。

**持久连接**：应对http无连接特点。指在一定时间范围内不需要反复进行握手和挥手动作。http提供的持久连接的方案就是修改请求头部字段，比如connection: keep-alive(客户端期许采用持久连接)、time:20(持久连接时间)、max：10(这条连接最多可以发生多少次请求和响应对)。
那怎么判断持久连接中的一次连接已结束呢？1)通过响应头部字段：content-length:1024来判断。2)还有就是最后一个报文的chunked字段是否为空来判断。

**Charles的抓包原理**：利用了http中间人攻击漏洞进行抓包，中间人就是模仿客户端和server端的所有操作。

**HTTPS**：HTTPS = HTTP + SSL/TLS。
HTTPS连接的建立流程：客户端先向server发送一个SSL版本及支持的加密算法和随机数C，server会返回一个选定的加密算法、随机数S、server端证书。客户端接收到后会先验证server证书（也就是server端公钥），然后通过C、S、预组秘钥组装成会话秘钥，之后通过server端公钥对预组秘钥进行加密发送给server端，server端则通过私钥解密预组秘钥，然后通过C、S、预组秘钥组装会话秘钥。然后客户端和server端相互发送一个加密消息，验证安全通道是否建立完成。
HTTPS都使用了哪些加密手段？
对称加密和非对称加密。非对称加密在公私钥中使用到，传输过程中则是使用对称加密。
什么是非对称加密和对称加密？
非对称加密包含两个概念：公钥、私钥。加解密使用的钥匙不一样的。用公钥加密，就得用私钥解密；私钥加密就得用公钥解密。
对称加密：加解密用的是同一个秘钥。

#### TCP/UDP
**TCP三次握手**：客服端向server端发送一个请求报文，server端接收到请求报文后会发送一个确认响应报文同时也附带一个建立连接的请求报文，客户端收到server端发来的请求报文后再会给server端一个确认报文。

**TCP四次挥手**：客户端想server端发送一个请求断开连接的报文，server端收到后会返回一个确认报文（这样客户端对server的连接就断开了），然后server端向客户端发送一个断开连接的请求报文，客户端收到后回复一个确认报文（这样server端对客户端的连接也断开了）

##### UDP：用户数据报协议。
UDP特点：无连接、尽最大努力交付（不保证可靠传输）、面向报文(既不合并报文也不拆分报文，会原封不动传输报文，只是在运输层会拼装一个UDP首部)；
UDP提供的功能：复用(就是不同的端口都可以复用传输层UDP数据报)、分用(接收到数据报后，会根据目的端口进行分发)、差错检测(就是发送方通过某种方法计算出某个数据，将其插入到UDP首部传输给接收方，然后接收方接收到数据后，运用相同的方式进行计算，然后对比接收到的数据，进行差错检测。)

##### TCP：传输控制协议。则需要建立连接。

TCP特点：面向连接（数据传输开始和结束需要建立和释放连接）、可靠传输（无差错、无重复、按序到达）、面向字节流、流量控制、拥塞控制。

Q1:为什么是3次握手，而不是两次？

假如客户端发送建立连接的请求报文发生了超时，客户端会启用超时重传策略，重新发送连接请求，Server端收到了会回复确认报文，那之后又收到了之前超时的请求连接，那就又会建立一次连接，这样就可能建立了两次连接。而多了那次客户端确认报文则可以解决这种问题。

Q2、为什么是4次挥手，要分别断开两个方向的链接？

因为TCP建立的是一个全双通的链接，就是无论从客户端到server端，还是server端到客户端，都可以建立单独的发送与确认接收的通道，比如说在4次握手中，如果仅仅是进行了前两步（断开了客户端到server端的链接），那么此时客户端是不能向server端发送数据的，但是server端依旧可以向客户端发送数据。

Q3 、怎么保证可靠传输的？

可靠传输是通过停止等待协议来实现的。它是包括4方面的：

无差错情况：就是每次报文的传输中，server端收到后都会返回一个确认报文。

超时重传：那如果超时了，也就意味着在这个时间范围内，server端没有收到报文，也自然没有返回确认报文，那客户端就会进行重新发送。

确认丢失：是指server端返回的确认报文丢失了，那么同样的，客户端没有在时间限定内收到确认，所以会进行重新发送。server端会将第一次接到的报文丢失掉。

确认迟到：指确认报文迟到了，客户端同样会进行确认丢失一样的操作。

Q4、面向字节流?

是指TCP并不是原封不动地将发送方发送的字节一次性地完全地传输给接收方，而是会根据实际情况对字节流进行拆分或合并，然后再进行发送。和UDP的面向报文的方式正好相反。

Q5、怎么做到流量控制、按序到底？

通过滑动窗口协议实现。TCP的发送缓存当中的数据都有字节编号，然后我们进行排序。将每次发送出去后收到的确认报文位置进行标记，将将要发送的字节流中的最后字节进行标记。然后这大概就是字节流中的一个小的字节窗口。但是为了避免接收方数据溢出，所以接收方需要动态调节发送方的窗口大小来控制发送速率（比如接收方只能接收2个字节了，那么发送方就最多只能发送2个字节。这个应该是放在报文的首部字段）。同样的，接收缓存中也会对已接收的字节进行排序，它会对按序到底的下一个期望到达的字节进行标记（比如已经接收了1、2、3字节，那么期望标记就是第4个字节，而返回给长层应用程序的字节就是这些已按序到底的字节部分，那比如说还接收到了第6个字节，则暂时不会进行处理。）。所以呢，这个滑动窗口协议就可以进行流量控制和按序到达了。

Q6、拥塞控制：

慢开始、拥塞避免：一开始先发送一个报文，如果没有发送拥塞，则翻倍发送2个，然后再4个、16个(指数增长的方式)。一直达到窗口的门限初始值为止；然后再通过拥塞避免的策略，以线性增长的方式发送报文，可能达到某个值得时候，就产生了网络拥塞（比如连续3个报文没有收到确认报文），此时就越高采用拥塞避免的乘法减小的策略，只发送一个报文，同时将门限值降低，然后重新开始“慢开始”。

快恢复、快重传：是指在达到拥塞时，回到新的门限值，以线性增长的方式发送报文，而不经过前面指数增长的慢开始阶段。



#### DNS解析
DNS解析过程？
DNS服务器是提供域名到IP之间的解析服务，一般计算机就是一个IP地址，但是纯数字不符合人类的记忆习惯，所以一般会有一个域名，比如www.baidu.com ，当我们代码对某个域名发起访问的时候，则要通过DNS解析，找到对应的IP，然后再进行访问 。一般DNS解析都是有运营商进行管理，比如移动的卡发出来的访问，先经过移动运营商，然后移动运营商找到对应的ip，然后进行访问。
DNS采用UDP数据报文，53端口号，且明文。

DNS解析查询方式：
1、递归查询：按照 本地DNS——根域DNS——顶级DNS——权限DNS的层级一层层递归查找；
2、迭代查找：先查询本地DNS，然后本地DNS依次询问根域DNS、顶级DNS、权限DNS；
DNS劫持问题？
因为DNS是UDP明文传输，就有可能被钓鱼DNS劫持，返回错误的IP地址。
DNS劫持与解析都与http无关，它是发生在http之前的操作。
解决DNS劫持：
1、httpDNS：实际上DNS解析是指DNS协议向DNS服务器的53端口进行请求，采用HTTPDNS这种方式则是直接通过http协议向DNS服务器的80端口进行请求，这样实际上就不存在DNS解析了，所以也就不存在DNS解析问题了。比如：http://119.29.29.29/d?dn=www.baidu.com&ip=163.177.153.109 (其中http://119.29.29.29/d 是国内最大的DNS域名服务器，dn=www.baidu.com 是需要解析的域名，后面是本地IP地址)
2、长连接：
客户端采用 长连server 从API Server通过内网专线获取IP的方式

DNS解析转发问题？
是指DNS解析服务器为了节省资源，将解析请求发送给其他DNS域名服务器，依次转发，最后返回的IP地址可能不是同一运营商的网络，存在跨网访问的可能，造成一些请求缓慢等效率问题。


##### Session/Cookie
应对http无状态特点，指多次发送同一个请求，server端无法知道是否是同一个用户。
Cookie主要是用来记录用户状态，区分用户；状态主要保存在客户端；
Session也是主要用来记录用户状态，区分用户；状态主要存放在server端。


