#### 主要问题
* 说一下哪个项目的技术点比较难。
* 在项目里都做了哪些卡顿的优化？（理论被断掉了，直接说自己做了哪些处理？）
* 卡顿是怎么做的检测？为什么还要自己写检测工具？那检测的过程中是怎么定位到具体的方法的？
* 主线程的卡顿是怎么检测到的？为什么要单独写一个CADisplayLink检测主线程上的帧率，如果是主线程已经卡顿的情况下岂不是会加重卡顿？
* 为什么要使用RunLoop做卡顿优化？一开始加载数据的时候岂不是没法使用？（简历里的坑）
* 在项目里是如何检测Crash的，降低崩溃率都做了哪些事情？
* Bugly的检测原理是什么？
* 是否了解直播的一些底层原理？还是说只停留在SDK的使用过程？

1、可能是因为一开始紧张，有点语无伦次，所以理论被直接断掉了。然后说实践的时候，自己都觉得这些点很微不足道，没有底气。
2、面试官估计能力很强，他一直就觉得我使用的是系统API之类的，都应该是基础的东西。没什么难的。而且做的一些实践应该是必须要做的。(总之，被鄙视了)

不过最主要的是自己对知识点里的细节没有把握清楚。主要就是CADisplayLink检测主线程、runloop为什么用来优化tableview，是怎么做的。木有说清楚。

#### 回答
1、原则：所有这些抽象类的问题，都应该尽可能引导到自己熟悉的知识点上。其次切忌模棱两可回答一些不必要的东西。

比如说：最难的项目应该是我最新的那个项目吧，因为在那个项目上，我做了很多列表流畅度优化、卡顿检测、崩溃检测等相关的尝试。

2、原则：永远优先直接回答问题，如果是自己比较熟悉的知识点，可以在回答的过程中，稍微带过。其次再看提问者会不会追问一些更深入的东西。

**预排版**：一般就是将**布局计算、文本计算放到后台线程中先异步生成**。比如： 刚获取到JSON数据时，将Cell中要显示的控件的布局数据都在后台线程中计算并封装在一个FeedLayout里。FeedLayout可以包含的内容包括：**cell中每个控件控件CGRect、整体Cell的高度、CoreText的排版结果**等。这样cell里的所有布局就都提前计算好了。但是这个方式需要考虑如果第一页数据非常多的话，可能会导致预排版的时间过长，所以可以结合滑动减速或RunLoop等一起使用。
```
//预排版类
@interface FCFFeedLayout : NSObject
@property (nonatomic, strong) FCFFeed *feed; //对应cell Model
//其他数据全是对应的CGRect
@property (nonatomic, assign) CGRect iconRect;
@property (nonatomic, assign) CGRect nameRect;
@property (nonatomic, assign) CGRect sexRect;
@property (nonatomic, assign) CGRect contentRect;
... ...
@property (nonatomic, assign) CGRect seperatorViewRect;
//cell整体高度
@property (nonatomic, assign) CGFloat height;
@end
```
**预渲染**：这里主要是指图片的解码。预渲染也是可以将将要显示的内容提前在后台线程中生成好，然后使用的时候直接赋值就好了。
	* 文本渲染：主要就是讲CoreText排版绘制成Bitmap。
	* 图片解码：
	* 同样是在TableView加载之前，就在后台线程将图片这种资源先渲染出来，尤其是要处理圆角等容易导致离屏渲染的属性，同时缓存到内存中，基本的实现步骤就类似SDWebImage了。另外，在预渲染的过程中，可以将容易导致离屏渲染的属性，尽量使用Core Graphics的API代替。预渲染和异步解码类似，只是时机不一样而已。

**异步绘制**：预渲染是在一开始数据回来的时候做的处理。而在列表滑动过程中，对于文本和图像的绘制，则可以使用异步绘制来进行。异步绘制的实现原理就是实现CALayer的displayer方法，然后在函数里，把文本绘制或图片绘制的操作放到后台线程中进行，最后将结果返回主线程显示。
文本渲染：所有的文本底层都是使用CoreText排版，然后绘制为Bitmap显示的。所以文本绘制就是使用CoreText或者TextKit的API创建文本。使用了CoreText的文本也就无需再计算了。
图片异步绘制：图像绘制就是使用所有
```
- (void)display{
	dispatch_async(backgroundQueue, ^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue, ^{
            layer.contents = img;
        });
	});   
}
```

**异步解码与绘制**：当使用UIImage或CGImageSource创建图片时，图片数据并不会立即解码设置到UIImageView或layer.contents中，只有Layer提交到GPU前，CGImage的数据才会在主线程中得到解码。如果想绕开这个过程，最常见的做法就是将图片绘制到CGBitmapContext中，然后从Bitmap创建图片。目前无论是SDWebImage还是YYKit，都实现了异步解码的过程。




这一套东西下来，基本能够保证一个复杂的列表达到接近50~60帧的效果了。

其次，除了列表的这些步骤，我们平时写代码的过程中，也需要注意一下其他的操作（主要是从CPU和GPU的角度）：
* 对象创建：对象创建会分配内存、调整属性、甚至读取文件，比较消耗CPU。策略就是**尽量用轻量级的对象创建**，比如CALayer代替无需操作的UIView。又比如说YYKit，单张图片时，直接给CALayer添加了一个setImageWithURL的方法，将图片直接赋值给layer.contents。其次就是**尽量推迟创建对象的时间**，比如使用懒加载。而对于可以复用的对象，**尽可能放到缓存池复用**，比如Cell。
* 对象调整：主要是CALayer的一些属性的调整，比如frame、bounds等，它实际上是通过运行时resolveInstanceMethod为对象临时添加一个方法，然后将对应属性保存到Dictionary里，同时通知Delegate、创建动画。 其次改变CALayer的一些**可动画属性值**时，会对模型层数据做动画，最后显示在展示层上，也多了一份数据的拷贝。所以对象(尤其是视图里的对象)的调整应尽量避免，尤其是视图层次，以及频繁地添加和移除视图。
* 布局计算和渲染：可以使用**预排版**的方式处理布局和排版。其次尽量少调整，对于复杂的视图来说，尽可能不使用Autolayout和storyboard。
* 





































#### 其他看到的关系卡顿和Crash相关的面试问题
* 用户报卡顿，有哪些情况，该如何定位问题？
* 卡顿检测有哪些方案？如果要监控每个函数的耗时如何实现？页面停留时间的检测该如何实现？
* 页面直接卡死，导致无法获取FPS，怎么解决这个问题？
* 为什么有时候FPS很高，但还是感觉卡顿？
* 获取FPS后，怎么定位到具体函数？
* 怎么做图片、数组、字符串的无差别存储，key怎么确定，怎么删除数据。如何保证取出的数据顺序？
* 常见的Crash有哪些？如何对这些Crash堆栈进行收集？如何捕获Crash？
* 捕获的堆栈如何进行符号还原呢？UUID是什么？怎么获取？
* dysm文件是什么，有什么作用？
* 如果你的项目中既有Bugly的Crash监控系统，又有自己的监控系统，可能存在什么问题？怎么解决？
* 针对无堆栈的Crash，比如out of memory有什么定位思路？
* 常见的野指针问题有哪些？
* dyld是什么？动态链接和静态链接的区别？dyld是什么时候执行的？dyld如何把对应dylib中函数实现链接到另一个库中的？
* 


质量保障体系相关体系：
* 内存泄漏检测
* 内存大图检测
* 图片主线程解压缩检测
* 卡顿检测
* 帧率检测
* 网络性能检测
* Crash检测
* Abort检测(jetsam杀死进程、watchdog杀死进程、后台崩溃)
* 内存消耗检测
* DNS解析检测
* 启动时间检测


想要处理列表等流程度，是肯定摆脱不了YYKit和AsyncDisplayKit这两个库的
[iOS保持界面流程的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)
[AsyncDisplayKit详解](https://zhuanlan.zhihu.com/p/25371361)
[FPS及具体定位](https://www.jianshu.com/p/03d51ced4bca)
//
[了解和分享Crash Report](https://juejin.im/post/5c5edb37e51d457f926d2290)
[iOS Crash日志堆栈解析](https://juejin.im/post/5adf15f2518825671775f3e1)