---
title: iOS-技能知识小集
date: 2020-11-29 21:06:00
tags: 耗电、优化、启动
categories: iOS进阶
description: 主要整理耗电与启动优化的理论知识和代码实践
---

###  耗电优化

#### 耗电的主要来源

* CPU工作；
* 网络请求
* 定位
* 图像（渲染）

#### 优化

* 尽可能降低CPU、GPU功耗；
* 少用定时器
* 优化IO操作（文件读写操作）
  * 尽量不要频繁写入小数据，最好批量一次性写入
  * 读写大量重要数据时，考虑使用dispatch_io,其提供了基于GCD的异步操作文件IO的API，用dispatch_io,系统会优化磁盘访问。
  * 数据量比较大时，建议使用数据库(比如SQLite、CoreData)

* 网络优化
	* 减少或压缩网络数据。(比如使用protocol buffer)
	* 如果多次请求的结果相同，尽量使用缓存
	* 使用断点续传，否则网络不稳定时可能多次传输相同的内容
	* 网络不可用时，不要尝试执行网络请求
	* 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 
	* 批量传输，比如，下载视频时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。

* 定位优化
	* 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电。
	* 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务。
	* 尽量降低定位精度，比如尽量不要使用精度最高的KCLLocationAccuracyBest。
	* 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新。



### 启动优化

- 冷启动是指APP不在后台，第一次打开
- 热启动是指APP在后台被唤起。

#### 冷启动过程

APP启动主要分为三个阶段：dyld阶段、runtime阶段、main函数首屏渲染完成：
* dyld：
	dyld是Apple的动态链接器，可以用来装载Mach-O文件(可执行文件、动态库)
	dyld做的事情主要包括：
	* 装载APP的可执行文件，同时会递归加载所有依赖的动态库；
	* 当dyld把可执行文件、动态库都装载完毕后，会通知runtime进行下一步处理。
* runtime：
	runtime做的事情依次为：
	* 调用map_images进行可执行文件内容的解析和处理。
	* 在load_images中调用call_load_methods,调用所有class和Category的+load方法；
	* 进行objc结构的初始化(注册objc类、初始化类对象等等)；
	* 调用C++静态初始化器和_attribute_((constructor))修饰的函数；
	
到这一步，可执行文件和动态库中所有的符号(Class、Protocol、Selector、IMP ...)都已经按格式成功加载到内存中，被runtime所管理。之后就是main函数之后的事情了。
* main函数:
	调用UIApplicationMain函数，开始首屏渲染等操作；

总结一下：
* APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库；
* 并由runtime负责加载成objc定义的结构；
* 所有初始化工作结束后，dyld就会调用main函数’；
* 接下来就是UIApplicationMain函数...

#### 启动耗时检测：

对于**main函数**之前的启动耗时日志，具体方法是在xcode中添加DYLD_PRINT_STATISTICS环境变量，并将其设置为1，这样就可以得到以下启动日志：

```
Total pre-main time: 1.3 seconds(100.0%)
	dylib loading time: 107.45 milliseconds (8.0%) //动态库加载
	rebase/binding time: 376.56 milliseconds (28.2%) //
	ObjC setup time: 166.96 milliseconds (12.5%) //objc 对象准备
	initializer time: 684.01 milliseconds (51.2%)
	slowest initalizers:
		libSystem.dylib: 297.56 milliseconds (22.2%)
		libMainThreadCheck.dylib: 33.00 milliseconds (2.4%)
		libLLVMContainer.dylib: 113.09 milliseconds (8.4%)
		ModelIO: 189.45 milliseconds (14.1%)
```
如果想要知道更加详细，可以把DYLD_PRINT_STATISTICS改成：DYLD_PRINT_STATISTICS_DETAILS 。


#### 启动优化
按照不同阶段：
* dyld：
	* 减少动态库，合并一些动态库（定期清理不必要的动态库）；
	* 减少Objc类、分类的数量，减少Selector数量(定期清理不必要的类和分类)
	* 减少C++虚函数数量
	* Swift尽量使用struct
* runtime
	* 用+initialize方法和Dispatch_once取代所有的_attrubute_((constructor)) 、C++静态构造器、Objc的+load方法。

* main
	* 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部放在finishLaunching方法中。
	* 按需加载。不要将各种无必要的类的初始化、配置文件的读写、首屏列表的数据获取和渲染相关等放到这个区间里面。比如说首页列表，通常会直接在viewdidload里做，这样是不好的

### 安装包瘦身
#### 安装包组成
安装包由可执行文件、资源组成
#### 优化
* 资源(图片、音频、视频)
	* 采用无损压缩
	* 去除没有用到的资源 (可使用开源项目LSUnusedResources)
* 可执行文件瘦身
	* 编译器优化：
		* Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES。(最新xcode已经都设置成了YES) 
		* 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO，Other C Flags添加-fno-exceptions   
	* 利用AppCode软件(第三方项目)检测未使用的代码：菜单栏——Code——Inspect Code. 
	* 其次也可以通过编写LLVM插件检测重复代码、未被使用的代码
	* 生成LinkMap文件，可以查看可执行文件的具体组成。