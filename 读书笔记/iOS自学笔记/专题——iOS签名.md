---
title: iOS-技能知识小集
date: 2020-10-23 7:36:48
tags: knoeledgePoints
categories: iOS进阶
description:  总结了iOS证书签名相关的知识点
---

### 加密解密
#### 对称加密 
对称加密算法中，加密和解密用的是同一套密钥。
* DES
	DES是一种将64位明文加密成64位密文的对称加密算法，密钥长度是56位。
	由于DES每次只能加密64位的数据，遇到比较大的数据，需要DES加密进行迭代。
	目前已经可以在短时间内被破解，所以不建议使用。
* 3DES
	3DES就是将DES重复3次所得到的一种加密算法。过程就是通过3个密钥加解密，3个密钥都是不同的，加密过程：明文——加密——解密——加密——密文；解密过程：密文——解密——加密——解密——明文。
	3DES的处理速度不是很高，安全性也不是很高。
* **AES**
	AES是取代DES、3DES的首选对称加密算法。目前无法被破解。目前对称加密算法最主要就是使用AES。

##### 对称加密的密钥配送问题
对称加密，如果密钥好密文都被同一个人窃取，那么就可以被破解。
解决方案
* 事先共享密钥
* 密钥分配中心
	发送方将密钥发送给分配中心，接收方再从分配中心获取密钥
* Diffie-Hellman密钥交换
	OpenSSH中使用到了这个技术

#### 非对称加密
非对称加密中，加密和解密使用的是两种密钥。 
* 加密密钥，一般是公开的，所以也称**公钥**。 
* 解密密钥，由接收方保管，不能公开，称为**私钥**。
* 公钥和私钥是一一对应的，不能单独生成，称为密钥对。
##### 解决密钥配送问题
* 由消息接收者，生成一对密钥 (公钥+私钥)

* 将公钥发送给消息发送方

* 发送方使用公钥加密

* 接收方使用私钥解密

##### RSA
**RSA**是目前使用最广泛的非对称加密算法。

#### 混合密码系统
  * 不能很好地解决密钥配送问题
* 非对称加密的缺点
  * 加解密速度比较慢 

混合加密系统，是将对称加密和非对称加密优势相结合的方法。
* 利用了对称加密解决了加解密速度慢的问题
* 利用了非对称加密解决了密钥配送问题

HTTPS中所采用的SSL、TLS都是运用了混合加密系统。
混合加密过程：
Alice >>>>>>> Bob
1、Bob先生成一对公钥、私钥；
2、Bob把公钥共享给Alice；
3、Alice随机生成一个随机会话密钥；(临时密钥)；
4、Alice用随机会话密钥加密需要发送的消息; (对称加密)；
5、Alice使用Bob的公钥加密会话密钥。(非对称加密)；
6、Alice把4、5步的加密结果，一起发送给Bob；

解密过程：
1、Bob利用自己的私有密钥解密。(公钥加密，私钥解密)
2、Bob利用会话密钥解密发送。(对称加密)

### 单向散列函数
单向散列函数，可以根据消息内容计算出散列值。散列值的长度和消息的长度无关，无论消息是1bt、10M、100G，单向散列函数都会计算出固定长度的散列值。
单向散列函数，也被称为**消息摘要函数，哈希函数**。
输出的散列值，也叫消息摘要、指纹。
eg:
```
用户口令 8bt ———— (单向散列函数 SHA-1 ) ———— 散列值20字节
图像数值 512bt ———— (单向散列函数 SHA-1 ) ———— 散列值20字节
存储文件 4GB ———— (单向散列函数 SHA-1 ) ———— 散列值20字节
硬盘文件 80GB ———— (单向散列函数 SHA-1 ) ———— 散列值20字节
```
特点：
* 根据任意长度的消息，计算固定长度的散列值
* 计算速度快，能快速计算出散列值
* 消息不同，散列值也不同
* 单向性，指计算出散列值后，无法推敲出原来的值

常见的单向散列函数
* MD5
	产生128bit的散列值，目前已经不安全。
* SHA-1
	产生160bit的散列值，目前已经不安全。
* SHA-2
	这个是一个标准，它下面有SSHA-256、SHA-384、SHA-512。分别生成256bit、384bit、512bit的散列值，目前是比较安全的。

#### 应用
* 防止数据被篡改
	假设一份很重要的文件存储在电脑中，如果不加密，那么如果文件系统被黑客黑了，那文件内容就有可能被串改，而如果使用单向散列函数，每次查看的时候对比一下散列值，就可以知道文件是否有被篡改过。
* 口令密码的加密。
	比如密码，一般用单向散列函数做一下摘要，避免明文传输和明文存储。假如被中间人攻击了，或者数据库被攻破了，那账号密码就不容易被泄漏了。所以忘记了密码通常也无法找回，只能重新设置。

### 数字签名
上文中的数据被篡改，是指原来有一份原始数据的情况下，再次查看数据时，经过前后对比散列值来判断数据是否被篡改。那如果始终没有接触过最原始的数据，怎么避免数据被篡改？
假设一个消息，被中间人攻击了，内容被篡改后再发送过来。那么接收数据的人如何判断消息被篡改了呢？

数字签名就是可以解决消息真实性的问题。

数字签名步骤
* 生成签名：
	由消息发送者完成，通过**签名密钥**生成
	* 如何保证这个签名是消息发送者自己签的？
		用消息发送者的私钥进行签名
* 验证签名：
	* 由消息接收者完成，通过**验证密钥**验证

在非对称加密过程中，所有发送者**获取**到 接收消息者 发出来的公钥，然后发送者再通过公钥加密好消息，发送给接收者，接收方用私钥进行解密读取消息。

数字签名消息的发送分为数字签名消息和非签名消息。
数字签名中，消息发送者会事先发送一个公钥给消息接收者。然后发送者先使用自己手里的私钥对消息进行加密，然后将加密后的内容发送给接收者。接收方收到签名后，先用手里的公钥对签名进行解密，最终得到消息。
另外，因为担心消息的真实性，则需要另外发送一个未经签名的消息。最后通过签名消息解密之后的消息与非签名消息进行比较，来最终确定数据的真实性。

但是上诉步骤，也有个确定就是发送的数据过大了。所以数字签名消息可以使用单例散列函数处理一下再进行数字签名，最后验证的时候，也对未经签名的消息做一下单向散列，然后对比前后的值来判断消息的真实性。

总结：
* 非对称加密中，公私钥是消息接收者生成的。数字签名中，公私钥是消息发送者生成的。
* 数字签名的作用不是为了保证消息机密性。而是为了设别元素消息是否有被篡改，而不是确保消息的机密性。 

#### 数字签名无法解决的问题
* 中间人攻击
	拦截双方的消息与签名。也就是说签名和未加密的消息都会被拦截，这样子的话，数字签名也无法解决问题。

### 证书
所有的证书（驾驶证、身份证、公钥证书）都有一个统一的性质，那就是由权威机构认证颁发的。
这里的证书是指公钥证书。它里面有姓名、邮箱等个人信息，以及公钥。并由CA施加数字签名(这个数字签名，先将个人信息做单向散列，然后CA使用私钥对散列值进行加密，生成数字签名)。


### 签名机制
