---
title: iOS-技能知识小集
date: 2020-5-9 17:36:48
tags: 缓存
categories: iOS进阶
description: 文章主要是主要是根据YYCache的源码来对缓存架构进行学习和整理
---
### 认识缓存
#### 什么是缓存
缓存就是本地数据存储。存储的方式主要包含两种：内存存储和磁盘存储。
##### 磁盘存储
磁盘存储就是硬盘存储，是磁盘的存储空间。磁盘存储的特点是：**容量大、速度慢、永久存储**。
iOS中，每个应用程序都拥有一个沙盒目录。沙盒根目录包括：Document、Library、temp：
* Document : 一般用于存储我们的缓存数据，比如音视频下载等，这个文件夹会在应用程序更新时自动备份，在链接iTunes也可以自动同步备份；
* Library：这个文件夹下有两个子目录：Caches和Preferences：
	* Cache：保存应用程序产生的支持文件和缓存文件，比如某些配置，再次启动需要的信息，日志也最后存放在这里；
	* Preferences：保存应用程序的偏好设置文件，NSUserDefault缓存的东西就是存在这里，可被iTunes备份；
* temp：缓存运行时产生的临时数据，iPhone重启时，会被自动清除；
##### 内存存储
内存存储就是指在当前程序运行空间进行存储。内存存储的特点就是：**容量小、速度快、不可持久**。
iOS中，内存分为5个区：栈区、堆区、全局区、常量区、代码区：
* 全局区：全局变量和静态变量都存储在这里，已初始化数据和未初始化数据会分开存储在相邻的区域；
#### 缓存使用场景
离线加载、本地通讯录等；
#### 怎么做缓存
最简单的缓存可以只使用磁盘缓存，iOS提供四种磁盘缓存方式：
* NSKeyedArchiver : 采用归档的形式来保存数据，该数据对象需要遵守NSCoding协议，实现encodeWithCoder：和initWithCoder：方法。**缺点：**归档只能一次性归档保存和一次性解压。所以只能针对小量数据，如果想改动数据的某一小部分，需要解压整个数据或者归档整个数据；
* NSUserDefaults：能存储的类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary；
* FileManager：写入磁盘的方式；
* SQLite：SQ语句写入数据库；
### 缓存的优化
YYCache通过YYMemoryCache和YYDiskCache两个来来分别实现内存缓存和磁盘缓存。
* YYMemoryCache通过采用双向链表的数据结构实现LRU(最近最久未使用)算法来实现内存优化；

* YYDiskCache

然后对容量管理采取了多种策略：

* ageLimit：时间周期限制，比如每天或每星期清理一次；

* costLimit：容量限制，比如超出10M后清理一次；

* countLimit：数量限制，比如超出1000个数据清理一次；

所以缓存优化就是使用**磁盘+内存**组合的方式进行优化：

* APP优先查找内存中的缓存资源；

* 如果内存缓存有，则返回，没有就查找磁盘；

* 磁盘中有资源，就先缓存到内存，方便以后快速获取，然后再返回使用；

#### 内存优化——提供内存命中率
LRU算法：将整个内存缓存看成一个链表，每个数据是整个链表的一个节点。经常访问的数据移动到头部，等数据超出容量后，从链表尾部销毁部分节点。这样经常访问的数据就留在头部，依旧保存在内存中。
#### 磁盘优化——数据分类存储
磁盘缓存可以根据缓存对象类型还选择是使用sqlite还是file缓存。
* sqlite：对于小数据（NSNumber）的存取效率，明显高于file；
* file：对于较大数据(高质量图片)的存取效率优于sqlite；
**通常，将数据进行磁盘写入，sqlite比file更快，但是读取性能取决于数据大小。当数据大小超过20KB时，从file文件读取数据比sqlite更快**，所以通常是使用这两种形式进行混合存储。
另外，磁盘缓存还使用以下功能进行优化：
* 使用LRU来删除对象；
* 支持按周期限制、容量限制、数量限制来控制存储；

### 其他
#### 线程安全
在YYCache中，YYMemoryCache使用pthread_mutex_t来加锁保证线程安全，YYDiskCache使用dispatch_semaphore信号量来保证线程安全。
其实按作者自己的话说，YYMemoryCache原本是使用自旋锁spinlock，但是自旋锁会存在**优先级反转**（低优先级获得锁并访问资源，此时高优先级也尝试获得这个锁，而低优先级线程无法与高优先级的线程争夺CPU时间，导致访问迟迟无法完成，也就无法释放这个锁）的问题。所以就使用互斥锁pthread_mutex来代替了自旋锁。而作者没有使用dispatch_semaphore是因为无法确定是否能够完全替代自旋锁。而使用互斥锁是绝对安全的。

### 缓存安全
[App缓存数据线程安全问题探讨](https://blog.cnbang.net/tech/3262/)
[iOS 数据持久化设计探讨](https://blog.csdn.net/andanlan/article/details/86514794)
[FMDB线程安全](https://juejin.im/post/6844903768975228942#heading-5)
[FMDB多线程解决方案](https://www.jianshu.com/p/3d66aa58ebe6)


