---
title: iOS-技能知识小集
date: 2020-5-9 17:36:48
tags: knoeledgePoints
categories: iOS进阶
description:  总结了OC学习当中的主要知识点。以底层进阶相关的理论知识点为主，以经常遇到的面试点为辅
---

### UI相关
#### 图像显示原理
iOS的所有视图控件都是继承自UIView。根据“单一职责”的设计原则，真正负责显示和动画操作的部分是CALayer。CALayer有一个id类型属性叫contents，它实际对应着一个CGImageRef（位图）。也就是说CALayer最终都是通过生成一张位图显示出来的。
* 每一帧画面的生成是由CPU和GPU合作完成的。
  CPU主要负责包括对象的创建、布局计算、文本计算与渲染、如果是图片的话，还会在提交给GPU之前进行图片的**解码**。最后将CPU生成的位图，通过Core Animation提交给GPU。GPU的部分就是OpenGL渲染管线相关的工作。主要就包括**顶点着色**、**图元装配**、**几何着色**、**光栅化**、**片段着色**、**片段处理**等，最后将生成的内容放到帧缓存区中。等到VSync信号到来之前，视图控制器就会去帧缓存区进行提取将要显示的内容。总的来说，Core Graphics渲染部分由CPU完成，OpenGL部分由GPU完成。
* iOS 是双缓冲机制
#### UI卡顿掉帧的原因
在VSync信号到来后。视图控制器就会去帧缓存区提取显示内容。那如果一个VSync信号周期内，CPU和GPU没能协作完成提交，那么那一帧就会被丢弃，此时屏幕就不会刷新，仍然显示之前的内容。这样就造成了卡顿。
* 按照苹果60FPS的刷帧率，每隔16.7ms就会有一次VSync信号。
#### 卡顿优化
根据上面的图像显示原理，要保证不卡顿，则需要让CPU和GPU在16.7ms之内生成将要显示内容。所以卡顿优化就主要从CPU和GPU两个方向入手：

##### CPU优化
* 对象创建：对象创建会分配内存、调整属性、甚至读取文件，比较消耗CPU。策略就是**尽量用轻量级的对象创建**，比如CALayer代替无需操作的UIView。其次就是**尽量推迟创建对象的时间**，比如使用懒加载。而对于可以复用的对象，**尽可能放到缓存池复用**，比如Cell。
* 对象属性的调整：主要是CALayer的一些属性的调整，比如frame、bounds等，它实际上是通过运行时resolveInstanceMethod为Layer临时添加一个方法，然后将对应属性保存到Dictionary里，同时通知Delegate、创建动画。 其次改变CALayer的一些**可动画属性值**时，会对模型层数据做动画，最后显示在展示层上，也多了一份数据的拷贝。所以对象(尤其是视图里的对象)的属性调整应尽量避免，尤其是视图层次，以及频繁地添加和移除视图。尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性。
* 布局计算和渲染：尽可能使用**预排版**的方式处理布局和排版。其次尽量少调整，对于复杂的视图来说，尽可能不使用Autolayout和storyboard。Autolayout会比直接设置frame消耗更多的CPU资源。
* 控制线程的最大并发数。尽量把耗时的操作放到子线程中执行（比如文本尺寸计算和绘制，图片的解码和绘制）；
* 列表多使用**预排版**、**预渲染**、**异步绘制**、**按需加载**、**延时加载**等技术；
* 图片的size最好刚好跟UIImageView的size保持一致。另外图片的编解码优化(比如：**SDWebImage编解码优化**)；
##### GPU优化
* 尽量避免出现**离屏渲染**；
* 视图混合：应该尽量减少视图数量与层次。不透明的视图表明opaque属性，避免无用的Alpha通道合成。
* 纹理的渲染：实际就是指图片的渲染。iOS中几乎所有的UI视图最终都是绘制成Bitmap，包括文本、图片、栅格化的内容。所以可以尽量减少短时间内大量图片的显示，尽可能将多张图片合成到一张图片中。其次对于过大的图片，比如超过GPU的最大纹理尺寸（4096*4096）,则需要CPU先预处理。所以尽量不要让图片大小超过这个值。
  [iOS性能优化](https://juejin.im/post/5b7a9c466fb9a019eb43b0d5)

#### 关键名词解析
* **合成**：是指一帧画面是由多张位图组成的，所以将多张位图组合成一帧画面的过程就是合成。比如位图的重叠部分的像素怎么处理等等！

* **解码**：解码主要是因为每一种图片都有不同的格式，要使图片能够显示在屏幕上，就得将不同格式的图片转码成图片的原始像素数据。这样才能进行绘制。

* **顶点着色**：是指把3D坐标转化为2D坐标；

* **图元装配**：根据顶点着色器的输入，将所有坐标装配成点、线、三角形这些基础的图元；

* **几何着色器**：根据图元数据生成几何形状；

* **光栅化**：就是把图元最终映射成屏幕上的像素，生成片段。片段是指一个像素渲染所需要的所有数据。

* **片段着色**：就将光栅化的结果先进行裁剪，去掉超出视图以外的像素，然后进行着色；

* **片段处理**：检测片段的对应深度值和透明度，丢弃被挡住的部分。然后对图层进行混合。

* **SDWebImage编解码优化**：

  iOS默认会在UI主线程对图像进行解码。SDWebImageDecoder的优化思路就是将解码的耗时工作放到了子线程中进行，解码完成后就缓存到内存避免重复解码。

  解码的主要函数：[UIImage decodedImageWithImage:img];

* **离屏渲染**：

  https://zhuanlan.zhihu.com/p/72653360

  在OpenGL中有两种渲染方式：当前屏幕内渲染和离屏渲染(在当前屏幕缓存区以外开辟一个新的缓存区进行渲染)。离屏渲染消耗性能的原因包括：
  1.需要创建新的缓存区；
  2.在离屏渲染的过程中，需要多次在当前屏幕和新的缓存区之间进行环境切换。
  哪些操作会触发离屏渲染？(因为有的组合属性在没有合成之前是不能在当前屏幕缓存区中使用的)
  1.光栅化：layer.shouldRasterize = true;
  2.遮罩：layer.mask
  3.圆角和masksToBounds一起使用的时候
  4.阴影。
  所以当遇到这些容易触发离屏渲染的情况的时候，可以考虑使用CPU渲染，也就是直接调用Core Graphics的API绘制来替代。

* **处理时机与Core Animation的Observe回调**：

  Core Animation在RunLoop中注册了一个优先级比较低的Observer，这个Observe监听了RunLoop的BeforeWaiting或Exit状态。当处理了UI时，比如frame、layer的层次，或者手动调用了setNeedsDisplay等方法。对应的CALayer就会标记为待处理，并被提交到一个全局容器里。 当Observe监听到通知后，然后回调方法里就会将待处理的方法进行实际的绘制，最后将合成的位图交由Core Animation。因为GPU处理的单元是Texture(纹理)，所以Core Animation实际会先创建一个OpenGL的Texture，并将contents的CGImageRef和这个Texture进行绑定，通过TextureID来标识。之后GPU将Texture渲染到屏幕上。

* **UIView绘制流程**：
  当调用UIView的setNeedsDisplay方法时，会调用CALayer的同名方法setNeedsDisplay，但是这时并没有立即发送绘制，而只是给CALayer打上了脏标记，然后将其放到了一个全局容器里。当Core Animation监听到RunLoop的BeforeWaiting或Exit状态时，则会回调将容器里的CALayer执行display方法，然后这个方法的内部会判断是否实现了layer.delegate的displayLayer：方法。如果没有实现，则是正常走系统绘制方法，如果实现了，则执行displayLayer。

  * 系统绘制：系统绘制首先会创建一个后备缓存(backing store),然后调用CALayer的drawInContext方法，drawInContext方法内会判断是否实现了layer.delegate的drawLayer:inContext:方法，如果实现了，就执行drawLayer:inContext:，如果没有就执行默认的drawRect:方法。

  * 异步绘制：一般来说异步绘制就是在layer.delegate的两个方法displayLayer:或者drawLayer:inContext:方法里，在子线程进行绘制工作，然后回到主线程给layer的contens进行赋值。不过最好的选择是使用displayLayer:方法，因为它节省了创建backing store的开销。其实只要绘制工作不放在主线程，我们都可以把它叫做异步绘制，比如在子线程调用Core Graphics生成位图，最后回到主线程赋值。
  ```
  - (void)displayLayer{
  dispatch_async(backgroundQueue, ^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue, ^{
            layer.contents = img;
        });
  	});   
  }
  ```

  * drawRect绘制过程: iOS的绘图操作默认是在drawRect:方法中进行的，我们也可以重写drawRect方法进行执行绘制操作。drawRect方法和drawLayer:inContext:方法都直接有绘制上下文，可以直接通过UIGraphicsGetCurrentContext获取。但是displayLayer方法无法直接获取到上下文，需要自己创建：创建：CGBitmapContextCreate(...);最后使用CGBitmapContextCreateImage获取bitmap。然后给contents赋值。

  * CALayer的后备存储Backing Store : 当我们调用CALayer的drawInContext方法时，layer会自动创建一块以layer大小成正比的内存区域，这个区域就是后备存储（backing store）。所以也最好不要随意重写drawRect:等相关方法。

### OC基础特性
#### KVO
KVO是OC观察者模式的实践之一，使用了里式替换的设计原则。KVO的实现原理是通过Runtime的**isa混写**技术给当前对象A生成一个NSNotifying_A的子类，然后重写所要监听的属性的Setter方法，Setter方法里会调用willChangeValueForKey:和didChangeValueForKey:方法。然后就会在ObserveValueForKey里监听到变化。
```oc
- (void)setB:(id)obj
{
    [self willChangeValueForKey:@"B"];
    [super setB:obj]; //调用原类的实现
    [self didChangeValueForKey:@"B"];
}
```
注意：
* kvo触发的关键点在于重写了属性的Setter方法，然后写了willChangeValueForKey和didChangeValueForKey方法，所以**直接给成员变量 _ B赋值是不会触发KVO的**，但是直接手动调用这两个方法也是可以触发KVO的；
* kvo重写了父类的setter方法、class方法、dealloc方法、isKVOA方法；
* KVC的setValue:ForKey:也能触发KVO，这也是KVC和KVO直接的联系；

#### KVC
KVC——KeyValueCoding键值编码。是苹果给NSObject添加的一个分类，它可以无需直接访问存Setter、取getter方法就能对属性进行操作(**所以这违反了面向对象的"封装性"的特性**)。主要的方法是setValueForKey:和valueForKey: 及KeyPath的变种。

注意：
* valueForKey:的时候会先按照getKey:、key:、isKey:、 _ key:的顺序查找**方法**，然后判断accessInstanceVariablesDirectly，走后续流程；
* setValue:forKey：的时候先按照setKey:、 _ setKey:的顺序查找**方法**，然后判断accessInstanceVariablesDirectly，走后续流程；
* accessInstanceVariablesDirectly 设置为YES，则如果没有找到setKey，会按照 _ key， _ iskey，key，iskey的顺序搜索**成员变量**，设置成NO就不这样搜索。
* 如果传入的Value值为nil，则会调用setNilValueForKey方法；
* 如果key不存在且没有搜索到和key有关的字段和属性，则会调用valueForUndefinedKey函数。

  [KVC详解](https://juejin.im/entry/587d8b3e128fe1005701f969)

#### Category
category的最直接的作用就是给已有类添加方法。其次还可以拆分单个文件、便于多人同时开发一个类、声明私有方法等。

OC在初始化的时候，会去加载map_images，map_images最终会调用objc-runtime-new.mm里面的_ read_ images方法。_read_images方法里面会去初始化内存中的map, 这个时候将会load所有的类，协议还有Category。NSObject的+load方法就是这个时候调用的。

所以说category是在runtime时决议的（所以category不能为类添加成员变量，因为运行时的类的内存布局已经确定了）。category的结构体中包含名称、所属的类、实例方法列表、类方法列表、协议列表、属性列表。 属性的话，其实也只是实现了属性对应的getter、setter方法的**声明**，并没有具体的实现，具体实现需要自己去写。

其次分类的这些内容都是在runtime时编译进宿主类里的。

根据上述OC初始化过程可知，category是在运行时添加进类当中的，**在添加的过程中是使用头插法从头插入到方法列表中的**。如果一个类对应多个category，每个category对应着相同方法，则最后编译的category的方法应该是实际生效的（编译顺序是可以在xcode的Compile Source中看到的）。但是并不是所有的方法都会直接这样“覆盖”掉。如果每个类本身和category都实现了**+load**方法，则每个load方法都会执行,执行的顺序是先类后category。

* **+load VS +initialize**：
  * +load：在APP启动时，会在main函数之前加载所有的类，load函数就是在这个时候被调用的,**每个类和分类都有load方法，并且都会被调用一遍（即使这个类没有被使用到，load方法也会被调用）**。调用顺序是先调用类的load方法，再调用分类的load方法（这个顺序好理解，因为分类方法最终都是附加到宿主类方法的前面的，所以宿主类必须先于分类方法生成，否则分类方法添加到宿主类的时候就无所适从了），父类和子类之间，则是先父类后子类。

    +load方法的作用：我们一般在这个函数里执行一些Runtime的方法；

  * +initialize：当类第一次接受到消息时，也就是在第一次使用某个类的时候，那么它将会调用该类的+initialize方法。所以基本就是在我们第一次使用该类的alloc方法时被调用，且只会调用一次，类似于懒加载的效果。

    如果是子类第一次使用，那么其父类的initialize方法也会被自动调用，且在+initialize方法里无需手动调用super，而且调用顺序是**先父类后子类**（感觉之所以这样操作是由于加载子类的时候，必须先加载父类）。如果类和分类都实现了initialize方法，则只有最后编译的category的initialize方法会被调用一次，其他的不会被调用，因为是懒加载。系统用它来初始化静态变量。

  * 为什么+load和+initialize方法会存在这样的区别？
	+initialize的本质是通过objc_msgSend的消息调用机制进行调用的。所以它肯定遵循分类的调用顺序(先分类后宿主类，先父类后子类)；
	+load方法则不是runtime的消息调用机制，而是在获取到load函数地址时，直接进行调用的。所以方法不会出现覆盖的情况。

* 扩展： 扩展可以说是一个匿名的分类，但是它又不是分类，因为它是编译时决议的，生命周期随之宿主类，只有声明，没有实现，依附在宿主类中。主要的作用就是用来声明私有属性、私有方法、私有成员变量。不能为系统类添加扩展。


#### Association关联对象
在category中提到，不能为已有类添加成员变量，因为运行时类的内存布局已经确定了。但是可以添加属性。但其实属性 = setter+ getter + ivar。依然绕不过成员变量这个坎。所以关联对象的出现，正好解决了这个问题。

```
// 添加关联对象API
void objc_setAssociatedObject(id object, const void* key, id value, objc_AssociationPolicy policy)
```

在runtime源码中我们可以看到一个AssociationsManager单例，它负责维护一个静态变量AssociationsHashMap。也就是说整个项目里的关联对象都放在这同一个全局容器中。这个map以API里的object为键值，Value是一个ObjectAssociationMap。也就是说每一个对象都对应一个map，map里存放着当前对象对应的所有关联属性。ObjectAssociationMap是一个以API里的key为键值，以ObjectAssociation为Value。ObjectAssociation则包含着策略和Value两个值。这样正好解决了内存布局的问题。

* 注意：accosiation的移除问题，association的objc_removeAssociationObjects接口是移除某个对象的所有关联对象，如果要移除单个关联对象，则还是应该使用objc_setAssociationObjec传入nil来达到移除目的。
* 在AssociationsManager中有一个spinlock类型的[自旋锁](https://en.wikipedia.org/wiki/Spinlock)lock。保证每次只有一个线程对AssociationsManager进行操作，保证线程安全

#### 通知
通知是使用观察者模式实现的，主要用于跨层传递消息。可以一对多进行传递。
通知的底层实现应该和关联对象的实现方式类似。主要由通知中心NSNotificationCenter管理一个Map表。Map表的key值是notifIctionName，value是一个列表。列表中的每个元素就是观察者、参数、方法等参数。

注意：
* 在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发。所以尽可能使用block API进行处理。其次要多注意它产生的循环引用的问题

* 代理：使用代理模式实现的，使用一对一的传递方式！

#### 属性关键字
* 读写属性：readwrite: 默认，可读可写；readOnly: 只读；

* 原子属性：atomic: 原子性; nonatomic: 非原子性（原子性可以理解为setter和getter方法内部是线程同步的）。atomic并不能完全包证使用属性的过程是线程安全的，  atomic能够保证读写方法的原子性，比如：如果是一个可变数组的话，只能保证数组的读写方法的原子性，但是对数组里元素的操作是没法保证原子性的。其次 atomic非常耗性能。一般我们保证可变数组的线程安全的最直接方式是使用信号锁，如果要实现多读单写则要使用dispatch_barrier_async。

* assign & weak：assign可以修饰基础数据类型和对象类型，但是修饰的对象类型，在对象释放后不会自动置为nil，容易导致垂悬指针错误；weak只能用于修饰对象类型，weak指针指向的对象释放后，会在dealloc内部对weak指针置为nil操作。所以一般使用是用weak修饰对象类型，用assign修饰基础数据类型。其次他们修饰对象类型的话也都不会增加所指对象的引用计数。

* copy：copy一般用于修饰不可变集合类型和block；通常的一个面试题是：为什么使用copy修饰NSString而不是strong。原因就是使用strong的话，如果用一个NSMutableString的类型b给NSString类型a赋值，那么a最终也就变成了NSMutableString类型。对b的修改也会导致a的变化，这样就违背了a是不可变类型的初衷，出现安全性问题。而使用copy，底层是深拷贝，会拷贝一份新的内存，两者的修改不会相互影响。

  MJ版本：拷贝的目的就是产生一个副本对象，副本对象跟源对象互不影响。修改源对象不会影响副本对象，修改副本对象，不会影响源对象。 使用copy—产生不可变副本，使用mutableCopy—产生可变副本。

* 浅拷贝 & 深拷贝：浅拷贝是指拷贝一个指针，与被拷贝对象是同一个内存区域，也就是会增加被拷贝对象的引用计数；深拷贝是将内存区域重新生成一份，然后用指针指向它，不会增加被拷贝对象的引用计数。(如何记忆？原则上，对拷贝完成之后的对象进行操作，不会影响原有对象则为深拷贝，否则为浅拷贝。比如，对不可变对象进行copy，结果是不可变对象，也就是拷贝前后的对象其实是可以使用同一块内存区域的，所以是浅拷贝；对可变对象进行copy，结果是不可变对象，那对拷贝之后的对象进行操作要不影响原有对象，只能拷贝另一份内存区域，所以是深拷贝；同样的，无论对可变还是不可变对象进行mutableCopy，最好都生成可变对象，对拷贝之后的对象进行操作，想要不影响原有对象，则必须拷贝另一份内存区域，所以都是深拷贝)

#### 关键名词解析
* **isa混写**：isa指针指向当前对象所对应的类，也可以说有isa指针的结构体就是一个对象，比如block和runloop。isa混写技术是指在运行时改变isa的指向，实现动态修改对象的类。具体是实现方案是通过给NSObject添加一个分类，分类里调用C函数objc_setClass来修过isa指向
```OC
//实现主体：
#import "NSObject+SetClass.h"
#import <objc/runtime.h>
@implementation NSObject(SetClass)
- (void)setClass:(Class)aclass {
   objc_setClass(self,aclass); //注意这里要确定两个类的size一样，通常需添加一个class_getInstanceSize的判断
}
@end

//使用：
A *a = [[A alloc]init];
[a setClass:[B class]];
```


### Runtime
我们知道OC是在C语言基础之上开发的。编译的时候，OC无法直接编译为汇编语言，而是需要先转成C语言再进行编译。而从OC到C的过度就是由runtime实现的。所以可以说runtime是OC的运行环境，它是OC在C的基础上实现面向对象和动态机制的基石。

#### Runtime 基础数据结构
* 先来分析一下runtime的基础数据结构，从数据结构中了解OC的部分运行时特性：
  OC中所有的对象都是id类型，id类型在runtime时被编译为objc_object结构体，objc_object包含了一个isa指针。OC中类对象Class在runtime中被编译成objc_class结构体，objc_class继承自objc_object。objc_class包含一个super_class指针，一个cache_t结构体，一个class_data_bits_t结构体。cache_t包含一个可增量扩展的数组，这个数组就是散列表，它里面的每一个元素是bucket_t的结构体，bucket_t结构体里包含一个key（其实就是SEL）和一个IMP。class_data_bits_t是对class_rw_t结构体的封装，class_rw_t里包含一个class_ro_t结构体、一个protocols二维数组、一个properties二维数组、一个methods二维数组。class_ro_t里包含一个name、一个ivars数组、一个protocols数组、一个properties数组、一个methods数组。methods数组里是一个method_t的结构体，method_t里包含一个SEL、IMP、const char*类型的字符串。

* 注意几个关键词：
  * isa指针是指向当前对象所属的类。它分为指针型isa和非指针型isa。指针型isa的所有数据都用于存储所属类的地址，非指针型的isa只有部分内容用来存储所属类的地址。我们可以说含有isa指针的结构体都是对象，比如说runloop、block等。其次，类也是一种对象，因为它继承自objc_object，称之为类对象。所以isa的指向就包括：实例对象的isa指向类对象，类对象的isa指针指向元类，元类的isa指针指向根元类，根元类的isa指针指向它本身。

    （MJ版本：isa_t是一个**联合体**，所谓联合体就是里面的成员共享一整块内存区域。联合体里面通常包含一个变量和一个结构体，结构体与变量共用一个内存区域，结构体使用**位域**的形式来标识其每个成员所占用的变量的字节区域。比如isa，整个是一个64位的变量，结构体里的每一个成员都占用其不同的位数，比如mark占第一位、isassociate占第二位、类地址占其中32位等）。

  * 类对象的super_class指针指向父类对象，元类对象的super_class指针指向父类的元类，根元类的super_class指针指向NSObject，NSObject的super_class指针为nil；

  * cache_t **使用散列表**来缓存曾经调用过的方法，可以提高方法查找速度。是**计算机局部性原理**的应用；runtime通过key进行hash算法定位到对应的bucket_t，然后获取IMP。**cache_t也是可增量扩展的，当缓存中的内容大于容量的3/4就会扩充缓存，使缓存的大小翻倍**。

  * method_t中，SEL是函数名（需要注意的是：**不同类中相同名字的方法，所对应的方法选择器是相同的，由于OC的这个特性，所以OC不支持函数重载。同时为了执行效率，runtime会通过dyld的共享缓存来实现选择器的唯一性**）；const char *是一个满足typecoding标准的字符串。

    ```
    -(int)test:(int)a b:(float)b { return 0; }
    这个函数的const char * 就是："i24@0:8i16f20"
    首先我们知道test函数实际还隐藏了两个参数，真实的test方法应该是：
    -(int)test:(id)self _cmd:(SEL)_cmd a:(int)a b:(float)b;
    "i24@0:8i16f20" : i表示返回值是int类型、24表示所有参数共占用24个字节、@表示self、0表示id指针是从整体参数的第0个字节开始、:表示SEL、8表示SEL指针是从整体参数的第8个字节开始、i表示参示int、16表示int参数是从整体参数的第16个字节开始、f表示float、20表示float参数是从整体参数的第20个字节开始的。
    ```

* 几个重要的点：
  * 1、class_rw_t里的二维数组类型有protocols、properties、methods。在runtime的时候，class_data_bits_t**会先将ro里的方法、属性、协议拷贝到rw对应数组中去**，然后再添加category里的方法、属性、协议。也就是说rw中的二维数组不止分类添加的，也包括类原类的方法、属性、协议。其次category添加对应成员时会添加到二维数组的前面，所以方法查找时会先查找category里的方法，再查找原理里的方法。而rw里没有成员变量，成员变量只存放在ro里，而class_ro_t是指只读的相关数据，也就是说已编译好的对象是无法在通过分类添加成员变量的（其实在编译期间类的内存大小已经确定，也不允许轻易更改内存）。在class_rw_t的方法列表中查找时，对于已排到的使用二分法查找，对于没有排序的直接遍历查找。

  * 2、super_class 指针的指向代表了方法查找的过程。也就是说对于实例方法，会沿着类对象的方法列表（此处先省略缓存查找等细节）进行查找，找不到就查找父类的方法列表，最后找的NSObject。而类方法的查找是在元类的方法列表中进行查找，以此往上查找，找的根元类的时候，如果根元类也没有实现，而由于根元类的superClass指针指向NSObject，所以又会查找NSObject对应的实例方法。所以如果一个类没有实现对应的类方法，但是**NSObject**实现了相同名称的实例方法，那么调用类方法时，则最终会调用到NSObject的同名实例方法。（注意，这里的实例方法必须是NSObject实现的。自身类没有实现类方法，实现了同名的实例方法，也是会崩溃的）
    * super : super关键字**调用方法**时，最终也会被编译成**objc_msgSendSuper**方法，这个方法第一个参数传入的是一个**objc_super的结构体**，第二个参数是SEL（比如下面例子里的@selector(class)）。**objc_super**包含一个receiver（消息接收者）和一个super_class（消息接收者的父类）指针，receiver对应的就是当前类的self。objc_msgSendSuper的工作原理应该是这样的: 从objc_super结构体指向的superClass父类的方法列表开始查找selector，**找到后以objc->receiver去调用父类的这个selector**。注意，最后的调用者是objc->receiver，而不是super_class！所以**使用super关键字调用方法，消息的接收者仍然是子类对象，只是方法实现是从内部的super_class开始搜索方法实现（从父类开始）**。另外，**class函数返回的其实就是方法调用者**，而无论是使用self还是super调用，最终的消息接收者都是子类对象，所以调用class方法，最后都返回当前子类的类名。
  ```
  @interface Person
  @end
  @interface Student : Person 
  @end
  @implemention
  -(void)print {
  
  	/*
      class方法是在NSObject里面:
      -(Class)class {
          return object_getClass(self);
      }
      object_getClass实际上获取的是isa
      Class object_getClass(id obj)
  	{
      	if (obj) return obj->getIsa();
      	else return Nil;
  	}
      根据方法的内部实现，我们可以知道，class返回的实际上是当前对象所属的类。
      */ 
  
  	//会编译成：objc_msgSend(self， @selector(class))
      NSLog(@"%@", [self class]);	//Student
      NSLog(@"%@", [self superclass]);	//Person
      
     
     //会编译成：objc_msgSendSuper({self, [Student class]}，@selector(class))
      NSLog(@"%@", [super class]);	//Student
      NSLog(@"%@", [super superclass]);	//Person
  }
  @end
  ```

#### Runtime涉及的事件
* 消息查找过程：

  oc中所有的方法调用都会被转化成函数objc_msgSend。该方法的第一个参数默认是receiver（消息接收者），默认第二个参数是SEL（函数名）。objc_msgSend函数实际是使用汇编语言写的，通常调用频次非常高的函数会被转化成汇编，提高执行效率。

  objc_msgSend方法内部先会判断接收者receiver是否为nil，还会判断selector是否要忽略。如果有target为nil，则会判断是否有相应的nil处理函数，有就跳转到对应的处理函数中。如果没有处理nil的函数，就自动清理现场并回收（这也是为什么可以给nil发送消息的原因）。接着通过receiver的isa指针，获取到当前对象对应的class，然后**在汇编的层级对class的缓存列表进行哈希查找**（哈希查找的过程是用过SEL&mask找到索引，然后找到对应的IMP），如果查找到了就直接返回；如果没有查找到，则会进入C语言的相关函数进行查找过程，**C语言中又会先进行缓存的哈希查找**（为什么这里又要第二次查找缓存？可能是担心在查找的过程中，缓存里有添加进新的方法），如果找到，则直接返回IMP（**在缓存的方法查找过程中也会使用读写锁保证线程安全**）；如果没有找到，则进入到class_data_bits_t的方法列表中（这里既包含类的原始方法又包含分类添加的方法）进行查找，这个查找过程是**先对已排序好的方法列表进行二分查找，然后对未排序的方法进行for迭代查找**（这里要说一下，有一个search_method_list函数，它内部会去判断methodList是否有序就会使用二分搜索，如果无序就傻瓜式迭代）；如果没有找到，则通过receiver的superclass获取到父类，然后在父类里进行查找（查找的过程也是先进行缓存的哈希查找，再对方法列表进行二分查找和迭代查找），**如果父类中找到了，则会将查找到的方法存入到当前调用的类的缓存列表中（注意：父类方法也存到当前类的缓存列表中）**，如果没有找到，则继续往父类里进行查找，如此往复，一直到找到NSObject也没有找到，则会进入动态消息解析的过程。

  * 这里的汇编里的查找过程可以成为高速查找，C语言里的查找过程可以成为缓慢查找；

* 动态消息解析及消息转发：
  如果方法查找没有找到，则iOS提供了动态方法解析和消息转发流程：
  动态方法解析：resolveInstanceMethod: (类方法是resolveClassMethod)。可以在这个方法里动态添加方法实现（使用class_addMethod）（**所以这里底层有个很重要的细节，在调用_class_resolveMethod的时候，会开启读锁，使得在动态添加方法时，不进行读的操作，使操作更安全**），添加完成后，**会重新走消息查找流程**。其次这里添加的方法最终也是添加到RW的方法列表里；
  如果动态方法解析没有添加方法，则开始走消息转发流程（顾名思义，就是将消息转发给别人）：先查看forwardingTargetForSelector：如果返回不为nil则说明转发给了其他id对象，则会开始走那个id对象的消息转发流程（其实就是内部调用了objc_msgSend）；如果返回nil，则会调用methodSignatureForSelector:方法，这个方法返回一个**方法签名**（**方法签名其实就是包装返回值类型、参数类型。其实就是一个动态开辟函数空间的类** ），则会调用forwardingInvocation方法执行（forwardingInvocation的参数NSInvocation，NSInvocation封装了一个函数调用，其中包括：方法调用者、方法名、方法参数。 在这个函数里可以将方法调用者赋值给其他对象，这样也类似转发给了其他方法调用者。）。否则调用doseNotRecognaziedSelector方法报出异常。所以我们可以使用methodSignaltureForSelelctor:和forwardingInvocation：来处理未找到方法导致崩溃的问题，可以对消息进行拦截，然后记录日志。

	* 面试题：方法签名的作用是什么？
		方法签名包含了方法的TypeCoding，它同时会在底层开辟一段函数栈空间，然后赋值给了forwardingInvocation里的NSInvocation。NSInvocation实际则封装了一个方法调用。
```
//动态消息解析
+(BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString *methodName = NSStringFromSelector(sel);
    if ([methodName isEqualToString:@"testMyObject"]) {
    //class_addmethod
    //参数1：给谁添加
    //参数2：添加的selector
    //参数3：添加的imp实现
    //参数4："v@:"方法的签名，代表没有参数的方法。
        class_addMethod([self class], sel, (IMP)myMethod,"v@:");
        return YES;
    }
  return [super resolveInstanceMethod:sel];
}

void myMethod(id self, SEL _cmd) {
    NSLog(@"我被调用了");
}

//消息转发
-(id)forwardingTargetForSelector:(SEL)aSelector
{
    NSString *selectorName = NSStringFromSelector(aSelector);
    if ([selectorName isEqualToString:@"testMyObject"]) {
        myObject *myobject = [[myObject alloc] init];
        return myobject;
    }
    return [super forwardingTargetForSelector:aSelector];
}

//以下方法拦截unreconizedSelector
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
	if ([self respondsToSelector:aSelector]) {
	//已经实现不做处理
		return [super methodSignatureForSelector:aSelector];
  	} 
	return [NSMethodSignature signatureWithObjCTypes:"v@:"];
}
-  (void)forwardInvocation:(NSInvocation *)anInvocation {
	NSLog(@"在 %@ 类中, 调用了没有实现的实例方法: %@ ",NSStringFromClass([self class]),NSStringFromSelector(anInvocation.selector));
}
```

* Method-Swizzing：
  方法交换是指使用runtime API : method_exchangeImplementations(Method m1, Method m2)来交换两个方法的实现。

  * **method-Swizzing应该总在+load中执行**。因为+initialize是以懒加载的方式调用的，是在第一次调用该类的方法时被调用，如果没有方法调用则+initialize永远并不会被执行。**其次+load方法不可以调用super**，如果调用了，那么可能导致多次交换而失效。
  * **method-Swizzing应该总是在Dispatch_once中执行**。避免多次调用，导致交换失效。

  q：两个category同时发生了methodSwizzed会出现什么问题？
  应该会换回去？首先如果分类方法与原始方法同名，则会被分类覆盖掉，而且分类方法如果和原始方法同名，则也无法实现methodswizzling，因为拿到的Method是一样的，所以无法交换。所以这道题的意思只能是两个分类的方法名是一样的，原始方法名不一样，然后在不同的分类分别与原始方法进行methodSwizzling。所以题解：首先分类被运行时加载进来时肯定不可能同时加载，也就是交换方法不可能同时执行，肯定有个先后顺序。然后肯定都得放到load方法里才可能都执行到。所以也就相当于换了之后又被换回去了！所以应该是调用的方法不会发生改变！

  ```
  #import <objc/runtime.h>
  @implementation UIViewController(Swizzling)
  + (void)load {
      static dispatch_once_t onceToken;
      dispatch_once(&onceToken, ^{
          Class class = [self class];
          
          SEL originSelector =  @selector(viewWillAppear:);
          SEL swizzledSelector = @selector(xxx_viewWillAppear:);
          Method originMethod = class_getInstanceMethod(class, originSelector);
          Method swizzledMethod = class_getInstanceMethod(class, swizzledMethod);
          //判断原有类中是否有替换的方法实现
          BOOL didAddMethod = class_addMethod(class, originSelector, method_getImplementation(swizzledMethod),method_getTypeEncoding(swizzledMethod));
          if (didAddMethod) {
              class_replaceMethod(class, swizzledSelector, method_getImplementation(originMethod),method_getTypeEncoding(originMethod));
          }else{
              method_exchangeImplementations(originMethod, swizzledMethod);
          }
      });
  }
  
  - (void)xxx_viewWillAppear:(BOOL)animated {
      [self xxx_viewWillAppear:animated];
      
  }
  @end
  ```

  

* 其他：Category、KVO、KVC、ARC等

* isKindOfClass & isMemberOfClass的区别？

  这两个函数的底层实现是：

  ```
  -(BOOL)isMembberOfClass:(Class)cls {
      return [self class] == cls;
  }
  // 一直循环查看class及super的class，判断是否有相等
  -(BOOL)isKindOfClass:(Class)cls {
      for(Class tcls = [self class], tcls = tcls->superClass) {
          if (tls == cls) return YES;
      }
      return NO;
  }
  ```

  从底层源码可以得出：isKindOfClass是判断消息接收者是否是参数类本身或者参数类子类；isMemberOfClass则是只判断消息接收者是否是参数类本身。

  

  ```
  @interface Person : NSObject
  @end
  
  -(void)main {
  //这几个左侧是id类型，也就是实例对象，所以class是类对象。所以右侧是类对象，所以class是元类。isKindOfClass会不断循环往父类查看是否是和当前class相等，isMemberOfClass则直接判断是否和当前class相等。
  // 另外，可以看出class是可以直接强转成id类型的。
      BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; //YES
      BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; //NO
      BOOL res3 = [(id)[Test2 class] isKindOfClass:[Test2 class]]; //NO
      BOOL res4 = [(id)[Test2 class] isMemberOfClass:[Test2 class]]; //NO
  // 这几个是测试实例对象
      BOOL res5 = [[NSObject new] isKindOfClass:[NSObject class]]; //YES
      BOOL res6 = [[NSObject new] isMemberOfClass:[NSObject class]]; //YES
      BOOL res7 = [[Test2 new] isKindOfClass:[Test2 class]]; //YES
      BOOL res8 = [[Test2 new] isMemberOfClass:[Test2 class]]; //YES
  }
  ```

[runtime入院系列](https://halfrost.com/objc_runtime_isa_class/)

### Runloop
RunLoop是通过系统内部维护的事件循环来对事件和消息进行管理的对象。事件循环可以有效地对消息和事件进行管理：当有消息需要处理时，会将进程从内核态到用户态进行切换，同时唤醒当前线程处理消息；当没有消息需要处理时，会休眠当前线程，将进程从用户态到内核态进行切换，以避免资源占用。所以runloop可以保证进程不退出，可以处理和监听事件，可以定时渲染UI，可以调节CPU的工作。

```
int retVal = 0;
do{
    // 睡眠中等待消息
    int message = slwwp_and_wait();
    // 处理消息
    retval = process_message(message);
}while (0 == retVal);
```



#### runloop基础数据结构：
CFRunLoopRef 里包含一个pthread、一个currentMode、一个modes、一个commonModes、一个commonModeItems。其中后面3个都是集合类型，里面放着的是CFRunLoopMode类型的元素，CFRunLoopMode的成员主要包含name、source0、source1、obbservers、timers等元素。currentMode和modes里的数据结构都是对应CFRunLoopMode类型，CFRunLoopMode对应5种mode：DefaultMode、UITrackingMode、UIInitializationMode、EventReceiveMode、CommonModes。currentMode是指当前runloop对应的运行mode，每次调用runloop的时候，只能指定一个mode为currentMode。如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入。这么做的目的就是为了在某个mode运行下，不会受到其他时间的影响，比如在滚动的trackingmode时，不会受到点击触摸事件的影响。 commonModes对应的是字符串，也就是前面5种mode的名称，它是一种技术解决方案。modeItems对应4种item：Observer、timer、source0、source1。

* 注意：
  * CFRunLoop和NSRunLoop的区别就是：CFRunLoop是纯C的API，是线程安全的，NSRunLoop是对CFRunLoop的包装，它不是线程安全的。 所以如果在一个线程中操作另一个线程的runloop可能会产生意想不到的后果。所以可以使用getCGRunLoop获取对应的CFRunLoopRef类，来达到线程安全的目的。

  * RunLoop与线程是一一对应的关系。CFRunLoop是基于pthread来管理的。所有的runloop被存在一个全局的字典容器中。我们无法手动代码创建runloop，只能通过currentRunLoop获取当前的runloop，如果你不主动获取，那它永远都不会有。获取的过程中，以线程为key值进行查找，没有找到就会默认创建。RunLoop的创建是发生在第一次获取时，RunLoop销毁是发生在线程结束时。所以子线程中，不手动调用[[NSRunloop current] run]，则该线程中的runloop就不会自动开启。 

  * 五种mode的区别：DefaultMode是APP默认的mode，通常主线程是在这个mode下运行；TrackingMode是UIScrollView的滑动mode；UIInitializationMode是app启动时的mode，启动完成后就不再使用；EventReceiveMode系统内部接收事件的mode，通常用不到；CommonMode则实际上不是一种模式，而是一种mode的组合方式。一个RunLoop包含多个Mode、每个Mode又包含多个Timer、Observer、Source；

  * commonMode是一种技术解决方案。RunLoop启动时只能指定一个Mode作为当前的currentMode，如果要切换Mode，只能先退出当前Mode，重新选择一个Mode进入。而commonMode是一种伪模式，它是指标记了Common属性的Mode，默认被标记了Common属性的Mode只有DefaultMode，TrackingMode。也可以使用CFRunLoopAddCommonMode 方法向 Common Modes中添加自定义 modes。

    ```
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];
    //下面一行和上面两行的效果是一样的
    [[NSRunLoop currentRunLoop] addTimer:timer3 forMode:NSRunLoopCommonModes];
    ```

    CommonMode就是为了解决一个RunLoop只能有一个Mode而产生的技术解决方案。而一个mode一旦被标记为common属性的话，则该mode的名字字符串就会被放到当前RunLoop的commonModes集合中，当runloop的mode变成CommonMode时，runloop会将commonModeItems中的Observer、timer、source同步到commonModes集合中的mode中，这样就可以让一些事件可以同时在多个mode中工作。比如NSTimer，当其被添加进commonMode中时，它就可以在标记了common属性的DefaultMode和TrackingMode中同时运行。

  * 4种Mode Item：Observer、timer、source0、source1：Oberver主要是用来观察RunLoop自身的6大状态，Timer实际就是我们用的NSTimer，也就是说NSTimer是根据RunLoop的Timer事件实现的，所以它是不准的。source0用于接收用户事件，比如UIEvent事件、performSelector调起的函数等。source1事件是系统内核使用的，比如基于Port的线程间通信、系统事件捕捉等，它可以主动唤起线程。

  * source0 和 source1的关系：

    source0只包含了一个回调，不具备唤醒线程的能力。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。 Source0事件则主要用于app应用层事件，

    source1包含了一个mach_port和一个回调，具备唤醒线程的能力。主要用于通过内核和其他线程相互发送消息和系统内核事件，

    所以一个touch事件，最初是由系统点击屏幕捕获到的系统事件，然后通过mach_msg，在APP内核生成一个source1事件，之后source1唤醒了当前线程，然后将其包装成source0事件去处理。

  * runloop循环状态：

    第一步：进入RunLoop会发出**KCFRunLoopEntry**通知，表示将循环监听当前runloop的mode中的各种状态。（注意：不存在KCFRunLoopBeforeObserver通知，然后如果将监听代码放到main函数里面，可以监听到 defaultMode的开启。其次，当切换mode时，比如从DefaultMode切到TrackingMode：会先执行DefaultMode的kCFRunLoopExit通知，然后执行UITrackingRunLoopMode的kCFRunLoopEntry通知；当滚动结束后，会先执行UITrackingRunLoopMode的kCFRunLoopExit通知,然后再执行DefaultMode的kCFRunLoopEntry通知，重新进入DefaultMode。）；

    第二步：进入Loop后，会先通知Observer，RunLoop将要触发Timer回调和Sources回调，接着执行block；（其实是先判断是否有timer事件和source0事件，有的话会先发送**KCFRunLoopBeforeTimers**和**KCFRunLoopBeforeSources**，处理对应Timer回调和Sources回调，然后执行block。处理sources回调时如果有Source1是ready状态的话，则会先跳转到handle_msg去处理消息）；

    第三步：回调触发后，则通知Observers，RunLoop将要进入休眠状态。（发出**CFRunLoopBeforeWaiting**通知）；

    第四步：进入休眠后，会等待mach_port消息，以再次唤醒。（有四个事件能将线程唤醒：基于port的Source1事件、Timer时间到、RunLoop超时、被调用者唤醒）；

    第五步：被唤醒后，发出**KCFRunLoopAfterWaiting**消息

    第六步：处理被唤醒的消息：timer时间、source1事件、GCD的唤起主队列事件；

    第七步：根据当前RunLoop的状态来判断是否继续监听当前runloop，如果继续监听，则又会从第二步开始。如果是被外部强制停止或者loop超时或者切换Mode，则会先退出当前RunLoop；

    第八步：如果退出的当前runloop的mode为非DefaultMode，则退出当前RunLoop的话会先发出**KCFRunLoopExit**通知，退出当前Mode。然后再重新进入到DefaultMode，发出DefaultMode的kCFRunLoopEntry通知。如果是在DefaultMode中，则只有程序关闭或切换Mode才会执行DefaultMode的**KCFRunLoopExit**通知。所以程序运行过程中肯定是一直处于某一种Mode当中的。也就是RunLoop一直会存在；

    根据这八个步骤也就知道，主要处理事件的阶段是在KCFRunLoopBeforeSources到KCFRunLoopBeforeWaiting之间 和 KCFRunLoopAfterWaiting之后。所以如果KCFRunLoopBeforeSources状态和KCFRunLoopAfterWaiting状态所在的时间过长（超过了卡顿阈值），那么就可以认为有卡顿出现了

    ```
    //另一种创建Observable的方式
            CFRunLoopObserverRef observer2 = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
                CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());
                switch (activity) {
                    case kCFRunLoopEntry:
                        NSLog(@"block__kCFRunLoopEntry__%@", mode);
                        break;
                    case kCFRunLoopExit:
                        NSLog(@"block__kCFRunLoopExit__%@", mode);
                        break;
                    default:
                        break;
                }
                CFRelease(mode);
            });
            CFRunLoopAddObserver(CFRunLoopGetMain(), observer2, kCFRunLoopCommonModes);
            CFRelease(observer2);
    ```

    

  * RunLoop主要处理6种事件：
    * 1、是Observer事件，主要是用于监听RunLoop本身的状态，然后Core Animation也是通过Observer监听状态来进行UI绘制的；
    * 2、block事件，非延时的performselector: 、dispatch_after立即调用、block回调；
    * 3、Dispatchlib唤醒主线程事件；
    * 4、Timer事件。延迟的performSelector：、延迟的dispatch_after、timer事件；
    * 5、是source0事件，主要包括event和socket事件；
    * 6、是mach_msg通信事件；

#### RunLoop涉及的事件：
* CALayer或者说视图树中的视图如果层次、frame或者调用了setNeedsDisplay\setNeedsLayout，则CALayer就会被标记为待处理。等到VSync信号发出来的时候才会CPU才开始处理，VSync的信号周期也就是 runloop的刷新周期，也就是在每秒60帧的画面，16.7ms的周期；(这里要说一下，之前一直认为UI要绘制的话，RunLoop要休眠怎么可能会达到16.7ms的绘制周期呢？其实不需要纠结这个问题，因为如果需要绘制，RunLoop肯定是不会在休眠的，如果在休眠状态，UI也是肯定不需要重绘的)

* runloop使得main函数不会退出，因为UIApplicationMain内部开启了一个主线程的runloop；

* runloop可以提升CPU效率，使其有事的时候做事，没事的时候休息；

* NSTimer实际是根据runloop的CFRunLoopTimerRef来实现的，为了节省资源，默认情况下，NSTimer只能在DefaultMode下被回调。当屏幕滑动时，定时器会暂停运行，所以需要通过commonMode的方案来解决。CADisplayLink则是一个和屏幕刷新率一致的定时器，但是它同样存在和NSTimer一样的问题。 所以要想要更精准的定时器，最好使用GCD或者Facebook 开源的 AsyncDisplayLink；

  MJ：CADisplayLink和NSTimer底层都是基于runloop来实现的。如果RunLoop的任务过于繁重的话，就可能导致NSTimer不准时。（可以理解为RunLoop每进行一次loop循环，就会查看一下定时器，只有定时器累计时间超过1s才会触发。而RunLoop每次运行一周的任务是不确定的，导致运行时间是不固定的，所以跑完很多圈之后，时间可能并不一定是1s，有可能超过1秒。比如0.2+0.3+0.3+0.5 > 1.0 触发定时器）。

  核心动画：NSTimer被插入到runloop的任务列表里，需要等到runloop执行到处理时间时间才会启动。所以说何时启动定时器并不确定，如果上一个任务需要较长时间执行完成，所以就可能导致延迟时间。CADisplayLink是CoreAnimation提供的类似NSTime的类，它总是在屏幕完成一次更新后启动（而屏幕的更新频率是每秒60次），所以也是每秒60次。我们通常使用CADisplayerLink来测量帧率，**但是FPS并不能够完全真实测量出Core Animation性能**，因为它仅仅测出应用内的帧率，而有的渲染是发生在应用之外的（在渲染服务器进程中处理）。所以FPS可以对某些性能提供参考，但是也会存在不一定准确的情况。

  要使定时器准时，则可以使用GCD的定时器，GCD的定时器是直接跟系统内核挂钩的，所以是非常准时的。而且GCD的定时器，不会受runloop的任何影响，且可以在任何线程下使用。其次GCD创建的东西也不需要手动销毁（就像我们创建的队列也不用手动销毁一样）。

  ```
  // 将NSTimer添加到commonModes里
  [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
  
  //GCD NSTimer 
  {
      // 定时器执行的队列
  	dispatch_queue_t queue = dispatch_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  	// 创建定时器
  	dispatch_source_t timer = dispatch_source_creat(DISPATCH_SOURCE_TYPE_TIMER,0,0,queue);
  	// 设置时间
  	uint64_t start = 2.0;	// 2秒后开始执行
  	uint64_t interval = 1.0; // 每隔1秒执行
  	dispatch_source_set_timer(timer,
  						dispatch_timer(DISPATCH_TIME_NOW,start * NSEC_PER_SEC),
  						interval * NSEC_PER_SEC, 
  						0);
  	// 设置回调，block 回调形式
  	dispatch_source_set_event_handler(timer, ^{
  		//定时回调了
  		NSLog(@"1111");
  	});
  	// 设置回调 ，函数形式
  	// dispatch_source_event_handler_f(timer, timerFire);
  
  	//启动定时器
  	dispatch_resumr(timer);
  }
  
  //定时器回调函数
  void timerFire(void *param) {
      NSLog(@"1111");
  }
  
  ```

  

* AutoreleasePool的实现原理：AutoreleasePool及其包含的对象的内存管理是根据runloop的运行周期来确定的，具体查看内存管理章节。

* 事件响应：参考上面source0和source1的分析

* performSelector：当使用NSObject的performSelecter:afterDelay:或者performSelector:onThhread：（注意这里一定得是和时间或线程有关的API），实际会在其内部创建一个NSTimer并添加到当前线程的Runloop中。所以如果当前线程没有Runloop，则这个方法会失效，比如在新创建的子线程中，如果不调用[[NSRunLoop currentRunLoop] run]则就不会调用Select中的函数。

* GCD：GCD中的dispatch_async在使用到主线程的时候也使用到了RunLoop。首先GCD的所有线程仍然由libDispatch处理，但是当用到主线程的时候，libDispatch会向主线程的RunLoop发送消息，主线程的RunLoop会被唤醒，并从消息中获取block，然后回调执行。其他线程则仍由libDispatch处理。

* 线程保活，网络请求框架中的常驻线程(面试有被考到)；
  如果一个子程序经常要处理任务，那就最好不要让其销毁。因为频繁地创建和销毁线程，也是非常消耗性能的。开启一个常驻线程也是非常便捷的。比如：

  ```
  -(void)viewDidLoad {
  	[super viewDidLoad];
  	_thread = [[FCFThread alloc] initWithTarget:self selector:@selector(run) object:nil];
  	[_thread start];
  }
  
  - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
  	//每点击一次就执行一次任务。意味着经常要在子程序中执行任务，所以才要求最好保活线程。
  	[self performSelector:@selector(task) onThread:_thread withObject:nil waitUntilDone:NO];
  }
  
  // 子线程经常要执行的任务
  - (void)task {
  	NSLog(@"子线程经常要执行的任务%s %@", __func__, [NSThread currentThread]);
  }
  
  //这个方法就是在子线程开启的时候执行，为了开启runloop，保证子线程不退出
  - (void)run {
  	NSLog(@"%s %@", __func__, [NSThread currentThread]);
  	//添加了这句就可以让线程保活，不执行后面的end。
  	[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];
  	[[NSRunLoop currentRunLoop] run];
  	NSLog(@"end");
  }
  ```
  但是这段代码存在的一个问题：子线程thread保活了，也就是不会被释放。而thread的target是当前ViewController，所以就导致当前ViewController无法被释放，导致内存泄漏。所以我们换一种thread的block初始化方法，使得ViewController并不会被thread强引用：
  ```
  -(void)viewDidLoad {
  	[super viewDidLoad];
  	//不引用target创建子线程和开始方法
  	_thread = [[FCFThread alloc] initWithBlock:^{
            NSLog(@"begin__%@", [NSThread currentThread]);
           
           //添加了这句就可以让线程保活，不执行后面的end。
           [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];
           [[NSRunLoop currentRunLoop] run];
           
           NSLog(@"end__%@", [NSThread currentThread]);
    }];
    [_thread start];
  
  }
  
  - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
  	//每点击一次就执行一次任务。意味着经常要在子程序中执行任务，所以才要求最好保活线程。
  	[self performSelector:@selector(task) onThread:_thread withObject:nil waitUntilDone:NO];
  }
  
  // 子线程经常要执行的任务
  - (void)task {
  	NSLog(@"子线程经常要执行的任务%s %@", __func__, [NSThread currentThread]);
  }
  ```
  这样的话，ViewController可以释放了，但是当前线程仍然没有销毁。还是会导致性能消耗。所以最好的做法就是让thread也跟随ViewController一起销毁。所以我们在ViewController的模拟销毁方法中方法中调用CFRunLoopStop方法暂停当前RunLoop，例如：
  ```
  // 停止子线程的runloop
  - (void)stopThread {
    	CFRunLoopStop(CFRunLoopGetCurrent());
    	NSLog(@"%s %@", __func__, [NSThread currentThread]);
  }
  
  // 按钮模拟销毁子线程
  - (IBAction)destroyThread:(id)sender {
    	// 让销毁方法在子线程中执行，才能拿到子线程的runloop
    	[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];
    	self.thread = nil;
  }
  ```
  结果发现，子线程仍然不会执行到打印end，也就是说子线程仍然没有销毁。这是为什么呢？从RunLoop的run方法的说明中，我们发现NSRunLoop的run方法底层是在重复调用runMode:beforeDate:方法，相当于是在这个Date之前开启一个无限的循环。换句话说run方法是停不掉的。所以我们的策略就是不使用NSRunLoop的run方法。最终代码就是：
  ```
  - (void)viewDidLoad {
  	[super viewDidLoad];
  	__weak typeof(self) weakself = self;
  	//使用block不使用target，避免强引用target
  	_thread = [[FCFThread alloc] initWithBlock:^{
            NSLog(@"begin__%@", [NSThread currentThread]);
  		//添加了这句就可以让线程保活，不执行后面的end。
  		[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];
  		//不使用这个方法，因为它无法被Stop。
  		//[[NSRunLoop currentRunLoop] run];
  		
  		// 注意这里的弱指针可能在下一个循环时被nil了。所以要加一个判断。
  		while (weakself && !weakself.isStop) {
  			[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
  		}
  		NSLog(@"end__%@", [NSThread currentThread]);
  	}];
  	[_thread start];
  }
  
  - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
  	//每点击一次就执行一次任务。意味着经常要在子程序中执行任务，所以才要求最好保活线程。
  	if (self.thread) {
  		[self performSelector:@selector(task) onThread:_thread withObject:nil waitUntilDone:NO];
  	}
  }
  
  // 子线程经常要执行的任务
  - (void)task {
  	NSLog(@"子线程经常要执行的任务%s %@", __func__, [NSThread currentThread]);
  }
  
  //停止子线程的runloop
  - (void)stopThread {
  	//更改标记
  	self.isStop = YES;
  	//停止RunLoop(只能停止一次runMode:deforeDate,所以无法使用它停止RunLoop的run方法)
  	CFRunLoopStop(CFRunLoopGetCurrent());
  	NSLog(@"%s %@", __func__, [NSThread currentThread]);
  	//清空线程
  	self.thread = nil;
  }
  
  // 按钮模拟销毁子线程
  - (IBAction)destroyThread:(id)sender {
  	if (!self.thread) return;
  	// 让销毁方法在子线程中执行，才能拿到子线程的runloop。
  	// 其次要注意一点，这里的waitUntilDone要设置成YES，表示子线程里的函数执行完毕后才会执行当前线程接下来的方法。如果设置成NO。然后在ViewController的dealloc方法中调用这个函数去销毁子线程会可能导致ViewController在子程序之前销毁，从而出现坏内存访问的问题。
  	[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];
  }
  
  - (void)dealloc {
      [self destroyThread:nil];
  }
  ```

[runloop详解](https://blog.ibireme.com/2015/05/18/runloop/)


### Block
Block是对函数及其执行上下文封装起来的对象。
#### block基础数据结构：
Block最终被编译之后得到的是一个结构体，结构体内部成员变量有一个 __block_impl的结构体，它内部包含一个isa指针，一个FunPtr函数指针。所以说block是一个对象，block调用就是函数调用。
可以通过打印block的superclass来查看block的类型，最终会得到NSObject。

```
void test1() {
    //说明block是一个对象
    void (^block)(void) = ^ {
        NSLog(@"xxxxxx");
    };
    NSLog(@"%@", [block class]); //__NSGlobalBlock__
    NSLog(@"%@", [[block class] superclass]); //__NSGlobalBlock
    NSLog(@"%@", [[[block class] superclass] superclass]); //NSBlock
    NSLog(@"%@", [[[[block class] superclass] superclass] superclass]); //NSObject
}
```

#### 截获变量： 
由block的底层原理可知，block调用就是函数调用。那么block使用外部的变量，就相当于函数使用外部变量。而block对于不同类型的变量有不同的捕获方式。**所谓捕获，就是结构体内部会有一个专门的新成员用来存储外部对应变量的值**。
* static（这里优先解释一下static的作用）:

  * 首先变量分为**全局变量和局部变量**。全局变量在所有文件中均可访问，全局变量存储在全局数据区；局部变量只在代码块中可以访问，局部变量通常是存储在函数栈中。

  * 如果在全局变量上添加static，那么就成了静态全局变量。静态全局变量的只在当前源文件内有效，其他文件无法访问。

  * 如果在局部变量上添加static，那么就成了静态局部变量。静态局部变量改变了其生存期，但是它的作用域依旧当前定义的函数体内。

  * 其次，这里要说明的是OC里的成员变量问题，实际上OC中的所有成员变量都是通过先获取对象（一般来说，是self），再通过get函数或者指针方式访问到对象，再获取到成员变量。所以对象里的成员变量实际也可以认为是局部变量。


Block使用到的变量包括：
* 全局变量（包括了静态全局变量）：
  * 不会捕获到block内部，直接访问。
  因为全局变量作用域是全局（即使是静态全局变量，作用域也是当前整个文件），所以可以直接访问，而不需要截获，即可直接使用；
* 局部变量：会捕获到block内部，但是访问方式不一样。
  * 自动变量 auto：c语言中一般定义的局部变量就有auto默认关键字，但是一般会省略，所谓auto就是说一离开作用域，就会自动销毁。所以auto变量也可以认为是非静态的局部变量。 
    * auto基础数据类型：**捕获方式是值传递**，只截获其值。
    * auto对象类型：**捕获方式是连同所有权修饰符一起截获**。（当block在栈上时，将不会对对象类型的auto变量产生强引用(因为block会随即释放，从而就没必要做什么额外操作)；当block拷贝到堆上时，会调用block内部的copy函数，该函数会根据auto对象的修饰符(_ _ strong、_ _ weak、_ _ unsafe_unretained)来对对象形成对应的强引用或弱引用；当block从堆上移除时，会调用block内部的dispose函数，执行auto对象的release方法）。

  * 静态局部变量 static：**捕获方式是指针传递**。
    因为局部变量的作用域只在当前代码块中（静态局部变量，虽然其存储在数据区，但是其作用域也只是当前函数体内），所以如果block使用了局部变量，当函数体执行完毕后（函数堆栈被释放了），block要想在其他地方使用的话，那block就得确保其内部访问的变量是有值的。

    比如：
  ```
  void (^block4)(void);
  void test() {
  	int age = 10;
  	static int height = 10;
  	block4 = ^{
  		NSLog(@"age is %d, height is %d", age, height);
  	};
  	age = 20;
  	height = 20;
  	block4();
  }// 执行到这里 age 就会被销毁。但是height不会销毁。
  int main(int argc, const char * argv[]) {
  	@autoreleasepool {
  	test();
  	/*
  	执行下面block时，block里面又得访问age和height。而此时age已经销毁了，而height有作用域问题，也是没法直接访问的。所以在block内部，得优先把age的值存起来，所以使用值传递就可以了。而height是静态变量，其仍旧存储在内存中，仍然可以访问到height的地址，所以使用指针传递，而无需开辟新的空间。
  	*/
  	block4();
  }
  return 0;
  }
  ```

  block对self的捕获也是遵循自动变量的捕获规则的：
  ```
  @implementation FCFPerson
  /*
  下面函数的编译结果:
  static void _I_FCFPerson_test(FCFPerson * self, SEL _cmd) {...}
  block的编译结果是:
  struct __FCFPerson__test_block_impl_0 {
  struct __block_impl impl;
  struct __FCFPerson__test_block_desc_0* Desc;
  FCFPerson *self; //捕获
  __FCFPerson__test_block_impl_0 ...
  };
  从函数的编译结果可知self也是一个参数，所以它也是一个局部变量。所以self也被捕获了。而block内部使用当前类的_name成员变量，实际也是先捕获self，然后通过self->_name来获取到成员变量的。如果是self.name，这里实际是编译成objc_msgSend,调用name的getter方法。
  */
  - (void)test {
  	void (^block)(void) = ^{
  		NSLog(@"------------%p", self);
  		NSLog(@"------------%p", self->_name);
  		NSLog(@"------------%p", self.name);
  	};
  	block();
  }
  @end
  ```

局部变量截获问题总结一下：
  * 对于局部auto基础数据类型编译后是**值传递**。所以即使是block里修改成功了自动变量，也无法改变外部的值；
  * 对于局部auto对象类型则是采用**连同其所有权修饰符一起截获**。如果是栈block，则无论修饰符是什么，都不会产生强引用（因为栈block随时都会释放，即使进行了强引用，那么block释放的时候，引用计数也会里面减一，所以就没有必要强引用）；如果是堆block，则会根据其所有权修饰符来确定是弱引用还是强引用。如果是强引用的话，则就可以保证被截获的对象肯定是在block之后被销毁的，所以对象在block内外的变化，都可以被同步到。因为最终操作都是通过指针找到对应的对象进行操作。其次这也存在内存管理相关的东西，所以这也就可能导致循环引用的问题。（说白了其实就是根据修饰符来改变了引用计数而已，如果最终没有被释放（强引用）最终也是通过block内部的指针找对对应的对象，然后进行操作）。
  * 对于静态局部变量，则直接通过**指针传递**，因为静态变量一直存在内存中，所以只需要得到地址就能够访问到之前的内容。

#### block的类型：
block分为NSGlobalBlock、NSMallocBlock、NSStackBlock，它们分别存在在全局数据区、堆区、栈区。并且在**ARC和MRC中有所区别**：
* **没有访问auto变量**的block就是全局block（Global）。 全局block对copy、retain、release没有反应；
* **访问了auto变量**的block就变成了栈block（stack）。因为一旦使用到了auto变量，就可能因为截获变量而得管理相关内存，所以block就得放到栈区，这栈block也容易被释放，所以一般我们都使用堆block。
* **在MRC下栈block调用了copy方法变为堆block（malloc）；在ARC下，编译器会根据情况自动将栈上的block复制到堆上，变成堆block（malloc）**，比如：
  * block作为返回值时；
  * 将block赋值给 _ _ strong指针时；
  * block作为foundation框架里的API的UsingBlock参数时；
  * 调用Block的copy方法（注意这里必须得是栈block） ；
  * block作为GCD API的方法参数时；
    在MRC下，只有对栈block进行copy操作才能将栈block拷贝到堆上，所以block属性使用copy；
* 注意 ：
  这里用代码解释一下block在ARC和MRC的区别：
```
void (^block)(void) = ^{
	NSLog(@"hello");
};
int age = 10;
void (^block2)(void) =^{
	NSLog(@"hello -- %d", age);
};
NSLog(@"%@\n%@\n%@",[block class],[block2 class], [^{
	NSLog(@"%d", age);
} class]);
//打印结果依次是：__NSGlobalBlock__ 、__NSMallocBlock__ 、__NSStackBlock__
 
void(^block) = ^{};   //block 没有对外部变量进行任何操作，所以是全局block;
int val = 0; 
NSLog("%@",^{val = 1;}); //引用了外部变量，所以这个匿名block是一个栈block，如果这是对其使用[^{val = 1;} copy],则就会变成一个堆block；
void (^block1) = ^{val=1;}; //注意，在MRC下，block1是一个栈block，因为它引用了外部变量。但是在ARC下，它是一个堆block，因为 = 左侧block1默认是 __ strong类型，相当于上文说的“将block赋值给__strong修饰的类型或成员变量”，所以在ARC下，大部分block其实都是堆block。
```
所以 在MRC中，block属性只能使用copy关键字，在ARC中，block属性可以使用Strong关键字和copy关键字。在实际开发过程中，为了使代码在ARC和MRC中都能使用，所以我们一般推荐使用copy关键字。

通过上面的分析，我们知道对全局block进行copy不会有任务反应，对栈block进行copy则会被拷贝到堆上，对堆block进行copy操作则会增加其引用计数（所以是个浅拷贝）。

#### --block：

问题：为什么会出现_ _ block？

block对于不同的数据类型，有不同的截获方式。全局变量、静态局部变量都是存储在数据区，所以在block内对其进行修改，也可以成功；**对auto变量进行修改，那是否能够实现？答案是不能**(我们如果在block里对auto类型变量进行**修改**，编辑器会直接报错)。其次我猜测是因为block里修改auto变量实际上就会触发到内存相关问题，首先对于auto基础数据类型，因为是值传递进来的，所以修改了block里面的值，就没法同步到block外面，所以编译器不允许；对于auto对象类型，在block里修改了对象（其实就是重新赋值），那就是在堆上开辟了一块新的内存空间的问题，所以两个对象无关联的话，那其实也是在block内外无法同步的，所以编译器同样不会允许。
所以这就出现了 _ _ block。
什么是 _ _ block? 
**_ _ block其实是一个存储区域说明符，它可以指定变量值存储到哪个区域中**。所以_ _ block可以解决block内部无法修改auto数据类型的问题。但是注意：_ _ block不能修饰全局变量、静态变量（因为这两个变量存储在数据区，数据区里的东西，编译完成后就不能轻易动）。

具体代码实现：

```
/*
下面的age变量最终编译成了一个结构体：
struct __Block_byref_age_0 {
	void *__isa;
	__Block_byref_age_0 *__forwarding; //可以发现这个指针类型是它本身
	int __flags;
	int __size;
	int age; //这里肯定就是存储age传进来的值
};
下面FCFPerson对象也被编译成了一个结构体：
struct __Block_byref_p_1 {
	void *__isa;
	__Block_byref_p_1 *__forwarding;
	int __flags;
	int __size;
	void (*__Block_byref_id_object_copy)(void*, void*);
	void (*__Block_byref_id_object_dispose)(void*);
	FCFPerson *p; //注意这个指针会根据MRC、ARC以及ARC下的引用计数修饰符来确定是强引用还是弱引用。
};
可以发现这个auto对象类型只是多了两个内存管理的方法：copy和disponse。
下面一行最终编译成：
__Block_byref_age_0 age = {
                    0,
                    &age,	//可以发现__forwarding存储的是age变量本身的地址，也就是__Block_byref_age_0结构体本身的地址。
                    0,
                    sizeof(__Block_byref_age_0),
                    10
};
*/
__block int age = 10;
__block FCFPerson * p = [FCFPerson new];
void (^block)(void) = ^{
	//这一句被被编译成：(age->__forwarding->age) = 20; 第一个age是结构体指针。
    age = 20;
    //下面一行被编译成：p = {0,&p, 33554432, sizeof(__Block_byref_p_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((objc_msgSend)(objc_getClass("FCFPerson"), sel_registerName("new"))};
	p = [FCFPerson new]; 
};
block();
// 这里编译成了age->__forwarding->age = 30；也就是说添加了_ _block之后，对age变量的所有修改，都是先通过结构体指针拿到__forwarding指针，然后获取到结构体内部的同名变量age，然后进行修改。
age = 30;
```

可以发现添加了 _ _ block修饰符的变量最终会被封装成一个结构体。结构体中包含一个isa指针与变量同名的成员变量，还包含一个 **_ _ forwarding指针，初始化指向结构体自身地址**。也就是说使用了 _ _ block修饰的变量最终变成了结构体对象。然后在block中对auto变量进行修改时，实际的使用方式是通过结构体指针获取到_ _ forwarding指针，然后获取到结构体内部的同名变量，最终进行赋值。

当auto变量变成结构体对象后，那么就肯定需要处理内存管理的问题。__block 修饰的对象的内存是怎么管理的呢？ 

*  _ _ block修饰的auto基础数据类型。 当block在栈上时，不会产生强引用（因为没有必要）。当block拷贝到堆上时， _ _ block结构体也会被拷贝到堆上，_ _ block结构体也会被拷贝到堆上，然后内部生成的结构体对象会通过copy函数来处理。因为其变成了对象，所以和auto对象类型一样的方式进行**连同其所有权修饰符一起截获**，又因为__block是强引用修饰，所以添加了 _ _ block修饰的auto基础数据类型最终是一个强引用的过程；当block从堆上移除的时候，则会通过dispose函数来释放它们（执行release）。
* _ _ block修饰的auto对象类型。其内部也是会生成一个新的结构体，然后内部有一个同名的对象指针。当block在栈上时，也不会产生强引用（因为没有必要）。当block拷贝到堆上时， _ _ block结构体也会被拷贝到堆上，然后内部生成的结构体对象会通过copy函数来处理。**如果是在MRC的情况下，内部结构体里的对象指针永远是弱引用；在ARC下，则会根据外部对象本身的所有权修饰符来确定是强引用还是弱引用**，多个block同时使用该变量的话，也只是引用计数上的变化。当block从堆上移除的时候，则会通过dispose函数来释放它们（执行release）。

**_ _ forwarding指针**

栈上的_ _ forwarding指针指向自身结构体地址，当 _ _ block变量被拷贝到堆上时，原来栈上的_ _ forwarding指针会指向其拷贝到堆上的结构体地址，堆上的_ _ forwarding指针依旧指向堆上自身结构体地址。这样就确保了无论什么时候、在哪里修改该 _ _block变量，最终都是修改的堆上的变量。



#### block循环引用：
* 使用_ _ weak、_ _ unsafe_unretained解决：
```
	FCFPerson * p = [FCFPerson new];
	p.block = ^{
		NSLog(@"-----------%@",p.name);
	};
```
解决方式：
```
	FCFPerson * p = [FCFPerson new];
	__weak typeof(p) weakp = p; //或者使用__unsafe_unretained , 只是__unsafe_unretained不安全，指针不会回收，会产生野指针错误。
	p.block = ^{
		__strong typeof(weakp) strongp = p; //为了确保执行过程中p不为nil
		NSLog(@"-----------%@",strongp.name);
	};
```

* _ _ block变量导致的循环引用：
  但是在**ARC和MRC下是有区别**的。**在MRC下使用 _ _ block修饰的变量是弱引用，不会增加对象的引用计数；在ARC下，使用 _ _ block修饰的变量，会增加其引用计数**，这样就导致block持有了_ _ block变量，结构体持有了_ _ block变量，block还持有了结构体，导致了循环引用。所以就有一道痕经典的面试题:

  ```
  {
    __block id * blockSelf = self;
    _block = ^int(int num){
        return num * blockSelf.var;
    };
    _block(3);
  }
  //分析：由于在MRC下，__block修饰的变量不会增加引用计数，所以也就不存在强引用的问题，所以这段代码在MRC下是不会有问题的。但是在ARC下，它是存在循环引用的。所以可以使用断环的方式进行处理：
  {
    __block id * blockSelf = self;
    _block = ^int(int num){
        int result = num * blockSelf.var;
        blockSelf = nil;
        return result;
    };
    _block(3);
  }
  ```
但是这样有个确定，就是必须执行block，否则永远存在循环引用。

* 截获_ _ strong类型的变量导致的循环引用：
由于block对局部auto对象类型的截获变量特性，所以就导致了可能存在的循环引用问题。如果对象类型是 _ _ strong类型的，那么block对其进行截获是会连同所有权修饰符一起截获，也就是说在block内部也是使用了一个 _ _ strong类型的变量强引用了它。所以这就导致了循环引用的问题。所以最好的解决方案就是对截获的变量使用  _ _ weak 的变量去替代它，其次常用的解决循环引用的方法就是断环。

* 处理NSTimer导致的循环引用问题（CADisplayLink也存在一样的问题）：
例如：当前类强引用了timer，timer又强引用了target。所以一般我们都考虑在当前类释放的时候， [ _ timer invalidate]; _ timer = nil; ，使用断环的方式处理循环引用。但是如果不太容易知晓在何处使用invalidate更好的情况下，怎么解除循环引用是一个难点。
```
_ timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(fire) userInfo:nil repeats:YES]; // 这种api默认开启了runloop的。
-(void)fire{
    NSLog(@"fire");
}
// 存在的问题就是NSTimer的target强引用了当前控制器。而当前控制器又强引用了NSTimer，导致循环引用。
```
解决方案一：不使用@selector的方式,使用block，这样就不会对target进行强引用
```
_ _ weakself typeof(self) weakself = self;
_ timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats: YES block:^(NSTimer * _ Nonull timer ) {
    [weakself fire];
}];
```

解决方案二：借助一个中间类（继承自NSObject）,弱引用target，使得NSTimer强引用中间类
```
// 这里可以继承自NSObject
@interface FCFProxy : NSObject
+(intencetype)proxyWithTarget:(id) target;
@property (nonatomic,weak) id target;
@end
@implementation FCFProxy

+ (intencetype)proxyWithTarget:(id) target {
    FCFProxy * proxy = [FCFProxy new];
    proxy.target = target;
    return proxy;
}

// 使用消息转发，将中间类没有实现的selector转发给target
- (id) forwardingTargetForSelector:(SEL)aSelector {
    return self.target;
}

//解析： 借助于中间类，NSTimer就强引用了中间类，而中间类却只是弱引用了self，所以就不会造成循环引用。但是中间类会找不到这个Selector方法。所以可以使用消息转发技术，将函数调用转发给self(也就是中间类的target)
_ timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:[FCFProxy proxyWithTarget:self] selector:@selector(fire) userInfo:nil repeats:YES]; 

同样的，CADisplayLink也可以使用这种中间类的方式去解决循环引用问题。
_ link = [CADisplayLink displayLinkWithTarget:[FCFProxy proxyWithTarget:self] selector:@selector(fire)];
[ _ link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];

```
解决方案三：借助一个中间类（继承自NSProxy）,弱引用target，使得NSTimer强引用中间类
```
// NSProxy 是专门用来做消息转发的。它的子类不保存消息查找和动态消息解析，甚至不存在forwardingTargetForSelector方法。而是直接进入methodSignatureForSelector方法中
@interface FCFProxy : NSProxy
+(intencetype)proxyWithTarget:(id) target;
@property (nonatomic,weak) id target;
@end
@implementation FCFProxy

+ (intencetype)proxyWithTarget:(id) target {
    FCFProxy * proxy = [FCFProxy alloc]; // NSProxy初始化没有init方法，直接alloc就行
    proxy.target = target;
    return proxy;
}

// 直接进入这个方法
- (NSMethodSignature * ) methodSignatureForSelector:(SEL)sel {
    return [self.target methodSignatureForSelector:sel];
}
- (void) forwardInvocation:(NSInvocation * )invocation {
	[invocation invokeWithTarget: self.target];
}

//解析： 理论和方案二是一样的
_ timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:[FCFProxy proxyWithTarget:self] selector:@selector(fire) userInfo:nil repeats:YES]; 

同样的，CADisplayLink也可以使用这种中间类的方式去解决循环引用问题。
_ link = [CADisplayLink displayLinkWithTarget:[FCFProxy proxyWithTarget:self] selector:@selector(fire)];
[ _ link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];

```

[Block原理探究](https://cloud.tencent.com/developer/article/1517593)



### 内存管理

#### 内存布局
从低到高
代码段——数据段(字符串常量-已初始化数据(一般指已初始化全局变量、静态变量等)-未初始化数据(一般指未初始化全局变量、静态变量等))——堆——栈——内核区

#### 内存管理方案
* **TaggedPointer**：对于一些小对象，比如NSNumber、NSDate、NSString。它有可能采用的是TaggedPointer的管理方式进行内存管理的，它是对象指针实际上不指向任何内存地址，而是直接将值存储在了指针本身里，该指针就被拆分成两部分，一部分是直接保存数据，另一部分是作为特殊标记。
  * 注意1：这里说的小对象，指的是对象的值很小，正好可以使用指针位数放下。如果超过了指针的位数，则使用原来的存储方案。比如NSNumbber, 当数值很小时，采用的是TaggedPointer的方式，如果数值非常大，则就又会是普通的存储方式；
  * 注意2：TaggedPointer技术不仅仅是内存方面的优化，使用上也会优化。比如对使用了TaggedPointer技术的对象发送消息时，objc_msgSend内部实际上也做了优化，它不会去走消息转发的流程，而是直接从TaggedPointer内取出它的值。比如：NSNumber *number = @10; [number intValue];
  * 面试题1：下面代码会发生什么？为什么？
  	```
  	@property (nonatomic, copy) NSString * name;
  	
  	- (void)method1 {
            dispatch_queue_t queue = dispatch_get_global_queue(0,0);
            for (int i = 0; i < 10000; i++) {
                dispatch_async(queue, ^{
                    self.name = [NSString stringWithFormat@"abcdefghijklmn"];
                });
            }
  	}
  	
  	- (void)method2 {
            dispatch_queue_t queue = dispatch_get_global_queue(0,0);
            for (int i = 0; i < 10000; i++) {
                dispatch_async(queue, ^{
                    self.name = [NSString stringWithFormat@"abc"];
                });
            }
  	}
  	
  	//答案：method1会在for循环里崩溃。method2不会。
  	method1为什么会崩溃？首先字符串数值比较大，所以它不是TaggedPointer类型，而是直接的对象类型。给name赋值，实际上调用的是setter方法。setter方法底层的实现是：
  	-(void)setter:(NSString)name {
            if (_name != name) {
                [_name release]; //释放老值
                _name = [name copy]; //赋值新值
            }
  	}
  	在setter方法内部，多个线程同时访问，_name就有可能被重复release，从而导致崩溃。
  	解决方案：就是给self.name = [NSString stringWithFormat@"abcdefghijklmn"];前后加解锁。
  	method2不会产生崩溃。因为字符串数值比较小，它实际是一个TaggedPointer，所以给name赋值，不会调用setter方法，从而不会出现上面的问题。
  	所以这道题的本质就是TaggedPointer的区别。
  	```

* **NONPOINTER_ISA**：在runtime章节中有提到isa是指向当前对象所属类的一个指针。一个结构体含有isa指针，那可以说明它是一个对象类型。实际上isa是对应一个isa_t的联合体，在64位架构下，它是由64个0和1的比特位组成。而实际上存储该对象所属类对象地址只需要用到大概33位，所以剩下的位数就可以用来存储其他的信息。
  我们来看看NONPOINTER_ISA的基础数据结构：
  * 第1位：是一个标志位，表示了它是否是一个非指针类型的isa，如果是0则说明它只是一个指针，内部的数据都是对应class的地址，如果是1则表示它是一个非指针类型的isa，内部数据只有部分用于存储class的地址；
  * 第2位：表示当前对象是否有管理对象——Association；
  * 第3位：表示是否使用ARC进行内存管理；
  * 第4~33位：表示当前对象所指向的类对象的地址；
  * 第34~40位：magic数据，表示是否完成初始化；
  * 第41位：表示是否有弱引用指针；
  * 第42位：是否正在执行deallocating操作；
  * 第43位：表示当前对象是否外挂散列表；
  * 剩余的位数：剩余19位都是表示extra_rc，但是注意，存储的是**真实的引用计数值-1**。

* **散列表：SideTables**：也就是在非指针型的isa的引用计数值太大时，则会使用到散列表来对内存进行管理。
  
#### 散列表详解
##### 散列表基础数据结构：
在64位架构下，通常会有64个散列表组成一个全局的SideTables（也是散列表），它类似AssociationMap。里面每个SideTable包含一个自旋锁、一个引用计数表、一个弱引用表。当需要对引用计数进行操作的时候，则通过对象指针作为key值，经过哈希查找定位到对应的散列表，然后进行操作。
```
  // 这个散列表是SideTables里的一个元素。
  struct SideTable {
      spinlock_t slock;			// 自旋锁
      RefcountMap refcnts;		// 引用计数表(散列表)
      weak_table_t weak_table;	// 弱引用表(散列表)
  }
```
* **自旋锁Spinlock_t**： 它是一个“忙等”的锁，也就是说在当前资源被某个线程占用的时候，其他的线程会一直试探该锁有没有解锁，而像信号量，则是会在获取不到资源的时候进行休眠，等资源被释放后，则再被唤醒。它使用与轻量访问。这里之所以要有多个sidetable组成一个sidetables，也是为了提高访问效率。因为每个引用计数的操作都是需要加锁处理，分割成多个表，就可以并行操作。实际上这就是**分离锁**的技术方案；；
* **引用计数表**：引用计数表也是一个hash表，它是通过hash函数插入和获取引用计数，提高访问效率。hash表里的每个元素是一个unsigned long类型的size_t。它也是由64位比特位组成，其中第一位是表示是否有弱引用，第二位表示是否正在执行dealloc函数。剩下的则也是表示**真实的引用计数值-1**。所以取引用计数的时候需要进行向右偏移2位的操作；
* **弱引用表**：实际上也是一个hash表，它存储的是一个weak_entry_t的结构体数组，它里面的每个对象存储的都是一个弱引用指针。作用就是在对象执行dealloc操作的时候将所有指向该对象的weak指针的值设为nil，避免垂悬指针。

#### ARC & MRC
MRC是手动内存管理，ARC是自动内存管理，它通过LLVM编译器和runtime协作在合适的时机给代码添加retain和release等代码，实现自动引用计数的管理。ARC无法显式调用retain和release等函数。
##### 引用计数值相关：
在RAC中可以使用runtime的objc_retainCount(id objc)来获取引用计数。它内部是通过获取到NONPointISA或者散列表里的引用计数值，**并在此基础上进行+1**后将结果返回，所以这也是为什么真正存储引用计数的地方的值都是**真实的引用计数值-1**的原因。
但是实际上不能完全信任objc_retainCount返回的引用计数值，比如说clang会尽可能把NSString实现成单例对象，所以其引用计数会非常大，TaggedPointer对象里的引用计数可能不太准确。

* alloc、new、copy、mutableCopy ：
这四个方法都会使引用计数+1。其内部流程都会调用retain方法。
* retain：新经过hash查找找到对应的sidetable，然后在经过hash查找找到对应的引用计数值，之后获取到引用计数值，进行+1操作；
q1：我们在进行retain操作的时候，系统是怎么查找其对于的引用计数的呢？
是经过两次hash查找，然后进行+1操作。
* release：
同样是经过两次hash算法，获取到存储的引用计数值，然后先判断引用计数是否等于0，如果等于0就将对象标记为正在析构，并发送dealloc消息，返回YES；否则进行-1操作。这样就避免出现负数。以下问题：为什么release只后打印的引用计数还是1呢？
```
Person * p = [Person new]; 
NSLog(@"%d",[p retainCount]);  //1
[p release];
NSLog(@"%d",[p retainCount]); //1
```
原因就是在执行最后一次release操作的时候，真实存储的引用计数值已经是0了，这个时候对象会被标记为正在析构，并执行deallocing，**且并不会对引用计数值进行减一操作**，而retainCount的值是取引用计数表里的引用计数值+1，所以就可能存在返回还是1的情况。

* autorelease：将对象放到AutoreleasePool中，并不是马上释放，而是延时释放；

* **dealloc函数及 _ _ weak指针**:
当一个对象没有任何强引用的时候，就会自动执行dealloc函数进行销毁。执行dealloc时，判断是否可以释放的条件包括：是否使用nonpointer_isa、是否有弱引用指针、是否有关联对象、是否使用ARC、是否使用sidetable。如果这些条件都为NO的时候，就可以直接使用c函数free直接释放，否则则要调用objc_dispose()进行进一步清理。
而objc_dispose则会一步步 移除对关联对象、将指向该对象的弱引用指针置为nil，将当前对象在引用计数表的数据清除掉等操作。(这里解决了两个面试题:1、对象在释放的时候，是否有必要移除掉关联对象；2、weak修饰的对象是怎么讲指针置为nil的。答案就是在dealloc内部实现的时候有做这些操作)

##### 被 _ weak修饰过的对象
q1：系统是怎样把一个weak变量添加到它对应的弱引用表中的。
一个被声明为 _ weak 的对象指针，经过编译器编译，会调用一个objc_initWeak函数，之后会调用weak_register_no_lock()函数进行弱引用变量的添加，具体添加的位置是通过hash算法进行位置查找的，如果查找的对应位置中已经有了当前对象对应的弱引用数组，则把当前变量添加进弱引用数组，如果没有，则重新创建一个弱引用数组。
q2：当一个对象被释放之后，weak变量是怎么被清理的。
会被置为nil。当对象执行dealloc的时候会调用弱引用清除相关函数，在函数内部会通过弱引用指针找到弱引用数组，然后遍历所有的弱引用指针，分别置为nil。

##### _ _ weak & _ _ strong & _ _ unsafe_unretain

```
- (void)method {
    [super viewDidLoad];
    
    __strong Person *person1;   // 通常默认情况下，是__strong修饰，可能会被省略。
    __weak Person *person2;     // 对象被清空后，指针会自动置为nil
    __unsafe_unretained Person *person3;    // 对象被情况后，指针不会自动置为nil，会产生野指针。所以这个基本已经不再使用
    
    NSLog(@"123");
    {
        Person *person = [[Person alloc] init];
        person1 = person;
    } // 如果不把person赋值给任何指针，则person在这里就会销毁；如果把person赋值给__weak和__unsafe_unretained修饰的指针变量，那也是在这里就会销毁。如果把它赋值给__strong修饰的指针变量，那么它将在当前函数结束之后释放。
    
    NSLog(@"456");
}
```



#### AutoreleasePool
添加了autorelease方法的对象会被添加进AutoReleasePool中。AutoreleasePool是用于对延迟释放的对象的内存管理。

```
// AutoReleasePool结构体
struct _AtAutoreleasePool {
    __AtAutoreleasePool() { // 构造函数
        atautoreleasepoolobj = objc_autoreleasePoolPush();
    }
    
    -__AtAutoreleasePool() { // 析构函数
        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    
    void *atautoreleasepoolobj;
}

// AutoreleasePoolPage 结构体
class AutoreleasePoolPage {
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage *parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
}

AutoreleasePoolPage对象占用4096个字节，除了存放基础的内部成员变量，剩下的空间都用来存放autorelease对象的地址。
从AutoreleasePoolPage的结构可以看出AutoreleasePoolPage是通过双向链表的形式连接在一起的。
```



* 首先来看一下AutoreleasePoolPage的内部结构:
  AutoreleasePoolPage是以双向链表的形式连接在一起的，同时每一个AutoreleasePoolPage含有一个pthread的成员。AutoreleasePoolPage是还有一个next指针。在ARC中的实现流程是：当@autoreleasepool{}中，{开始的位置会被编译成AutoreleasePoolPush()，它内部调用了AutoreleasePoolPagePush(),它会在当前page中插入一个标志位，并且返回。在执行{}之间的代码时，会把当前生成的**Autorelease对象**插入到next指针的位置，然后next指针往后移（类似入栈的一个操作，入栈后栈顶指针进行移动）。如果page满了的话，就会生成下一个page。在}结束前，会把push返回的标志位做为AutoreleasePoolPop的入参，然后底层调用AutoreleasePoolPagePop(xx),这个时候就会给标志位与next指针之间的Autorelease对象依次发送release消息同时执行pop操作（类似出栈操作），然后复位next指针位置。

  如果Autorelease对象过多的话，可能就会有多个page用于存放对象。当前正在使用的page称作hot page，不在使用的page称作cold page。

* 注意：
  因为AutoreleasePool的数据结构实际是以标志位插入的方式来实现的，所以无论有多少层嵌套，都只是对标志位进行操作而已。

* Autorelease对象在什么时机会被执行release？

  1、如果Autorelease对象直接在@autoreleasepool{}包裹中。则autoreleasePoolPage执行pop的时候，对autorelease对象执行一次release操作

  ```
  @autoreleasepool {
      Person *person = [[[Person alloc] init] autorelease];
  } // 这里会对person执行release操作
  ```

  2、没有显示放在@autoreleasepool{}里的Autorelease对象执行release则与runloop有关。

* AutoreleasePool与runloop的关系及内存管理：
  AutoreleasePool与线程是一一对应的关系，那么它与runloop自然也是一一对应的关系。在**主线程的runloop**发出**CFRunLoopEntry**通知的时候，会执行一个autoreleasePoolPush()函数，创建一个AutoreleasePoolPush()。其次在runloop的事件循环中，如果监听到了kCFRunLoopBeforeWaiting通知，会先执行autoreleasePoolPop()然后再执行autoreleasePoolPush()函数，相当于释放旧的AutoreleasePool，创建新的AutoreleasePool。然后在runloop退出前，即接收到KCFRunLoopExit通知时，再执行AutoreleasePagePop()释放掉AutoreleasePool。所以从这里可以看出，在Runloop的每一次事件循环期间，也是会对标志位直接的每一个对象发送一次release的，以及时释放掉无用的对象。所以主线程的几乎所有的对象都被AutoreleasePool环绕。

* 什么样的对象会自动加入到AutoreleasePool中？

  Autorelease对象。

  虽然说main函数里有@AutoreleasePool，但是并不是说所有对象都会交给Autoreleasepool来处理。

  * 使用类方法生成的对象（或者说作为方法的返回值的对象），会被自动注册到Autoreleasepool中。比如：id obj = [NSMutableArray array]; 
  * id指针或者对象指针没有显示指定时会被附加上 __autoreleastring修饰符。比如传参过程中的（NSError **）err 就等同于 <#NSError * _Nullable __autoreleasing * Nullable#>。

* **子线程默认不开启RunLoop，那出现Autorelease对象如何处理？会不会出现内存泄漏？**
  在子线程中，如果你创建了Pool的话，产生的Autorelease对象就会交给Pool去管理，如果你没有创建Pool，产生了Autorelease对象，就会调用autoreleaseNoPage方法。在这个方法中，会帮你自动创建一个hotPage(hotPage可以理解为当前正在使用的AutoreleasePoolPage)。然后调用page->add(obj)将对象添加到当前正在使用的AutoreleasePoolPage的栈中，所以这也不会导致内存泄漏。

* main函数的AutoreleasePool有什么作用，可否直接去去掉？
  实际上UIApplicationMain是永远不会返回的，除了系统kill应用，系统会把整个应用占用的内存释放掉。因为UIApplicationMain永远不会返回，所以这里的AutoreleasePool就没有执行pop的机会，所以实际上如果删掉应该也不会有内存泄漏的问题。

* 自动释放池在MRC和ARC中的区别：
  如果函数返回值是对象的话，MRC则需要区分调用者是否拥有这个返回值，如果调用者拥有这个返回值，则调用者就要对其进行释放，如果没有就不需要。比如说：
```
分析：调用者直接拥有返回值。对象初始化时引用计数为1，property是retain的话，赋值的时候，引用计数会加1。 所以即使dealloc的时候，执行[ _ property release]，也会存在内存泄漏。正确的做法是：self.property = [[[NSObject alloc] init] autorelease]; 

错误的：self.property = [[NSObject alloc] init]; 

NSObject * a = [[NSObject alloc] init];
self.property = a;
[a release];
这里因为执行了一次临时变量的release，所以就不会出现内存泄漏问题。
```
在ARC下，则无需考虑这两个返回值的区别。Runtime有对Autorelease返回值进行优化。在ARC下，编译器会在返回值使用objc_autoreleaseReturnValue()代替调用autorelease，使用的时候会使用objc_retainAutoreleaseReturnValue()代替调用retain，最后释放的时候会使用objc_storeStrong()代替release。比如
```
+ (instancetype)createSark {
    return [self new];
}
// caller
Sark * sark = [Sark createSark];
//runtime中变成：
+ (instancetype)createSark {
    id tmp = [self new];
    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease
}
// caller
id tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain
Sark * sark = tmp;
objc _ storeStrong(&sark, nil); // 相当于代替我们调用了release
```
其次使用了objc_autoreleaseReturnValue方法时，runtime会将返回值存储到TLS(线程局部存储器)中，objc_retainAutoreleasedReturnValue则直接去TLS中取出对象。将TLS作为一个中转站来使用了。

* autorelease 对象赋值给weak对象，是否会立即释放？
不会，这种情况会通过objc_loadweak把对象注册到AutoreleasePool中，以延长生命周期。比如：
```
NSNumber  _  weak * number = [NSNumber numberWithInt:100];
NSLog(@"number = %@", number); //这里是可以打印出来的
```

  


### 锁与多线程
#### 进程与线程
* 进程：(线程+内存+文件/网络句柄)
  指在系统中**正在运行**的一个应用程序，是系统进行**资源分配和调度的基本单位**。每个进程都有自己独立的内存空间，每个进程的内存是相互独立的。这里的内存是逻辑内存，指的是虚拟地址空间（虚拟地址空间通过某种映射方法转换成实际的物理地址。所以只要妥善控制映射过程，就能够让单个进程所能访问到的物理地址空间不会跟另一个程序相重叠，达到地址空间隔离的效果。其次在真正的内存使用过程中，每切换一个进程后，虚拟地址空间都得完全映射到物理地址中，如果内存不足，则会先将正在使用内存的其他程序移出以空出内存供当前程序使用。这也是为什么APP容易被后台强杀的原因）

* 线程
  是指进程中一个单一顺序的控制流，是程序执行的最小单位。进程可看做事线程的容器，一个进程可以并发多个线程，每条线程单独执行不同任务，**各个线程之间共享进程的内存空间（包括代码段、数据段、堆等）**，所以线程也不是越多越好，开辟子线程也就意味着消耗更多的内存；其次线程之间的上下文切换也会开销很大。

  线程主要包括：

  - 栈：是指函数的调用栈，从main函数开始，会不断地进行函数调用，每调用一个函数，会把所有参数和返回地址作为一个单元压入栈中；
  - PC计数器：它是用来指向内存中的当前指令的指针。
  - 线程局部存储TLS：是线程所独有的内存空间，可以用来存储线程所独有的数据。(比如iOS的ARC中Autorelease对象作为返回值时有使用TLS作为临时缓存)。

- 线程调度
  当线程数小于等于处理器数量时，是真正的并发，不同的线程运行在不同的处理器上，彼此不相干。但是当线程数量大于处理器数量时，则至少有一个处理器会运行多个线程。
  在单个处理器处理多个线程时，操作系统会让这些线程轮流执行。这些线程的执行过程则是根据线程的状态进行调度。

  - 运行

  - 就绪

  - 等待（阻塞）

    处于运行中的线程有一个时间片的运行时间。刚创建的线程，不会立即执行，会先进入就绪队列；当线程被分配到CPU时间后，线程进入到运行状态；在运行期间，如果碰到非常耗时的操作，则线程会被挂起进入阻塞状态，以让CPU可以执行其他任务。

* 线程优先级
虽然所有的任务按照上述的方法轮流执行，但是有一些非常紧急的任务可能会需要先执行。所以这就需要让优先级高的任务优先执行，或者说让优先级高的任务优先进入就绪状态。但是由于某个优先级低的任务可能就存在饿死（一直得不到执行）的情况，所以优先级得动态调整。
	* 用户指定优先级；
	* 根据进入等待状态的频繁程度提升或降低优先级；
	* 长时间得不到执行而被提升优先级；

#### 进程之间的交互 
通过TCP/IP端口来实现

https://www.jianshu.com/p/534a4a664abd

https://www.zybuluo.com/qidiandasheng/note/1681645

#### 线程之间的交互

https://juejin.im/post/6844904152082939917



多线程是为了实现并发执行的技术。在单核CPU中，操作系统通过分配CPU计算时间来实现软件层面的多线程，在多核CPU中，则直接可以在硬件层面进行多线程运行。
iOS有多种多线程的方案，pthread、NSThread、performSelect、GCD、NSOperation。

#### NSThread和performSelector
* NSThread先创建线程再启动线程，NSThread常用于开启常驻线程
```
//1 创建线程
NSThread * thread = [[NSThread alloc] initWithTarget:self selector:@selector(xxx) objc:nil];
//手动启动
[thread start]; 
// 2 创建线程 自动启动
[NSThread detachNewThreadSelector:@selector(xxx) toTarget:self withObject:nil];
```
* performSelector afterDelay、UntilDone: 含有thread的API可以隐式开启线程。但是其含有delay的API则是使用了线程中对应runloop的Timer，需要开启NSRunLoop才能运行
```
- (void)test {
    NSLog(@"test");
}

- (void)interView05 {
//    NSLog(@"1");
    //这个定时器任务可以直接执行，因为主线程的RunLoop是自动开启的。
//    [self performSelector:@selector(test) withObject:nil afterDelay:0];
//    NSLog(@"3");
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{
        NSLog(@"4");
        //可以立即执行
//        [self performSelector:@selector(test) withObject:nil];
        // 带有afterDelay的API底层用到了NSTimer定时器，定时器是得添加到RunLoop里面工作。而子线程的RunLoop需要手动开起。
        [self performSelector:@selector(test) withObject:nil afterDelay:0];
        /*手动启动runloop 注意run方法只是调用了runMode:beforeDate:方法，添加事件源得另外方法添加，没有事件源，线程仍旧无法保活。这里能够使用run方法让线程保活是因为perform:afterDelay:方法本身就有一个定时器事件源，所以可以直接run开启。若把这行代码放到perform前面则同样无法执行perform的selector，因为那时没有事件源。
         */
//      [[NSRunLoop currentRunLoop] run];
        
        // 另外一种手动启动runloop的方式，先添加事件源，再开启runMode
        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; //添加事件源source0
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; //开启
        NSLog(@"5");
    });
}

- (void)interView06 {
    NSThread * thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@"1");
        // 手动开启runloop，让线程不要立即死掉，才能执行下面的perform UntilDone
        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; //添加事件源
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; //启动
//        这里不能直接用run方法，因为run方法只是调用了runMode，但是没有添加事件源，也可能无法执行下面的perform方法。之前的perform:afterDelay:方法是其本身就有一个定时器事件源，所以可以直接run开启。
//        [[NSRunLoop currentRunLoop] run];
    }];
    //
    [thread start]; //block立马执行
    
    /*
     这个UntilDone是指等thread里的block任务执行完成后才执行Selector。但是如果thread内部不开启runloop，thread就无法保活，当perform执行selector时，thread有可能会退出。
     只调用runloop的run方法有时也会报错： target thread exited while waiting for the perform'
     */
    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];
}

// 这里会产生死锁，当thread start的时候，
- (void)interView07 {
    NSLog(@"1");
    NSThread * thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@"2");
        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    }];
    NSLog(@"3");
    // UntilDone 为YES就会产生死锁，为NO就可以正常运行。（PS：不是很明白）
    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];
    NSLog(@"4");
    [thread start];
}
```
#### GCD
GCD是一个多核并行运算的解决方案，它可以自动管理线程的生命周期，只需要告诉GCD干什么就行。
##### 队列和任务:
* 队列分为**串行**和**并发**：
串行派发是指同一时间一次只能执行一个任务，只有在当前任务执行完成后，才会派发新的任务；并发是指多个任务可以在同一时间同时进行，无需等待前面的任务执行完也可以派发新任务；iOS中主队列mian是一种特殊的串行队列，全局队列global是一种并发队列；

* 任务分为**同步**执行和**异步**执行：
**同步和异步主要影响会不会开启线程**。同步执行是在当前线程中执行，异步执行会在线程池中获取一个线程进行执行，如果线程池中没有则会创建一个新的线程执行；**但是如果是在main队列中，无论是同步还是异步都不会开启新的线程，都是在主队列中执行**。

##### 4种线程组合：
* 同步串行：同步不开启新线程，串行队列让任务一个一个执行。所以它实际不会产生多线程运算；
* 同步并发：并发队列虽然可以并发执行，但是同步执行不开启线程，也就相当于任务只在一个线程中执行，而一个线程一次只能处理一个事件，所以实际也不构成多线程运算；
* 异步串行：异步执行虽然会开线程（注意在main队列依旧不开启线程），但是串行队列中任务一个个执行，所以也不构成多线程运算；
* 异步并发：并发队列可以让任务并发执行，异步执行可以开启多个线程（注意在main队列依旧不开启线程），所以这才会真正实现多线程运算。
```
//eg 01
serialQueue.async{
    serialQueue.sync{
    }
}
// 分析：首先这是在一个串行队列里执行，所以其执行方式必然是一个一个执行。最外层使用异步执行，所以会开辟一个线程；内部的任务是同步执行，所以是在当前线程中执行，且要求立马执行。因为是串行执行，所以内部任务是在外部任务执行完成后才开始执行，而外部任务的执行完成依赖于内部任务也执行完成。所以就导致了死锁！
SerialQueue.sync{
    SerialQueue.async{
    }
}
//分析：同上面的分析类似。使用串行队列，最外层任务是在当前线程中执行，内部任务会开辟新的线程执行，且不要求立马执行。外部任务的执行完成意味着内部任务也执行完成，而内部任务可以在另外的线程中执行完成，所以这个是可以正常运行的！
```
##### 全局队列优先级
创建全局队列时，有一个参数是优先级的标识，所以如果要在并行队列中，让任务先执行，这可以通过设置这个优先级来达到目的（但是这里要注意，先执行并不一定是第一个执行完，它只能保证开始的执行顺序而已）。它的优先级包括（低-高：background（同步备份数据）、utility（需要时间的下载）、default、user-Initiated(用户出发的，如打开文件)、user-Interractive(用户交互，如主线程事件)）

##### dispatch_barrier

dispatch_barrier是指栅栏调用，它的特点是无论是同步还是异步，都会阻塞当前线程，也就是说它会等待所有之前入队的任务都执行完成才开始执行，而在之后入队的所有任务会等待dispatch_barrier本身任务执行完成再执行。
* dispatch_barrier_async与dispatch_barrier_sync的执行效果是一样的，区别就在于：**sync会阻塞后续任务入队，async不会阻塞入队**。但是执行时候的效果是一样的。例如，如果主线程中有打印，则sync会阻塞主线程中的打印，而async不会。
```
ConcurentQueue.sync(flogs:.barrier){
	print("~~~~barrier~~~")
}
print("主线程任务1")； //这行一定是在barrier之后执行；

//ege:
ConcurentQueue.async(flogs:.barrier){
	print("~~~~barrier~~~")
}
print("主线程任务2")；//这句不一定是在barrier之后执行。
```


* dispatch_barrier_async和dispatch_barrier_sync只有在自定义的并发队列中才能有栅栏效果，否则它与dispatch_async或dispatch_sync的作用是一样的，比如串行队列或者系统的全局队列都是无效的。所以它在串行队列中同样容易导致死锁。

* dispatch_barrier实现多读单写
```swift
案例一swift：
A{
    set{
        ConcurentQueue.async(flogs:.barrier){
            _a = newvalue
        }
    }
    get{
    //注意这里使用同步读取
        ConcurentQueue.sync{
            return _a
        }
    }
}

案例二oc：
// 初始化 栅栏调用，必须是自定义的并发队列
@property (strong, nonatomic) dispatch_queue_t queue;
_queue = dispatch_queue_create("rw_queue", DISPATCH_QUEUE_CONCURRENT);

- (void)test {
    //从打印的时间可以看出。读是同时进行的，写是一个个执行
    for (int i = 0; i < 2; i++) {
        [self read];
        [self read];
        [self read];
        [self read];
        [self write];
        [self write];
        [self write];
        [self read];
        [self read];
    }
}

// 读操作，可以同时多个线程同时执行，异步并发。
- (void)read {
    dispatch_async(self.queue, ^{
        sleep(1);
        NSLog(@"%s", __func__);
    });
}

// 写操作，一次只能一个线程执行。
- (void)write {
    dispatch_barrier_async(self.queue, ^{
        sleep(1);
        NSLog(@"%s", __func__);
    });
}
```
##### dispatch_group调度组
dispatch_group可以实现先并发处理一些任务，然后监听所有任务的执行完成。
dispatch_group_async可以异步添加任务到group中，如果无需涉及线程或者队列的话，则可以使用dispatch_group_enter和dispatch_group_leave**配对**执行，比如接口任务。最后使用dispatch_group_notify通知group所有任务已完成。也就是说可以单独使用dispatch_group_async往group添加任务，等执行完成同样会调用notify，比如自己写的请求。那对于已经有队列、异步线程的，则可以使用enter和leave，比如使用第三方请求的时候。

```
{
//注意点：dispatch_group_async与dispatch_group_enter效果是一样的，都是异步添加任务，dispatch_group_enter与dispatch_group_leave必须成对出现，否则group中的任务永远不会完成。
    let group = DispatchGroup()
    DispatchQueue.global().async(group: group, qos: DispatchQoS.default, flags: []) {
      sleep(1000)
      print("任务1")
   }
   DispatchQueue.global().async(group: group, qos: DispatchQoS.default, flags: []) {
      sleep(1000)
      print("任务11")
   }
    
    dispatch_group_enter(group)
    self.request1({
      sleep(1000)
      print("任务2")
      dispatch_group_leave(group)
    })
    
    dispatch_group_enter(group)
    self.request2({
      sleep(1000)
      print("任务3")
      dispatch_group_leave(group)
    })
    
    dispatch_group_notify(group,dispatch_get_main_queue(),^{
        print(finish)
    })
}
```
##### dispatch_semaphore 信号量
dispatch_semaphore俗称信号量，也叫信号锁，用于控制多线程下资源访问的数量。
三个方法：
* dispatch_semaphore_create: 创建一个带有初始值的信号量dispatch_semaphore_t，这个初始值，也可以说是最大并发量，类似NSOperation里的maxCount；
* dispatch_semaphore_wait:  这个方法第二个参数是表示等待时间。一般都使用DISPATCH_TIME_FOREVER，指永久时间。方法执行逻辑是：如果信号量的值 > 0 时，就先让信号量减1，然后继续执行后续代码；如果信号量的值 <= 0时，就会休眠等待，直到信号量的值又 > 0 ，才会继续执行后续代码。 
* dispatch_semaphore_single: 这个方法用于让信号值加1。
```
//1线程同步
let semaphonre = DispatchSemaphore(value: 0)
self.request2({
	print("执行耗时任务，比如接口请求")
	sleep(1000)
	semaphore.signal()
})
print("开始等待")
semaphore.wait(timeout: DispatchTime.distantFuture)
print("任务结束")

//2资源加锁
//创建一个线程，信号量为1，说明一次只允许一个线程同步访问。
let semaphonre = DispatchSemaphore(value: 1)
static int tickets = 100; //100张票
var i = 0
while(i<3){
	//开启了3个线程
    DispatchQueue.global.async({
        //开启并发，每个线程类似一个售票窗口，因为初始信号量是1，这个票始终都只有一条线程访问。
        semaphore.wait(timeout: DispatchTime.distantFuture) //-1
        sleep(1000)
        tickets -= 1 //卖票
        semaphore.signal() 
    })
    i += 1
}

//3改变全局队列里设置好的优先级。
var highQueue = Dispatch.global(qos:.userInitiated)
var lowQueue = Dispatch.global(qos:.utility)

let semaphore = DispatchSemaphore(value:1)
lowQueue.asycn{
    semaphore.wait()
    sleep(1000)
    semaphore,signal()
}
highQueue.asycn{
    semaphore.wait()
    sleep(1000)
    semaphore,signal()
}
//这里lowQueue的优先级更高。
```
**注意**：
在信号量使用过程中对信号量进行重新赋值或者置空操作会crash。在libdispatch源码中，使用一个变量dsema_value保存当前信号量的值，使用dsema_orig保存初始值。执行过程中，当使用wait时会对dsema_value减1，使用signal的时候对dsema_value加1。当我们对信号量进行置空或重新赋值的时候，会调用disponse释放信号量，在disponse函数中如果dsema_value小于dsema_orig，则会直接调用CRASH使程序崩溃。
[dispatch_semaphore](https://juejin.im/post/5cc819cfe51d456e4869548d)

[dispatch_semaphore使用](<https://www.jianshu.com/p/c74e0eb574d6>)

#### Operation：
NSOperation是基于GCD更高一层的封装。它是基于两个概念**操作**和**队列**来实现多线程的。
* **操作**：
  * 操作其实就是对应着GCD的block。但是NSOperation的操作更复杂一些，它可以管理自己的状态和优先级。NSOperation使用其子类来定义操作:NSInvocationOperation、NSBlockOperation、自定义子类。
  * 每个操作都对应着4个状态：isReady(是否就绪)、isExecuting(是否进行中)、isCancelled(是否取消)、isFinished(是否完成)。
  * 单独的操作只在当前线程中执行。
* **队列**：
  * NSOperation的队列有区别于GCD的先进先出的调度队列。NSOperationQueue是根据NSOperation的依赖关系来决定将队列中的哪个Operation置成就绪状态，然后进入就绪状态的Operation的**开始执行顺序**取决于操作之间的优先级；
  * OperationQueue实现了暂停、继续、终止、优先顺序、依赖等操作。
  * NSOperationQueue只提供了两种不同的队列：主队列和自定义队列；主队列运行在主线程之上，自定义队列运行在后台。
  * NSOperationQueue通过设置最大并发量maxConcurentOperationCount来确定其实串行还是并发。

* 如何实现多线程
* 单独的NSOperation使用同步运行，把它放到NSOperationQueue中，然后设置最大并发量大于1就可以实现多线程的运行效果；
##### NSInvocationOperation
单独使用NSInvocationOperation是在当前线程中执行，并不开启线程。将其放到其他线程下面，才会开启新线程
```
//test函数省略， 单独这样使用的话，test就在当前线程中运行，和多线程没有任何关系。也可以将其放到任一一个子线程中运行。
- (void)useInvocationOperation{
	//创建对象
    NSInvocationOperation *iop = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];
    //手动开启
    [iop start];
}

```
##### NSBlockOperation
同样的，**单独的**的NSBlockOperation也是在当前线程中运行，并不会开启子线程。
```
- (void)useBlockOperation{
	//创建对象
    NSBlockOperation *bop = [NSBlockOperation blockOperationWithBlock:^{
		//模拟耗时操作
		[NSThread sleepForTimeInterval:20];
    }];
    //手动开启
    [bop start];
}
```
但是，NSBlockOperation还提供了addExcutionBlock。通过addExcutionBlock可以为NSBlockOperation添加额外的操作。而这些操作(包括NSBlockOperation本身)可以在不同的线程中同步执行，具体哪些线程在其他线程中执行以及开多少条子线程则由系统决定。
```
- (void)useBlockOperationWithAddExcution {
	//创建Block对象
    NSBlockOperation *bop = [NSBlockOperation blockOperationWithBlock:^{
		//模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
    }];
    //添加额外操作1
    [bop addExcutionBlock:^{
        //模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
    }];
    //添加额外操作2,可以添加n个额外操作
    [bop addExcutionBlock:^{
        //模拟耗时操作
		[NSThread sleepForTimeInterval:20];
		NSLog(@"2---%@", [NSThread currentThread]);
    }];
  
    //手动开启
    [bop start];
}
```

##### 自定义Operation
如果想自己控制操作的状态，则可以自定义Operation，自定义的Operation又分为非并行的Operation和并行Operation：
* 非并行Operation：
非并行的Operation只需要实现main函数即可，将操作代码放到main函数里：
```
@interface CustomSyncOpretion:NSOperation
@end
@implementation CustomSyncOpretion
- (void)main{
	if ([self isCancelled] == NO) {
        [Thread sleepForTimeInterval:20]; 
	}
}
@end

//使用
CustomSyncOpretion *cop = [[CustomSyncOpretion alloc] init];
//调用 start 方法开始执行操作
[cop start];
```

* 并行Operation子类
要实现并发的子类则要复杂很多，因为要自己管理操作的状态，所以必须重写以下方法：
	* start ：所有并行的Operation必须重写这个方法，然后在你想要执行的线程中手动调用这个方法。注意：不要调用其父类的start方法；
	* isExecuting：是否执行中，需要使用KVO实现；
	* isFinished：是否完成，需要使用KVO实现；
	* isAsynchronous：该方法返回NO，表示非并发执行。并发执行需要自己定义并返回YES，其后的操作根据这个值来决定是否手动开启子线程；
```
@interface CustomAsyncOperation : NSOperation
@end

@interface CustomAsyncOperation(){
    BOOL excuting; //执行中
    BOOL finished; //已完成
}
@end

@implementation CustomAsyncOperation
- (instanceType)init{
    self = [super init];
    if (self){
        excuting = NO;
        finished = NO;
    }
    return self;
}

- (BOOL)isAsynchronous {
    return YES;
}
- (BOOL)isExecuting {
    return excuting;
}
- (BOOL)isFinished {
    return finished;
}

- (void)start {
	@autoreleasepool{
        if (self.cancelled) {
            [self willChangeValueForKey:@"isFinished"];
        	finished = YES;
        	[self didChangeValueForKey:@"isFinished"];
        	return;
        }
        
        // 任务。。。模拟耗时操作
	    [NSThread sleepForTimeInterval:20];
	    NSLog(@"2---%@", [NSThread currentThread]);
	    [self completeOperation];
    }
}

- (void)completeOperation {
    [self willChangeValueForKey:@"isFinished"];
    [self willChangeValueForKey:@"isExecuting"];
    
    executing = NO;
    finished = YES;
    
    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
}

@end

//使用
CustomAsyncOperation *cop2 = [[CustomAsyncOperation alloc] init];
//调用 start 方法开始执行操作
[cop start];
```

##### 队列
NSOperationQueue中一共有两种队列：主队列、自定义队列。自定义队列同时包含了串行和并发功能。
* 主队列：
凡是放到主队列中的操作，都会放到主线程中执行。(注意：这里不包括addExecutionBlock添加的额外操作，额外操作可能在其他线程中执行)
```
//获取主队列
NSOperationQueue * queue = [NSOperationQueue mainQueue];
```
* 自定义队列：
自定义这种队列的操作，会自动放到子线程中执行。
```
//注意，这里虽然用了上述的操作，但是在Queue里使用就无需手动start了。
NSOperationQueue * cusQueue = [NSOperationQueue new];
[cusQueue addOperation:iop];
[cusQueue addOperation:bop];
[cusQueue addOperation:cop1];
[cusQueue addOperation:cop2];

//直接使用block添加操作
[cusQueue addOperationWithBlock:^{
	//模拟耗时操作
	[NSThread sleepForTimeInterval:20];
}];
```
**队列控制串行并发**
队列使用属性**macConcurrentOperationCount**来控制串行和并发。注意：macConcurrentOperationCount并不表示并发线程的数量，而是一个队列中同时能并发执行的最大操作数。且一个操作并非只在一个线程下完成。macConcurrentOperationCount默认值是-1，表示不进行限制，可进行并发执行，如上代码；值为1时，队列为串行执行；值大于1时，队列并发操作，当然了，最大并发数肯定是无法超过系统限制的。
##### NSOperation操作依赖
NSOperation的操作依赖用来控制添加到队列中的操作进入准备就绪状态。
* addDependency:(NSOperation * ) op;  添加依赖，使当前操作依赖于操作 op 的完成。
* removeDependency:(NSOperation * ) op; 移除依赖，取消当前操作对op的依赖。
* @property (readonly, copy) NSArray<NSOperation *> *dependencies；在当前对象开始执行之前，完成数组里的所有操作对象。
**注意**：操作直接如果相互依赖会导致死锁。
##### NSOperation 优先级
NSOperation的优先级queuePriority属性，进入就绪状态的操作的**开始执行顺序**则是通过优先级属性决定的。
queuePriority包含五种取值：NSOperationQueuePriorityVeryLow、NSOperationQueuePriorityLow、NSOperationQueuePriorityNormal、NSOperationQueuePriorityHigh、NSOperationQueuePriorityVeryHigh。
优先级的属性只适用于同一队列中的操作。

总结：**依赖关系**决定了准备就绪状态，**优先级**决定了开始执行顺序：当一个操作的所有依赖已经完成时，操作会进入准备就绪状态。比如op1、op2、op3、op4四个操作。op3 dependency op2、op2 dependency op1。现在4个操作都添加到队列里，op1和op4都没有依赖，所以都是准备就绪状态，op2要等到op1执行完成后才进入准备就绪状态，op3要等到op2执行完成后才进入准备就绪状态。而同时进入准备就绪状态的操作的开始执行顺序则是由priority决定的。

##### Operation的暂停和取消操作
操作的暂停和取消操作并不代表里面就能将当前操作进行暂停和取消，而是当当前操作执行完毕之后不再执行新的操作。暂停和取消的区别则在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作就会清空索引的操作，后续无法继续。

[NSOperation基础](https://www.jianshu.com/p/4b1d77054b35)
[自定义Operation](https://www.jianshu.com/p/813f7d58935d)
[自定义Operation2](https://juejin.im/post/5d26a7a2e51d45777b1a3e38)


#### GCD VS NSOperation：
GCD是基于C语言实现的，NSOperation是基于GCD实现的！
NSOperation可以添加依赖、优先级、最大并发量，操作可以控制状态，执行暂停和取消等操作。
GCD则有栅栏、group、信号量、单例、延时执行等。在暂停、取消、最大并发量这些操作更不容易实现。

#### 锁

https://juejin.im/post/6844904167010467854

锁主要可以分为三大类：**信号量**、**互斥锁**、**自旋锁**：
锁就是为了防止多个线程同时访问同一资源（这个资源就是指加解锁之间的代码，也叫做临界区），导致数据错乱。加锁之后，线程就无法继续访问，必须等到当前锁解开之后才可以继续使用（独占临界区），即使是同一个线程也无法对资源进行重复加锁，除非是互斥锁。

性能从低到高排列：

* OSSpinLock是自旋锁，自旋锁是忙等的锁，当访问资源（这个资源指的是临界区，也就是开锁-解锁区间的代码）被锁时，线程不会休眠，而是不停地循环等待（从汇编底层可以追踪到，自旋锁的忙等就是使用一个类似while循环一直去试探锁有没有被解开），直到被锁资源被释放，所以自旋锁效率较高。但是存在优先级反转的问题：比如优先级低的线程先获取资源，对资源进行了加锁。此时，优先级高的线程进来发现资源已锁，所以就会不断地循环等待。因其优先级更高，所以CPU会优先被使用。而获取到资源的线程却因优先级更低而没法获取到CPU的使用权限，而导致无法释放资源（也就是开锁-解锁区间的代码无法执行完成）。最终导致优先级更高的线程一直在等待解锁，但是却会一直占用CPU，优先级低的线程获取到资源却没有CPU去执行，而无法释放锁；最终导致相互等待的结果。所以自旋锁已经不再使用了；
	```
	// 使用的头文件是：
	#import <libkern/OSAtomic.h>
	API :
	// 初始化
	OSSpinLock _lock = OS_SPINLOCK_INIT;
	// 尝试加锁
	OSSpinLockTry(&_lock);
	// 加锁
	OSSpinLockLock(&_lock);
	// 解锁
	OSSpinLockUnlock(&_lock);
	```

* os_unfair_lock 用来替换OSSpinLock，但是它并非忙等的锁，等待的过程中也会处于休眠(所以猜想可能是互斥锁)；iOS10开始使用；
	```
	// 使用特殊头文件
	#import <os/lock.h>
	API:
	// 初始化
	os_unfair_lock _lock = OS_UNFAIR_LOCK_INIT;
	// 尝试加锁
	os_unfair_lock_trylock(&_lock);
	// 加锁
	os_unfair_lock_lock(&_lock);
	// 解锁
	os_unfair_lock_unlock(&_lock);
	```

* 信号量查看GCD相关知识点；（推荐使用）

* phread_mutex是互斥锁，互斥锁在访问被锁的资源时，调用线程会进行休眠，此时CPU可以调度其他线程工作，直到资源被释放，此时线程才会被唤醒。
  pthread_mutex可以传入不同参数，实现普通锁pthread_mutex(normal)和递归锁pthread_mutex(recursive)；（推荐使用）
	```
	// 头文件
	#import <pthread.h>
	API:
	// 初始化的过程比较复杂, 得先设置属性，再进行初始化
	// 初始化属性
	pthread_mutexattr_t attr;
	pthread_mutexattr_init(&attr);
	// 设置类型	通常使用的是两种类型normal和recursive。默认是normal类型，表示常规互斥锁，recursive表示递归，表示递归锁。
	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
	
	// 初始化锁, init第二个参数就是传入设置的属性。假如是常规互斥锁，可以直接传入NULL，从而省略上面的设置属性代码。
	pthread_mutex_t lock;
	pthread_mutex_init(&_lock, &attr);
	// 销毁属性
	pthread_mutexattr_destroy(&attr);
	
	// 加锁
	pthread_mutex_lock(&_lock);
	// 尝试加锁
	pthread_mutex_trylock(&_lock);
	// 解锁
	pthread_mutex_unlock(&_lock);
	// 销毁
	pthread_mutex_destory(&_lock);
	```

* NSLock是对pthread_mutex 普通锁的封装；
	```
	// 所有NS开头的类都是继承自NSObject。所以初始化方式都非常简单。
	NSLock *_lock = [NSLock new];
	[_lock lock];	//加锁
	xxx
	[_lock unlock];	//解锁
	```

* NSCondition是对phread_mutex_t + pthread_cond_t的封装；
	```
	// phread_mutex_t + pthread_cond_t
	// API:
	// 初始化条件
	pthread_cond_t _cond; 
	pthread_cond_init(&_cond,NULL);
	// 等待, 锁是普通互斥锁。相当于给lock添加等待条件
	pthread_cond_wait(&_cond, &_lock);
	// 信号，唤醒一个等待中的线程
	pthread_cond_signal(&_cond);
	// 广播，唤醒所有使用到_cond的线程
	pthread_cond_broadcast(&_cond);
	// 销毁条件
	pthread_cond_destroy(&_cond);
	
	// 案例：
	- (void)生产者 {
        pthread_mutex_lock(&_lock);
        NSLog(@"生产一个商品");
        // 发送有商品可卖的信号
        pthread_cond_signal(&_cond);
        // 这里睡眠了1秒，用来假设发出信号之后，lock仍然未解锁。
        sleep(1);
        pthread_mutex_unlock(&_lock);
	}
	
	- (void)消费者 {
        pthread_mutex_lock(&_lock);
        if (没有商品可卖) {
        	// 一进入等待，会先将当前的lock解锁，以便其他地方使用资源时加锁（因为除了递归锁，无法对同一把锁进行重复加锁）。当接收到信号或通知后，则会唤醒当前线程，然后对资源重新进行加锁（为了独占临界区），如果此时的锁还未解锁，则会先等到解锁(比如上面生产者要睡眠1秒后才解锁)。
            pthread_cond_wait(&_cond, &_lock);
        }
        NSLog(@"卖出一个商品");
        pthread_mutex_unlock(&_lock);
	}
	
	// 这个案例假设先调用消费者，再调用生产者。 则消费者如果没有商品可卖就会等待生产者生成商品。所以使用条件锁可以实现类似线程依赖的效果。
	
	// NSCondition 是对pthread_mutex_t + pthread_cond_t的封装
	// 案例：
	@property (strong, nonatomic) NSCondition *condition;
	- (void)生产者 {
        [_condition lock];
        NSLog(@"生产一个商品");
		[_condition signal];
        sleep(1);
		[_condition unlock];
	}
	
	- (void)消费者 {
		[_condition lock];
        if (没有商品可卖) {
        	[_condition wait];
        }
        NSLog(@"卖出一个商品");
        [_condition unlock];
	}
	
	```

* pthread_mutex(recursive) 递归锁；（因为递归锁需要处理，所以效率较低）
	```
	// 递归锁就是上面互斥锁中设置属性是把type设置成recursive
	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
	
	//案例一： 这里用到的lock不是递归锁，而是普通互斥锁，那么程序会存在什么问题？
	- (void)test1 {
        pthread_mutex_lock(&_lock); 
        NSLog(@"%s", __fun__);
        [self test2];
        pthread_mutex_unlock(&_lock);
	}
	- (void)test2 {
        pthread_mutex_lock(&_lock); 
        NSLog(@"%s", __fun__);
        pthread_mutex_unlock(&_lock);
	}
	// 答案：会导致程序卡死(不知道这算不算死锁)。原因就是当线程在test2函数中相对lock进行加锁时，发现lock已经处于加锁状态，而普通锁的话，无法重复加锁（必须独占临界区），所以线程就进入休眠，等待解锁。而想要解锁，就得等test1函数都执行完毕才能解除由test1加的锁。也就是说test1要解锁得等test2执行完成，test2要执行完成得先获取临界区(也就是先加锁)，所以就导致了相互等待的结果。
	// 处理方案：1、test1和test2使用不同的锁。2、使用递归锁。递归锁可以允许统一线程对同一把锁进行重复加锁，而无须等待。
	// 那假设是一个递归的调用过程：则无法使用方案1解决，则只能使用递归锁。
	- (void)test {
        pthread_mutex_lock(&_lock);
        NSLog(@"%s", __fun__);
        [self test];
        pthread_mutex_unlock(&_lock);
	}
	
	```

* NSRecursiveLock是对pthread_mutex(recursive)递归锁的封装；
	```
	// 使用方式类似NSLock
	@property (nonatomic, strong) NSRecursiveLock * lock;
	- (void)test {
        [_lock lock];
        [self test];
		[_lock unlock];
	}
	```

* NSConditionLock是对NSCondition的又一层封装；
	```
	// NSConditionLock是对NSCondition的又一层封装。它可以设置某个条件值，来指定对某个条件的锁进行加解锁操作。
	
	
	// 案例
	// 初始化 这里设置条件值是1，所以只有条件值为1的锁才能加锁成功。假设直接使用init初始化，则默认的条件值就是0。
	NSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition: 1];
    
	- (void)__one {
		[_conditionLock lockWhenCondition:1];
		NSLog(@"%s", __func__);
		[_conditionLock unlockWithCondition:2];
	}
	- (void)__two {
    	[_conditionLock lockWhenCondition:2];
    	NSLog(@"%s", __func__);
		[_conditionLock unlockWithCondition:3];
	}	
	- (void)__three {
		[_conditionLock lockWhenCondition:3];
		NSLog(@"%s", __func__);
		[_conditionLock unlock];
	}
	// 这样就能够让线程之间达到一种依赖，执行顺序必定是：__one ——__two ——__three
	```

* @synchronized是对pthread_mutex(recursive)递归锁的封装；

  

可以看到NSLock、NSCondition、NSRecursiveLock、NSConditionLock都是内部封装的pthread_mutex,都属于互斥锁的范畴。@synchronize是pthread_mutex(recursive)的封装，牺牲了效率，简洁了语法。

  * 什么情况下使用自旋锁比较划算？
  	* 预计线程等待锁的时间很短；
  	* 加锁的代码(临界区)经常被调用，但竞争情况很少发生；
  	* CPU资源不紧张；
  	* 多核处理器；
  * 什么情况下使用互斥锁比较划算？ 
  	* 预计线程等待锁的时间较长；
  	* 单核处理器；
  	* 临界区有IO操作；
  	* 临界区代码复杂或循环量大；
  	* 临界区竞争非常激烈； 



#### 读写安全

* 使用规则。
  * 同一时间，只能有一条线程进行写操作；
  * 同一时间，允许有多个线程进行读操作；
  * 同一时间，不允许既有写操作，又有读操作

* 多读单写解决方案，一般用于IO操作，文件操作：
  * pthread_rwlock; 

    等待的过程中会进入休眠（所以应该是互斥锁的一种）。

    ```
    //  API ：
     // 初始化锁
     pthread_rwlock_init(&_lock, NULL);
     // 读-加锁
     pthread_rwlock_rdlock(&_lock);
     // 读-尝试加锁
     pthread_rwlock_tryrdlock(&_lock);
     // 写-加锁
     pthread_rwlock_wrlock(&_lock);
     // 写-尝试加锁
     pthread_rwlock_trywrlock(&_lock);
     // 解锁
     pthread_rwlock_unlock(&_lock);
     // 销毁
     pthread_rwlock_destroy(&_lock);
     
    案例：
    @property (nonatomic, assign) pthread_rwlock_t lock;
    // 初始化
    pthread_rwlock_init(&_lock, NULL);
    
    // 读操作，可以同时有多个线程同时执行
    - (void)read {
        pthread_rwlock_rdlock(&_lock);
        // 读
        pthread_rwlock_unlock(&_lock);
    }
    
    // 写操作, 一次只能一个线程执行
    - (void)write {
        pthread_rwlock_wrlock(&_lock);
        // 写
        pthread_rwlock_unlock(&_lock);
    }
    
    ```

  * dispatch_barrier_async （参考dispatch_semaphore）




#### 死锁的几种情况

##### GCD产生死锁总结：
**sync函数**往**当前串行队列**中添加任务，就会产生死锁。（因为sync得立马执行，而串行队列任务得一个一个执行，所以就导致新旧任务相互等待的情况）

```swift
//1、串行队列：异步里同步嵌套
SerialQueue.async{
    print(1)
    SerialQueue.sync{
        print(2)
    }
}
//2、串行队列：同步里同步嵌套
SerialQueue.sync{
    print(1)
    SerialQueue.sync{
        print(2)
    }
}
//3、主线程中执行同步操作
viewDidLoad(){
    DispatchQueue.main.sync{
        print(3)
    }
}
//4、NSOperation 线程间依赖
let operaA = Operation()
let operaB = Operation()
operaA.addDependency(operaB)
operaB.addDependency(operaA)

// 5.普通互斥锁的重复加锁，或者递归调用
- (void) test {
    pthread_mutex_lock(&_lock);
    [self test2]; // 重复加锁
    [self test]; //递归调用
    pthread_mutex_unlock(&_lock);
}
- (void) test2 {
    pthread_mutex_lock(&_lock);
    // 执行某个操作
    pthread_mutex_unlock(&_lock);
}
```
产生死锁的四个必要条件：
* 互斥条件：进程所分配的资源不允许其他进程访问。若其他进程访问，只能等待；
* 请求和保持条件：进程获得一定资源后，又对其他资源发出请求，但是其他资源可能被其他进程占有，此时请求阻塞，但又对自己获得的资源保持不放；
* 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完自己释放；
* 环路等待条件：指进程若发生死锁，必然存在一个“进程——资源”之间的环形链

#### 高效使用多线程
* 减少队列切换
* 控制线程数量。一个进程最多开启多少线程？目前我不是很清楚。但是过多的线程及线程调度肯定是非常耗性能的，所以最好的做法是开启和CPU核心数量一样的串行队列，提高CPU使用效率。
* 权衡线程优先级。比如大量图片异步解压过程。应该让查询磁盘的线程优先级高一点，让解压的优先级低一点。
* 主线程优化。比如Cell的复用机制、懒加载机制都能减少CPU的使用

[如何高效使用多线程](https://juejin.im/post/5d3faa9de51d4561f95ee9b7#heading-4)


### 事件及手势
#### 触摸——事件——响应者
* 触摸UITouch：就是一次触摸屏幕。它对应生成一个UITouch对象。多个手指触摸生成多个UITouch对象。在同一个位置双击，则会更新第一次单击的tap count值。每个UITouch对象记录了触摸的时间、位置、阶段、所处视图、窗口等。
* 事件UIEvent：一个触摸事件对应一个UIEvent。当然了UIEvent也可能不对应UITouch，也可能是其他的事件，比如抖动事件。
* 响应值UIResponder：每个响应者都是一个UIResponder对象。比如UIView、AppDelegat等。

#### 事件响应
* 1、手指触碰到屏幕后，将由系统判断决定是否传递给前台APP进程
* 2、APP进程接收到触摸事件后，触发source1回调，主线程的runloop就被唤醒；
* 3、主线程被唤醒之后，source1事件被包装成source0事件，添加到UIApplication对象的事件队列中；
* 4、等到事件出队后，就开始寻找最佳响应者的过程；
* 5、寻找到最佳响应者之后，接下来的事情便是事件在响应链中的传递及响应了；

##### 传递链寻找最佳响应者
**寻找最佳响应者就是遍历传递链的过程：传递链就是由系统向最佳响应者传递的过程**

* 1、事件出队后，UIApplication首先将其传递给UIWindow，如果存在多个Window，则优先传给后显示的window；
* 2、若该window不能响应事件，则将事件传递给其他window。若该window能响应事件，则从后往前询问窗口子视图；
* 3、子视图中，若能响应，则自下而上传递，若其子视图不响应，则自身是最合适的响应者。若不能响应，则传递给其同级的前一个兄弟视图；
* 4、重复第3个步骤，直到找到最佳响应者后，然后将其回溯返回给UIWindow。
##### 响应链最终处理事件
响应链是由事件响应的view向底层系统传递
**首先每个响应者都有一个nextResponder方法，用于将事件传递下一个响应者：若UIView是视图控制器的根视图，则其nextResponder是视图控制器，否则其nextResponder是其父视图；若视图控制器是window的根控制器，则其nextResponder是UIWindow，否则是其前一个控制器；UIWindow的nextResponder是UIApplication；UIApplication的nextResponder是AppDelegate。**

其次每个响应者都有4个默认实现的响应事件触摸的方法：touchBegan:withEvent:、touchMoved:withEvent:、touchEnded:withEvent:、touchCancelled:withEvent:。**事件最终就是通过这些方法像最佳响应者传递的**。所以重写touchBegan:withEvent也能够让事件不再往下传递，或者对事件进行一些额外的处理。

* 如何判断是否能响应？
每个UIView都有一个hitTest:withEvent方法，该方法返回一个能响应的UIView对象。比如：事件传递到UIWindow，UIWindow执行hitTest:withEvent:判断自身能否响应事件，若可以，则调用子视图的hitTest:withTest:将事件传递给子视图，并在子视图中查找最佳响应者。找到了之后就回溯给UIApplication一个最佳响应者视图。
hitTest:withEvent:方法的判断标准包括：是否允许交互、是否隐藏、透明度是否小于0.01，若这三个条件都通过，则会判断触摸点是否在当前视图的坐标系范围内。

* 如何判断触摸点是否在当前视图坐标系范围内？
  pointINside:withEvent:方法用于判断触摸点是否在自身坐标范围内，返回一个bool值。如果为No，则hitTest返回nil，如果是YES，则向当前视图的子视图发送hitTest方法，所有子视图的遍历顺序是按照subviews数组的末尾向前遍历。其次要注意的是判断的时候都得以自身坐标系为准，所以应当使用covertPoint:toView:先进行坐标系转换。所以一般项目中碰到扩大按钮点击区域、tabBar凸出的按钮点击不响应等问题，则可以重写pointInside:withEvent:方法。

###### UIResponder、UIGestureRecognizer、UIControl同时存在时，会怎么响应？
  * **手势识别器比UIResponder的响应优先级更高**。Window在将事件传递给最佳响应者之前，会将事件先传递给最佳响应者视图对应的视图控制器的手势识别器中。若手势识别器成功识别了事件，则就会将touchBegin/Move/End等回调打断，然后将UIGestureRecorognizer标记为待处理。Observe检测到BeforeWaiting事件后，会回调获取刚被标记成待处理的UIGestureRecorognizer，并执行UIGestureRecorognizer的回调；如果手势有变化过程，则回调也会进行对应处理。
  * **UIControl比手势识别器的响应优先级更高**。比如UIButton。

[触摸事件全家桶](https://www.jianshu.com/p/c294d1bd963d)


### 网络相关
#### HTTP：
http其实就是超文本传输协议，它主要包括请求报文和响应报文两部分组成。请求报文包括：方法(get、post)、url、http版本、首部字段(媒体类型、Encode编码格式、认证信息等)、实体主题；响应报文包括：http版本、状态码、首部字段(accept_range字节范围、时间、重定向URI)、实体主题。

**状态码**：2xx、3xx、4xx、5xx，200请求成功，301、302一般是重定向问题、404一般是网络问题、504一般是指服务器问题。

**http的特点**：无连接（也就是每次请求连接都需要经历连接和断开的过程）、无状态（同一个用户在多次发送http请求时，server端并不知道是同一个用户发送的）

**持久连接**：应对http无连接特点。指在一定时间范围内不需要反复进行握手和挥手动作。http提供的持久连接的方案就是修改请求头部字段，比如connection: keep-alive(客户端期许采用持久连接)、time:20(持久连接时间)、max：10(这条连接最多可以发生多少次请求和响应对)。
那怎么判断持久连接中的一次连接已结束呢？1)通过响应头部字段：content-length:1024来判断。2)还有就是最后一个报文的chunked字段是否为空来判断。

#### Session/Cookie

应对http无状态特点，指多次发送同一个请求，server端无法知道是否是同一个用户。
**Session**是服务端用来认证和追踪用户的数据结构。它通过判断客户端传来的消息来确定用户。确定用户的唯一标识是客户端传来的Session ID。实际上也是在客户端第一次请求的时候会生成一个SessionID，然后放到响应头部字段的set-Cookier的头部字段，然后客户端之后的每一次请求都在头部的cooiker带上SessionID字段。server端通过SessionID来验证是否是真实用户。它默认存储在服务器的一个文件里，当然也可以存储在内存、数据库里。

**Cookie**主要是用来在客户端保存用户信息，区分用户的；主要操作就是初始会话时，server端生成一个Session ID，HTTP协议会在Cookier头部字段记录这个Session ID，然后客户端接收到之后进行存储，之后每次请求都会把Session ID发送给服务器端。server端通过Cookier来判断用户登录状态。所以一般传输过程中也需要对Cookie进行加密，设置Cookie为HTTPOnly防止跨站脚本攻击。

**Charles的抓包原理**：利用了http中间人攻击漏洞进行抓包，中间人就是模仿客户端和server端的所有操作。

#### HTTPS
**HTTPS**：HTTPS = HTTP + SSL/TLS。
HTTPS连接的建立流程：客户端先向server发送一个SSL版本及支持的加密算法和随机数C，server会返回一个选定的加密算法、随机数S、server端证书。客户端接收到后会先验证server证书（也就是server端公钥），然后通过C、S、预组秘钥组装成会话秘钥，之后通过server端公钥对预组秘钥进行加密发送给server端，server端则通过私钥解密预组秘钥，然后通过C、S、预组秘钥组装会话秘钥。然后客户端和server端相互发送一个加密消息，验证安全通道是否建立完成。
HTTPS都使用了哪些加密手段？
对称加密和非对称加密。非对称加密在公私钥中使用到，传输过程中则是使用对称加密。
什么是非对称加密和对称加密？
非对称加密包含两个概念：公钥、私钥。加解密使用的钥匙不一样的。用公钥加密，就得用私钥解密；私钥加密就得用公钥解密。
对称加密：加解密用的是同一个秘钥。

Q：如何使用Charles抓取Https协议，原理是什么？

首先Charles是根据中间人攻击的方式来抓取网络请求的。具体过程就是：Charles拦截客服端发往服务端的网络请求，然后再往服务端发送请求，服务端返回的响应数据，Charles也会再截取之后往客户端发送。一句话**Charles就相当于同时干了server端和客户端的所有事情**。而HTTPS又是怎么拦截呢？首先原理是一样的，其次HTTPS较HTTP多了一个TLS协议，要支持HTTPS协议的服务器也必须去CA申请一个证书，然后客户端校验通过后才会建立起连接通道，所以Charles想要拦截HTTPS协议，也必须先去CA申请一个证书（过程就是用手机浏览器访问charlesproxy.com/getssl,安装好证书。然后Charles需要在SSL Proxying添加上APP的访问域名和端口号，注意**端口号是443**）。然后使用的过程中手机需要先去设置里信任证书。意思就是客户端安装的是Charles服务器的CA证书，Charles安装的是服务器的CA证书。

Q：HTTPS的验证证书怎么做的

Q：HTTP1.x和HTTP2的主要区别？
* HTTP2采用二进制格式，HTTP1是文本格式。二进制格式更健壮；
* HTTP2有多路复用，即共享连接，相当于每个连接上可能会有多个request；
* HTTP2的head会进行压缩缓存。HTTP1则每次都会重复发送；

#### Get和Post的区别：

Get请求的参数通过？拼接在URL后面，post则放在Body里面。然后Get是安全的、幂等的、可缓存的，Post是非安全的、非幂等的、非可缓存的。安全性是指是否会引起server端的变化，幂等是指一种请求方法执行多次的结果是否完全相同，可缓存的是指代理服务器是否会进行缓存。

#### TCP/UDP

**UDP**：用户数据报协议。
UDP特点：无连接、尽最大努力交付（不保证可靠传输）、面向报文(既不合并报文也不拆分报文，会原封不动传输报文，只是在运输层会拼装一个UDP首部)；
UDP提供的功能：复用(就是不同的端口都可以复用传输层UDP数据报)、分用(接收到数据报后，会根据目的端口进行分发)、差错检测(就是发送方通过某种方式对数据报中的数据进行计算，然后将得出的结果插入到UDP首部传输给接收方，然后接收方接收到数据后，运用相同的方式进行计算，然后对比接收到的数据，进行差错检测。)

**TCP**：传输控制协议。则需要建立连接。

TCP特点：面向连接（数据传输开始和结束需要建立和释放连接）、可靠传输（无差错、无重复、按序到达）、面向字节流、流量控制、拥塞控制。

**三次握手**：客服端向server端发送一个请求报文，server端接收到请求报文后会发送一个确认响应报文同时也附带一个建立连接的请求报文，客户端收到server端发来的请求报文后再会给server端一个确认报文。

**四次挥手**：客户端向server端发送一个请求断开连接的报文，server端收到后会返回一个确认报文（这样客户端对server的连接就断开了），然后server端向客户端发送一个断开连接的请求报文，客户端收到后回复一个确认报文（这样server端对客户端的连接也断开了）

**实现细节**：TCP的连接是全双工的，即连接双方的读写可通过一个连接来进行，所以这也是必须4次挥手的原因。连接过程中，**发送端和接收端都有一个数据缓冲区**。发送方连续发送的多次写操作的数据会先被放入TCP的发送缓冲区，当数据真正需要发送时，缓冲区的数据则可能会被封装成一个或多个数据包发出，具体实现则要看滑动窗口的设置。接收端接收到一个或多个TCP报文后，则会按照TCP报文的序号将其有序放入到接收端缓冲区中。接收端应用也通过滑动窗口的设置来读取一段完整有序的数据。

**TCP头部**：TCP头部最长是60字节，头部包含的信息有：字节编号、端口号、确认号、标志位（ACK标志、SYN标志、FIN标志、PSH标志（提醒应用层从缓存区读取数据））、16位窗口大小（控制流量）、16位校验和（差错检测）。

Q1:为什么是3次握手，而不是两次？
假如客户端发送建立连接的请求报文发生了超时，客户端会启用超时重传策略，重新发送连接请求，Server端收到了会回复确认报文，那之后又收到了之前超时的请求连接，，服务器又会返回确认连接的报文。如果没有第三次握手，那么这样就会又建立一次连接，相当于建立了两次连接。而多了那次客户端确认报文的话，服务器发送第二次确认报文后，客户端不会返回第三次握手，那么后面那次连接就建立不起来。

Q2、为什么是4次挥手，要分别断开两个方向的链接？
因为TCP建立的是一个全双通的链接，就是无论从客户端到server端，还是server端到客户端，都可以建立单独的发送与确认接收的通道，比如说在4次握手中，如果仅仅是进行了前两步（断开了客户端到server端的链接），那么此时客户端是不能向server端发送数据的，但是server端依旧可以向客户端发送数据。

Q3 、怎么保证可靠传输的？
可靠传输是通过**停止等待协议**来实现的。它是包括4方面的：

无差错情况：就是每次报文的传输中，server端收到后都会返回一个确认报文。

超时重传：那如果超时了，也就意味着在这个时间范围内，server端没有收到报文，也自然没有返回确认报文，那客户端就会进行重新发送。

确认丢失：是指server端返回的确认报文丢失了，那么同样的，客户端没有在时间限定内收到确认，所以会进行重新发送。server端会将第一次接到的报文丢失掉。

确认迟到：指确认报文迟到了，客户端同样会进行确认丢失一样的操作。

Q4、面向字节流?
是指TCP并不是原封不动地将发送方发送的字节一次性地完全地传输给接收方，而是会根据实际情况对字节流进行**拆分或合并**，然后再进行发送。和UDP的面向报文的方式正好相反。

Q5、怎么做到流量控制、按序到达？
通过**滑动窗口协议**实现。TCP的发送方和接收方都有一个缓存区域，缓存区域的数据都是有序的，可以把它当作是有顺序编号的。在发送方，有一个类似滑动窗口用于从缓存数据里取一个有序序列往接收方发送；为了避免接收方数据溢出或因网络问题导致大数据无法发送，接收方在每一次接收完成后会在确认报文里返回一个数据，告诉发送方当前可以接收的数据。同时发送方在每次发送完成收到确认报文后会将已发送的最后字节标记，然后按照确认报文里的数据来确定滑动窗口的大小，比如说缓存区有1~9个数据，1~5是已经发送完成的，这个时候接收方接收到前三个数据后，表示由于网络环境较差，只能接收2个字节，那么就会在确认报文里返回2，这样滑动窗口的大小就变成了2。一句话说就是通过接收方来动态调节发送方的发送速率。这样就可以做到流量控制！

同样的，接收方的缓存区，如果接受到了1、2、3、6编号的数据，那么它只会对按序到底的下一个期望到底的字节进行标记，这里也就是4，而往应用层发送已排序好的1、2、3序列部分，那如果后面又接收到了非期望值的数据，则不会处理。这样就做到了按序到达！

Q6、拥塞控制：
**慢开始、拥塞避免**：一开始先发送一个报文，如果没有发生拥塞，则翻倍发送2个，然后再4个、16个(指数增长的方式)。一直达到窗口的门限初始值为止；然后再通过拥塞避免的策略，以线性增长的方式发送报文，可能达到某个值得时候，就产生了网络拥塞（比如连续3个报文没有收到确认报文），此时就重新开始采用拥塞避免的乘法减小的策略，只发送一个报文，同时将门限值降低，然后重新开始“慢开始”。

**快恢复、快重传**：是指在达到拥塞时，回到新的门限值，以线性增长的方式发送报文，而不经过前面指数增长的慢开始阶段。

Q7：为什么不直接用TCP，而要用HTTP？

TCP是建立在传输层上的协议，HTTP是应用层协议。TCP主要是用于建立传输通道的，HTTP则是建立在TCP的连接通道之上进行数据收发的。

#### DNS解析：
DNS解析过程？
DNS服务器是提供域名到IP之间的解析服务，一般计算机就是一个IP地址，但是纯数字不符合人类的记忆习惯，所以一般会有一个域名，比如www.baidu.com ，当我们代码对某个域名发起访问的时候，则要通过DNS解析，找到对应的IP，然后再进行访问 。一般DNS解析都是有运营商进行管理，比如移动的卡发出来的访问，先经过移动运营商，然后移动运营商找到对应的ip，然后进行访问。
DNS采用UDP数据报文，53端口号，且明文。

DNS解析查询方式：
1、递归查询：按照 本地DNS——根域DNS——顶级DNS——权限DNS的层级一层层递归查找；
2、迭代查找：先查询本地DNS，然后本地DNS依次询问根域DNS、顶级DNS、权限DNS；
DNS劫持问题？
因为DNS是UDP明文传输，就有可能被钓鱼DNS劫持，返回错误的IP地址。
DNS劫持与解析都与http无关，它是发生在http之前的操作。
解决DNS劫持：
1、httpDNS：实际上DNS解析是指DNS协议向DNS服务器的53端口进行请求，采用HTTPDNS这种方式则是直接通过http协议向DNS服务器的80端口进行请求，这样实际上就不存在DNS解析了，所以也就不存在DNS解析问题了。比如：http://119.29.29.29/d?dn=www.baidu.com&ip=163.177.153.109 (其中http://119.29.29.29/d 是国内最大的DNS域名服务器，dn=www.baidu.com 是需要解析的域名，后面是本地IP地址)
2、长连接：
客户端采用 长连server 从API Server通过内网专线获取IP的方式

DNS解析转发问题？
是指DNS解析服务器为了节省资源，将解析请求发送给其他DNS域名服务器，依次转发，最后返回的IP地址可能不是同一运营商的网络，存在跨网访问的可能，造成一些请求缓慢等效率问题。



### socket
socket是对TCP/IP协议的封装，它本身并不是协议，而是一套API，通过socket才能使用TCP/IP协议，它包含了：连接使用的协议、本地主机IP、本地进程协议端口、远程主机IP、远程主机协议端口等信息。
IP地址：用于区分哪一台机器需要建立连接；
端口号：用于区分哪一个应用需要建立连接；
socket通信报文一般分为报头和正文。报头一般包含：操作指令用于解开正文、正文长度、报文认证信息等。
#### socket与http：
* http
HTTP是超文本传输协议，建议在TCP协议之上的应用层协议。HTTP请求时在数据需要更新时由客户端发送网络请求到服务端，请求结束后会主动断开连接。由于这种每次建立连接到关闭都是一次性连接，所以HTTP也被称为短连接。
* socket
socket可以支持不同的传输层协议(TCP、UDP)，当使用TCP时，socket连接就是TCP连接。Socket是长连接、双向通信的，建立连接后客户端和服务端会一直连着，当有数据更新时，服务器会直接发送给客户端，不需要客户端主动请求。当然了，在连接过程中,长期不活跃的连接有可能被系统断掉，为了保证连接不断开，客户端也会定时不间断地发送心跳数据，如果连接断了，则需要自己手动重连。

#### socket粘包和半包处理：
如果socket是TCP连接，则就可能涉及到粘包和半包问题。粘包就是多组数据被一并接收了，粘在一起，无法划分。半包就是数据不完整，无法处理。解决的方式：在socket通信报文的头部的信息中，会约定好一个字段专门用于描述数据包的长度，这样就使数据有了边界，依靠这个边界，粘包的数据就能划分出来，半包的数据也能知晓数据的缺失。

#### socket Net打洞：
* 什么是NAT穿透技术？
  NAT叫做网络地址转换，主要是将内部的私有IP转换成可以在公网使用的公网IP；

* 打洞流程：

  1、客户端A、B分别发送消息给服务器S;

  2、S转发A的IP+port给B，同时也转发B的IP+port给A，使得A、B都知道对方的IP+port；

  3、A直接发消息给B，此时B会屏蔽这条消息，但是也让A的NAT映射中加上了一条映射，允许接收来自B的消息。所以B——>A打洞成功

  4、B发消息给A，由于A能接收到这条消息，同时B的NAT映射上也添加了一条可以接收来自A的消息的映射。此时A——>B打洞成功。

[swift socket实战](https://www.hangge.com/blog/cache/detail_756.html)

[最详细网络协议](https://blog.csdn.net/kyl282889543/article/details/99670768)

### 数据库
#### SQLite基础语句学习
SQLite数据库中有一个sqlite_master的表，它定义数据库的模式，可以在其上查询以获取所有表的索引。
* 创建表：先判断表是否存在如果表不存在就新建：
```
CREATE TABLE IF NOT EXISTS User(uid interger primary key, uname varchar(20),mobile varchar(20))
```
* 查询表：
```
SELECT count(*) FROM sqlite_master WHERE type="table" AND name="查询的表名"
```
* 获取某张表的建表语句
```
SELECTF sql FROM sqlite_master WHERE type="table" AND name="查询的表名"
```
* 获取表中的所有列名
```
PRAGMA table_info([查询的表名])
```
* 插入数据
```
INSERT INTO User(uid, uname, mobile)
```
* 更新数据
```
UPDATE 
```
* 删除数据
* 
Demo
```
//获取数据库实例
let db = SQLiteDB.sharedInstance

//打开数据库
        _ = db.openDB()
//如果表还不存在则创建表（其中uid为自增主键）
let result = db.execute(sql: "create table if not exists t_user(uid integer primary key,uname varchar(20),mobile varchar(20))")

//查询表
let result = db.query(sql: "SELECT count(*) FROM sqlite_master WHERE type=\"table\" AND name = \"t_user\"")
print("result：\(result)")
//结果判断
if result.count > 0 && result[0].count > 0 {
    print("存在t_user表!")
}else{
    print("不存在t_user表!")
}

//获取某张表的建表语句
let result = db.query(sql: "SELECT sql FROM sqlite_master WHERE type=\"table\" AND name = \"t_user\"")
//输出结果
print("---查询结果---\n\(result)")
print("---建表SQL---\n\(result[0]["sql"]!)")

//获取表中的所有列名
let result = db.query(sql: "PRAGMA table_info([t_user])")
//结果判断
print("---查询结果---\n\(result)")
//提取列名
print("---共\(result.count)列---")
for column in result {
    print(column["name"]!)
}

//搜索
let data = db.query(sql: "select * from t_user")
if data.count > 0 {
	//获取最后一行数据显示
	let user = data[data.count - 1]
	txtUname.text = user["uname"] as? String
	txtMobile.text = user["mobile"] as? String
}

//插入数据库，这里用到了esc字符编码函数，其实是调用bridge.m实现的
let sql = "insert into t_user(uname,mobile) values('\(uname)','\(mobile)')"
print("sql: \(sql)")
//通过封装的方法执行sql
let result = db.execute(sql: sql)
print(result)

```

#### 事务
事务是指一个操作序列，这些操作要么执行，要么不执行。比如说转账：从一个账号里扣款，使另一账号增款。这两个操作要么执行，要么不执行。
事务是数据库维护数据一致性的单位，每个事务结束时，都能保持数据一致性。
事务的基本特征：
* 原子性：指事务中的所有操作，要么全部成功，要么全部失败；
* 一致性：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态；
* 隔离性：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立；
* 持久性：事务结束后，事务处理的结果必须能够得到固化；
#### Realm学习：
#### FMDB学习:

<https://www.hangge.com/blog/cache/detail_2318.html>

<https://juejin.im/entry/5a1d44a6f265da432f30dd09>

https://www.jianshu.com/p/4ec2b334fed2


### 加解密
加密解密主要是为了解决数据安全的问题。比如使用POST请求，因为POST请求数据放在body里面相对get直接将参数暴露在外部更安全一些，其次使用HTTPS，对接口进行加密。
数据安全基本原则：
* 在网络上不允许传输用户隐私数据的明文；
* 在本地不允许保存用户隐私数据明文；
#### 常用加密方法
* 编码方案：Base64:
可以将任意二进制数据进行Base64编码，所有的数据都能被编码为只用65个字符A~Z a~z 0~9 + / =）就能表示的文本文件；
* 哈希函数：
	* MD5摘要算法：
	对相同的数据进行加密，得到的结果是一样的；对不同的数据进行加密，得到的都是32位的定长字符串；其结果是不可逆的，也就是只能加密，不能解密；
	但是现在的MD5已不再安全，可以被暴力破解。所以可以使用“加盐”的方案来增加解密的难度。比如，在明文里插入随机串，再进行MD5；也可以对明文进行乱序或多次MD5等。或者使用最新的SHA-2算法。
	**哈希函数其实就是对数据内容进行计算，算出一个散列值，这个散列值就用来校验信息的完整性**。
* 对称加密算法：
	* DES：数据加密标准
	* AES：高级加密标准
	**对称加密的特点就是加密/解密使用相同的密钥**；加密和解密的过程是可逆的；加密的过程是先加密再base64编码，解密的过程是先base64解码再解密。
* 非对称加密算法：
	* RSA：
	**非对称加密的特点：使用公钥加密，使用私钥解密，或者使用私钥加密，使用公钥解密**；公钥是公开的，私钥是保密的。加密安全，但是性能消耗较大。
* 数字签名：
信息的发送者用私钥加密，接收者用公钥解密。也就是说私钥加密的密文只能用公钥来解密，所以叫做数字签名，通常用于身份认证。证书就是经由CA机构数字签名之后的公钥证书，用于身份认证。
* HTTPS：HTTP+TLS：略
总结：
对称加密：甲方使用某一个密钥对信息进行加密，乙方也使用同一套密钥对信息进行加密。但是密钥的保存和传递就成了最头疼的问题；
非对称加密：乙方生成两把密钥(公钥和私钥)。公钥是公开的，任何人都可以获取，私钥是保密的。甲方获取乙方公钥，然后用它对信息进行加密。乙方得到加密后的信息，使用私钥进行解密。甲方获取到乙方的信息后也可以直接用公钥去解密私钥加密的数据。

#### TLS协议
TLS协议就是HTTP协议中的‘S’。TLS协议可以对传输内容进行加密、进行身份验证、避免传输内容串改。TLS协议包括TLS握手协议和TLS记录协议。TLS握手协议使用到的加密手法包括：非对称加密、散列函数、数字签名技术；TLS记录协议使用了对称加密、散列函数等技术。
##### 

#### 通常的做法：
* 1、使用Base64防止数据明文传输；
* 2、对普通请求可以使用MD5进行数据完整性校验；
* 3、对于重要的数据，使用RSA进行数字签名；
* 4、对于敏感的数据，客户端使用RSA加密，服务器返回DES(AES)加密；
* 5、想要安全的数据传输，使用HTTPS。但是最好加上双向验证防止中间人攻击；

[ios常用加密手法](https://juejin.im/post/5d9f41f16fb9a04e1e7bb17b)

### 动画
动画就是由一帧帧画面组成的。
基于iOS系统的屏幕刷新率是60FPS，也就是每秒60帧画面，每一帧相当于16.7ms。
动画的本质就是在一段时间间隔内，对象的位置、形状、透明度等属性随着时间变化的过程。
而负责动画操作的则是CALayer，CALayer的作用主要是为了内容展示和动画操作。
#### 逐帧 和 关键帧
iOS的动画主要分为两大类：逐帧动画 和 关键帧动画：
##### 逐帧动画：
**就是对过程中的每一帧画面进行绘制**

实现方式就是周期性地调用绘制方法，绘制每帧的动画对象。这里的周期性使用的是CADisplayerLink，即屏幕每次刷新都进行调用。
##### 关键帧动画：
理论上就是提供关键节点，比如起始点、中间点、终点等关键位置，其他的过度位置就交由计算机自动生成。
一般我们提供起始帧、结束帧、动画时间、匀速运动；起始帧和结束帧是我们设定的，其他的过渡帧是系统生成的。CALayer的同一个属性值，会分别保存在模型层和展示层。当我修改一个属性值时，修改的是模型层的数值，动画时系统根据模型层的变化生成过渡值，将其保存在展现层中。执行的过程：

* 1、动画前，显示模型层的当前值；
* 2、动画开始，切换显示展示层的值；
* 3、动画过程中，展示层的值会随着时间变化，我们看到的实际是展示层的值在变化；
* 4、动画结束时，切换回显示模型层的值。此时的模型层的值也被修改为动画结束时展示层的值。
代码实现：
```
UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    view.backgroundColor = [UIColor redColor];
    [self.view addSubview:view];

    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"position"];
    animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(50, 0)];
    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 0)];
    [view.layer addAnimation:animation forKey:nil];

//    view.frame = CGRectOffset(view.frame, 100, 0);
```
解析：
这里注释了最后一步，也就是动画结束的设置，所以动画结束后又回到了原来的位置。

#### 隐式动画
**我们显式地给CALayer添加动画的方式叫做显示动画，比如上面的逐帧和关键帧动画。而如果我们改变CALayer的一个可动画属性值时，就会触发系统的隐式动画**
比如，我们修改CALayer的frame。只是UIView对应的CALayer，系统关闭了隐式动画，所以修改UIView的CALayer的相关属性时，变化是直接生效的，没有动画效果。
所以如果我们做逐帧动画时给一个单独自建的CALayer变换frame，那么也会触发系统的隐式动画，这个时候就需要我们手动关闭隐式动画。

UIView的一系列animationWithDuration等动画方法。在这些方法中UIView的CALayer都会恢复隐式动画，所以在block中修改属性时，会触发隐式动画。

#### 相关类
* CAAnimation : 核心动画基础类，不能直接使用；
* CAPropertyAnimation : 属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用;
* CAAnimationGroup : 动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行;
* CATransition : 转场动画，主要通过滤镜进行动画效果设置;
* CABasicAnimation : 基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态;
* CAKeyframeAnimation : 关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制;

基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画;
隐式属性动画的本质是这些属性的变动默认隐含了CABasicAnimation动画实现;


#### 总结：
* 关键帧动画的实现，只需要修改某个属性值就可以；
* 逐帧动画则绘制过程复杂、开销较大；
* 我们平时开发中使用UIView的隐式动画更多一些；


[动画1](<https://www.jianshu.com/p/13c231b76594>)
[动画2](https://www.cnblogs.com/iOS-mt/p/4194575.html)


### 编译连接
#### 编译型和解释型语言的区别：
* 编译型语言：先将代码经过编译器先编译成机器代码，然后再执行。所以每次修改完代码都得先编译，才能执行结果。优点就是**代码执行效率高**，缺点就是**编写调试周期长**。我们也称这种执行方式为“**AOT预先编译**”
* 解析型语言：不需要经过编译。执行的时候，通过一个解释器将代码解释成cpu可以执行的代码（实际上就相当于一边编译一边执行）。优点是**编写调试方便**，缺点是**执行效率不够高**。我们也称这种方式为“**JIT即时编译**”

#### OC的编译连接过程
OC和swift都是编译型语言。通过LLVM将代码转成机器码，主要的流程包括：
#### 0、查看编译过程
```
$clang -ccc-print-phases main.m
0: input, "main.m", objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, ir
3: backend, {2}, assembler
4: assembler, {3}, object
5: linker, {4}, image
6: bind-arch, "x86_64", {5}, image
```


##### 1、预编译：
**主要是处理源代码中以“#”开头的预编译指令**:
```
clang -E xx.m -o xx.i
```
* “#define”删除并展开对应宏定义；
* 处理所有预编译指令：#if、#ifdef、#else、#endif；
* "#include、#import"包含的文件递归插入此处；
* 删除所有注释；
* 添加行号和文件名标识；
##### 2、编译：
**就是把预编译得到的.i文件进行：词法分析、语法分析、静态分析、优化生成相应的汇编代码**
```
clang -S xx.i -o xx.s
```
* 词法分析：顾名思义就是对每个词进行分析，把每一行代码分割成一个个token，主要是包括关键字、标识符变量名、字面量、特殊符号等。比如把变量名放到符号表等；
* 语法分析：生成抽象语法树AST。比如运算符优先级、括号匹配等；
* 静态分析：主要类型声明与匹配的问题。比如整形与字符串相加肯定会报错；
* 中间语言生成：这里是指根据AST自顶向下生成LLVM的IR语言（它是区别与源码和机器码的一种中间代码）
* 目标代码生成：根据IR生成依赖具体机器的汇编语言。
##### 3、汇编：
**把上面得到的.s文件里的汇编指令翻译成机器指令**
```
clang -C xx.s -o xx.o
```
##### 4、链接：
**把目标文件（一个或多个）和需要的库（静态库、动态库）链接成可执行文件Mach-O**

```
clang xx.o -o xx
```

#### Clang 和 LLVM
* LLVM是一个模块化可重用的编译器和工具链技术的集合。
LLVM IR 是一种“中间描述”。它是整个编译过程中有别于源码和机器码的中间代码。因此它是LLVM进行优化和代码生成的关键。LLVM的核心功能就是围绕IR建立的。
所以整个LLVM的编译架构就是：前端——>IR——>后端;所以这也让LLVM的扩展性做的非常好，如果需要支持一种新的编程语言，则只需要实现一种新的前端即可，如果要支持一种新的设备，则只需实现一个新的后端就好。
* Clang是LLVM的子项目，是C、C++、OC的前端编译器。
主要负责的工作就是上诉的编译流程：
预处理——词法分析——语法分析——静态分析——生成LLVM IR；

* OC采用Clang作为编译器前端，Swift采用Swift作为编译器前端，
swift编译器则是先生成一种SIL的中间代码，然后由SIL生成IR。

[LLVM and Clang](https://www.jianshu.com/p/037fb5002b77)
#### MachO文件
MachO文件是iOS和OS X操作系统的可执行文件格式。
因为不同的CPU平台支持的指令集不一样，所以通常不同的CPU对应不同格式的MachO文件，比如arm64和x86。**通用二进制文件**则是指多种架构下的Mach-O文件"打包"在一起。
通用二进制文件常用命令：
```
//查看通用二进制文件中的MachO文件信息
$ file bq 
$ otool -f -V bq

//lipo命令增、删、提取指定的MachO文件
//提取
$ lipo bq -extract armv7 -o bq_v7
//删除
$ lipo bq -remove armv7 -o bq_V7
//瘦身
$ lipo bq -thin armv7 -o bq_V7
```
MachO文件里主要就是代码和数据（全局变量）。而代码段和数据段是存在不一样的内存地址的，所以这个就需要**链接器**将其关联起来。

#### 静态库与动态库
* 静态库：以.a和.framework为后缀；链接是会被完整复制到可执行文件中，被多次使用就有多份拷贝；
* 动态库：以.tbd和.framework为后缀；链接时不复制，而是由运行时动态加载到内存，系统只加载一次，多个程序共用，比如UIKit.framework;


### WebView 及 前端 学习
#### JSBridge
https://juejin.im/post/5abca877f265da238155b6bc
#### JavaScriptCore 

<https://zhuanlan.zhihu.com/p/81634837>

#### WebCore

<https://blog.csdn.net/HorkyChen/article/details/8888428>

//接下来要学习
[被问千百遍的 TCP 三次握手和四次挥手面试题](https://www.cnblogs.com/xiaolincoding/p/12638546.html)
[一篇让你明白进程与线程之间的区别与联系](https://juejin.im/post/6844903801321685000)
[iOS高性能缓存框架](https://www.jianshu.com/p/4d0705595278)
[app启动性能优化](https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA)
[iOS项目编译时间](https://juejin.im/post/6844903940778115086)
[6月最新面经](https://zhuanlan.zhihu.com/p/198939499)
[6月面经2](https://www.jianshu.com/p/9fe59064220c)
[8月面经](https://www.jianshu.com/p/9447936dfb46)
[面经3](https://www.jianshu.com/p/939765be93a7)
[大厂面经](https://www.jianshu.com/p/bbd11d8b66f9)

[面经3](https://zhuanlan.zhihu.com/p/113816262)

[iOS 网络](https://www.jianshu.com/p/7aa730830238)
[看图学https](https://juejin.im/post/6844903608421449742)
[无侵入埋点组件](https://juejin.im/post/6867421879729127431)
[YBImageBrowser重构心得](https://cloud.tencent.com/developer/article/1466390)

[敏捷开发](https://juejin.im/post/6844904039822409735)

[kakaJson源码](https://github.com/FCF5646448/KakaJSON)

[高效使用单元测试](https://xiaozhuanlan.com/topic/3790216845)

[写好一个单例](https://juejin.im/post/6844903818216341517#heading-3)

[后台任务崩溃](https://www.jianshu.com/p/1fc5a2c676c6)

[深入理解swift派发机制](https://kemchenj.github.io/2016-12-25-1/)

[iOS性能优化](https://zhuanlan.zhihu.com/p/110545595)

[iOS性能优化2](https://zhuanlan.zhihu.com/p/181404556)

[iOS锁详解](https://juejin.im/post/6844904167010467854)

[iOS即时通讯](https://www.jianshu.com/p/2dbb360886a8)