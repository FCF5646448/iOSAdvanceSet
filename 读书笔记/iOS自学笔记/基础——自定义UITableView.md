

#### UIKit知识点

##### UIApplication

UIApplication对象的主要作用就是处理用户事件路由。同时维护APP打开窗口的列表。所以它可以获取到APP里的任何一个View。

#### 窗口和视图

视图（UIView）和窗口（UIWindow）展示了应用程序的界面，同时负责界面的交互。

* 视图架构

  一个视图（UIView）其实就是定义了屏幕上一个矩形区域，同时处理该区域的绘制和触屏事件。一个视图可以作为其他视图的父视图，同时决定着这些子视图的位置和大小；

  **每个视图（UIView）包含一个层对象（CALayer）支持，它管理着视图的显示和相关的动画**。视图（UIView）的绘制代码需要尽可能地少调用，所以绘制结果是会被Core Animation缓存起来的。很大地提升了性能；

* 视图层次及子视图管理

  视图可以作为其他视图的父视图。充当一个容器的作用。

  子视图会覆盖父视图部分区域。父视图通过一个有序数组存储子视图。存储的顺序会影响到每个子视图的显示效果。

  父视图尺寸、alpha值的改变会连带改变子视图的尺寸和位置。

  **视图层次也决定着响应事件的影响。一个视图的触摸事件会被直接发送到该视图去处理，如果没有处理，则会传递给它的父视图**。

* 视图绘制周期

  视图（UIView）第一次出现在屏幕前，系统会绘制自己的内容。在绘制过程中，系统会创建一个**快照**，如果绘制代码不被调用，那么就会一直使用这个快照。

  如果你改变了视图（UIView）内容，也不会立即重绘，而只是打上了**脏标记**。系统会等待当前RunLoop循环结束，统一进行绘制操作。

* 内容模式（contenmode）

  通常来说，当视图第一次显示时，会解释内容，生成位图。然后层级树会捕获这张位图。**在那之后，改变视图的几何结构不会导致重新创建位图**。

  当改变frame或bounds的宽高时，内容模式才会被应用。（也就是说通常情况下不会重绘，只是利用contentmode进行调整）

* 拉伸视图

  contentStretch属性定义一个视图的可拉伸区域。当然只有视图是允许被拉伸的内容模式下才能使用。

* 坐标系统

  frame是父视图坐标系统，所以原点是相对于父视图的原点位置；Center也是在父视图坐标系中的已知中心点；bounds则是自身坐标系统，原点永远是(0，0)，宽高和frame的一致。这三个属性，任一一个改变都会影响到其他两个。

  视图的框架默认不会被父视图剪裁，所以超过父视图外的尺寸都会被完整的解析。当然了，如果设置了clipstobounds,就会被剪裁。其次触摸事件总是发生在父视图的bounds内，位于父视图之外的部分，事件不会被截获。

* 运行时交互模型

  当用户与界面进行交互时，UIKit框架会将触摸事件打包成UIEvent对象，同时分发给合适的视图。

  改变视图或其子视图的属性（frame、bounds、alpha等）调用setNeedsLayout方法以标记该视图（或者其子视图）需要进行布局更新；调用setNeedsDisplay或者setNeedsDisplayInRect方法标记该视图需要进程重绘。

  如果一个视图的几何结构改变了，UIKit会根据不同情况来更新它的子视图：a：如果自动重设尺寸的规则在发生作用，UIKit会根据这些规则来调整视图；b、如果视图实现了layoutSubviews方法，UIKit会调用它，所以你可以在你的定制视图中覆盖这个方法同时用它来调整任何子视图的位置和大小。

  如果任何视图的任何部分被标记为需要重画，则UIKit会要求重画自身。

  

* 视图控制器
  视图控制器的工作是管理一个视图层次，而视图层次经常是包含了多个视图。
  视图的展示、协调视图的剔除，释放内存以响应低内存警告，翻转视图以响应界面方向变更等。

* 开发过程中的主要作用

  * 描画与动画

    * 视图负责对其所属的矩形区域进行描画

    * 某些视图属性变量可以以动画的形式过度到新的值

      

  

  

  

  







