---
title: 操作系统、内存、线程
date: 2020-6-29 7:03:00
tags:  basis software
categories: 软件基础
description:  希望自己像讲故事一样学习。（所有内容观点截止2009年——书本发布时间。但是无论在什么时期，理论应该是大致类似的）
---

### 操作系统
#### 基本硬件架构
对于程序开发者来说，最重要的硬件组成就是：CPU、内存、I/O(输入输出设备)控制芯片。
* 早期硬件架构
对于这三个硬件来说，运行速率最高的是CPU、其次是内存、其次是I/O。简单的早期计算机硬件模型中，使用PCI Bridge(北桥)**系统总线**连接所有高速设备（CPU、内存），PCI Bridge的频率与内存一致。然后使用ISA Bridge(南桥)**ISA 总线**连接磁盘、USB、键盘、鼠标等所有低速设备。
* SMP与多核
由于制造工艺的问题，CPU的运行频率到了4GHz的时候，就一直没法继续提升。于是就产生了**对称多处理器**，简单来说就是用增加CPU的数量来提高运行速率。

#### 基本计算机软件结构
计算机软件体系的一个设计要点就是：分层结构。最上层的是**应用程序**；应用程序使用**应用程序接口**调用**运行库**；运行库使用**系统调用接口**来访问**操作系统内核**；操作系统内核使用**硬件驱动程序**来使用硬件。

#### 操作系统的工作
操作系统的一个主要功能是提供抽象接口，另一个主要功能就是管理硬件资源。
* 让CPU不用打盹
早期操作系统使用时间片轮训的**分时系统**来处理任务，但是分时系统无法解决一个程序强占CPU的情况。所以就出现了**多任务系统**，多任务系统中，**每个应用程序都是以进程的方式运行在比操作系统权限更低的级别，每个进程都有自己的独立地址空间。CPU也由操作系统根据进程的优先级来统一分配，运行操过了一段时间，操作系统就会暂停进程。**
* 操作系统使用**硬件驱动程序**来管理和使用硬件。

### 内存
在多任务分时系统中，CPU和I/O都可以很好地处理进程间的共享问题，但是将有限的物理内存分配给多个进程使用则不是太容易。
#### 虚拟地址
将程序给定的地址作为**虚拟地址**，然后通过某些映射，将虚拟地址转换成实际物理地址。每个进程都有自己独立的虚拟地址空间，每个进程也只能访问自己的地址空间。这样就将进程之间的内存访问隔离开来了。
真正的内存使用过程中，每切换一个进程后，虚拟地址空间都得完全映射到物理地址中，比如程序A需要10KB内存，则就真正在物理地址中开辟10KB内存，然后将虚拟地址空间映射过去，程序执行的时候就可以想象成独享这一片内存。如果内存不足，则会先将正在使用内存的其他程序移出以空出内存供当前程序使用。
所以这也存在内存使用效率不高的情况。
#### 分页
分页就是将虚拟地址和物理地址都进行分页，每一页的大小是固定的。然后把常用的数据结构和代码页装载到内存中，把不常用的代码和数据保存到磁盘中。这样物理地址空间就可以供多个虚拟地址空间使用。也就提高了内存使用效率。

### 线程
线程是本书的重点！
线程是一个**轻量级的进程**，是程序的最小执行单元。一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。**一个进程由多个线程组成，各个线程之间共享程序的内存空间**。
#### 线程访问权限
线程可以访问进程内存中的所有数据。但是线程拥有自己的私有存储空间
* 栈：(比如局部变量)
* 线程局部存储TLS：(是指操作系统为线程单独提供的私有空间，比如iOS的ARC中Autorelease对象作为返回值时有使用TLS作为临时缓存)
* 寄存器：(比如函数参数)
#### 线程调度与优先级：
当线程数小于等于处理器数量时，是真正的并发，不同的线程运行在不同的处理器上，彼此不相干。但是当线程数量大于处理器数量时，则至少有一个处理器会运行多个线程。
在单个处理器处理多个线程时，操作系统会让这些线程轮流执行。这些线程的执行过程则是根据线程的状态进行调度。
* 运行
* 就绪
* 等待（阻塞）
  处于运行中的线程有一个时间片的运行时间。刚创建的线程，不会立即执行，会先进入**就绪**队列；当线程被分配到CPU时间后，线程进入到**运行**状态；在运行期间，如果碰到非常耗时的操作，则线程会被挂起进入**阻塞**状态，以让CPU可以执行其他任务。

##### 线程优先级
虽然所有的任务按照上述的方法轮流执行，但是有一些非常紧急的任务可能会需要先执行。所以这就需要让优先级高的任务优先执行，或者说让优先级高的任务优先进入就绪状态。但是由于某个优先级低的任务可能就存在**饿死**（一直得不到执行）的情况，所以优先级得动态调整。
* 用户指定优先级；
* 根据进入等待状态的频繁程度提升或降低优先级；
* 长时间得不到执行而被提升优先级；

#### 线程安全
如果多个线程同时操作一个数据，那么这个数据的结果就是不确定的。就导致了线程安全问题。
* **原子**操作：是指单条指令的操作。单条指令的操作是不会被打断的，所以具备线程安全。但是它只适用于一些简单的场合。如果是复杂的数据结构，则就需要用锁来保证数据操作的唯一性；
* **同步与锁**：同步就是说在有线程访问数据未结束时，其他线程不得对同一个数据进行访问。同步最常用的做法是**锁**。每一个线程访问数据之前先尝试**获取锁**，在访问结束时**释放锁**。在锁已经被其他线程占用时，线程会等待，直到锁重新可用。
##### 各种锁
* **信号量**：信号量是最简单的**锁**。一个初始值为N的信号量允许N个线程并发访问。线程访问资源时，首先获取信号量对信号量-1；如果信号量原本就小于0，则进入等待状态；访问完资源后，线程释放信号量，对信号进行+1。当信号量不为负值值，运行其他线程访问。
* **互斥量**：如果信号量只有0和1，则成为二进制信号量，**互斥量**和二进制信号量类似。但是**信号量运行一个线程获取之后由另一个线程释放**。但是**互斥量则要求哪个线程获取了互斥量，则哪个线程就得负责释放**。

##### 函数可重入
一个函数可重入，表示在函数没有执行完成时，又调用了一次该函数。一般只有两种情况会发生可重入：多个线程同时执行这个函数；函数自身调用了自身。
一个可重入的函数是线程安全的。

#### 多线程模型
用户实际使用的线程并不是系统内核线程，而是存在于用户态的用户线程。
* 一对一模型：就是一个用户线程唯一对应一个内核线程。线程之间的并发就是真正的并发。但是内核线程之间的上下文切换开销较大。而且一对一模型也导致线程数量有限。
* 多对一模型：多个用户线程映射到一个内核线程上。多对一模型可以高效地切换上下文和没有限制的线程数量。但是如果一个用户线程阻塞，那么其他线程也将无法执行。
* 多对多模型：多对多模型则综合了一对一模型和多对一模型的特点。

Q：为什么开辟子线程就一定更耗性能？
首先同一个进程中的所有线程都共享进程的内存空间，多开辟子线程也就意味着消耗更多的内存；其次线程之间的上下文切换也会开销很大。




